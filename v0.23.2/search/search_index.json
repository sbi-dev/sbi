{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>sbi</code>: simulation-based inference toolkit","text":"<p><code>sbi</code> is a Python package for simulation-based inference, designed to meet the needs of both researchers and practitioners. Whether you need fine-grained control or an easy-to-use interface, <code>sbi</code> has you covered.</p> <p>With <code>sbi</code>, you can perform parameter inference using Bayesian inference: Given a simulator that models a real-world process, SBI estimates the full posterior distribution over the simulator\u2019s parameters based on observed data. This distribution indicates the most likely parameter values while additionally quantifying uncertainty and revealing potential interactions between parameters.</p> <p><code>sbi</code> provides access to simulation-based inference methods via a user-friendly interface:</p> <pre><code>import torch\nfrom sbi.inference import NPE\n\n# define shifted Gaussian simulator.\ndef simulator(\u03b8): return \u03b8 + torch.randn_like(\u03b8)\n# draw parameters from Gaussian prior.\n\u03b8 = torch.randn(1000, 2)\n# simulate data\nx = simulator(\u03b8)\n\n# choose sbi method and train\ninference = NPE()\ninference.append_simulations(\u03b8, x).train()\n\n# do inference given observed data\nx_o = torch.ones(2)\nposterior = inference.build_posterior()\nsamples = posterior.sample((1000,), x=x_o)\n</code></pre>"},{"location":"#overview","title":"Overview","text":"<p>To get started, install the <code>sbi</code> package with:</p> <pre><code>pip install sbi\n</code></pre> <p>for more advanced install options, see our Install Guide.</p> <p>Then, check out our material:</p> <ul> <li> <p> Motivation and approach General motivation for the SBI framework and methods included in <code>sbi</code>.</p> </li> <li> <p> Tutorials and Examples Various examples illustrating how to get    started or use the <code>sbi</code> package.</p> </li> <li> <p> Reference API The detailed description of the package classes and functions.</p> </li> <li> <p> Citation How to cite the <code>sbi</code> package.</p> </li> </ul>"},{"location":"#motivation-and-approach","title":"Motivation and approach","text":"<p>Many areas of science and engineering make extensive use of complex, stochastic, numerical simulations to describe the structure and dynamics of the processes being investigated.</p> <p>A key challenge in simulation-based science is constraining these simulation models\u2019 parameters, which are interpretable quantities, with observational data. Bayesian inference provides a general and powerful framework to invert the simulators, i.e. describe the parameters that are consistent both with empirical data and prior knowledge.</p> <p>In the case of simulators, a key quantity required for statistical inference, the likelihood of observed data given parameters, \\(\\mathcal{L}(\\theta) = p(x_o|\\theta)\\), is typically intractable, rendering conventional statistical approaches inapplicable.</p> <p><code>sbi</code> implements powerful machine-learning methods that address this problem. Roughly, these algorithms can be categorized as:</p> <ul> <li>Neural Posterior Estimation (amortized <code>NPE</code> and sequential <code>SNPE</code>),</li> <li>Neural Likelihood Estimation (<code>(S)NLE</code>), and</li> <li>Neural Ratio Estimation (<code>(S)NRE</code>).</li> </ul> <p>Depending on the characteristics of the problem, e.g. the dimensionalities of the parameter space and the observation space, one of the methods will be more suitable.</p> <p></p> <p>Goal: Algorithmically identify mechanistic models that are consistent with data.</p> <p>Each of the methods above needs three inputs: A candidate mechanistic model, prior knowledge or constraints on model parameters, and observational data (or summary statistics thereof).</p> <p>The methods then proceed by</p> <ol> <li>sampling parameters from the prior followed by simulating synthetic data from    these parameters,</li> <li>learning the (probabilistic) association between data (or data features) and    underlying parameters, i.e. to learn statistical inference from simulated    data. How this association is learned differs between the above methods, but    all use deep neural networks.</li> <li>This learned neural network is then applied to empirical data to derive the    full space of parameters consistent with the data and the prior, i.e. the    posterior distribution. The posterior assigns high probability to parameters    that are consistent with both the data and the prior, and low probability to    inconsistent parameters. While NPE directly learns the posterior    distribution, NLE and NRE need an extra MCMC sampling step to construct a    posterior.</li> <li>If needed, an initial estimate of the posterior can be used to adaptively    generate additional informative simulations.</li> </ol> <p>See Cranmer, Brehmer, Louppe (2020) for a recent review on simulation-based inference.</p>"},{"location":"#implemented-algorithms","title":"Implemented algorithms","text":"<p><code>sbi</code> implements a variety of amortized and sequential SBI methods.</p> <p>Amortized methods return a posterior that can be applied to many different observations without retraining (e.g., NPE), whereas sequential methods focus the inference on one particular observation to be more simulation-efficient (e.g., SNPE).</p> <p>Below, we list all implemented methods and the corresponding publications. To see how to access these methods in <code>sbi</code>, check out our Inference API\u2019s reference and the tutorial on implemented methods.</p>"},{"location":"#posterior-estimation-snpe","title":"Posterior estimation (<code>(S)NPE</code>)","text":"<ul> <li> <p>Fast \u03b5-free Inference of Simulation Models with Bayesian Conditional Density   Estimation by Papamakarios &amp; Murray (NeurIPS 2016)   [PDF] [BibTeX]</p> </li> <li> <p>Flexible statistical inference for mechanistic models of neural dynamics  by Lueckmann, Goncalves, Bassetto, \u00d6cal, Nonnenmacher &amp; Macke (NeurIPS   2017)   [PDF] [BibTeX]</p> </li> <li> <p>Automatic posterior transformation for likelihood-free inference by Greenberg, Nonnenmacher &amp; Macke (ICML 2019) [PDF] [BibTeX]</p> </li> <li> <p>BayesFlow: Learning complex stochastic models with invertible neural   networks by Radev, S. T., Mertens, U. K., Voss, A., Ardizzone, L., &amp; K\u00f6the, U. (IEEE transactions on neural networks and learning systems 2020) [Paper]</p> </li> <li> <p>Truncated proposals for scalable and hassle-free simulation-based   inference  by Deistler, Goncalves &amp; Macke (NeurIPS 2022)   [Paper]</p> </li> <li> <p>Flow matching for scalable simulation-based inference by Dax, M., Wildberger,   J., Buchholz, S., Green, S. R., Macke, J. H., &amp; Sch\u00f6lkopf, B. (NeurIPS, 2023) [Paper]</p> </li> <li> <p>Compositional Score Modeling for Simulation-Based Inference by Geffner, T.,   Papamakarios, G., &amp; Mnih, A. (ICML 2023) [Paper]</p> </li> </ul>"},{"location":"#likelihood-estimation-snle","title":"Likelihood-estimation (<code>(S)NLE</code>)","text":"<ul> <li> <p>Sequential neural likelihood: Fast likelihood-free inference with   autoregressive flows by Papamakarios, Sterratt &amp; Murray (AISTATS 2019)   [PDF] [BibTeX]</p> </li> <li> <p>Variational methods for simulation-based inference  by Gl\u00f6ckler,   Deistler, Macke (ICLR 2022) [Paper]</p> </li> <li> <p>Flexible and efficient simulation-based inference for models of   decision-making  by Boelts, Lueckmann, Gao, Macke (Elife 2022)   [Paper]</p> </li> </ul>"},{"location":"#likelihood-ratio-estimation-snre","title":"Likelihood-ratio-estimation (<code>(S)NRE</code>)","text":"<ul> <li> <p>Likelihood-free MCMC with Amortized Approximate Likelihood Ratios by   Hermans, Begy &amp; Louppe (ICML 2020)   [PDF]</p> </li> <li> <p>On Contrastive Learning for Likelihood-free Inference by Durkan,   Murray &amp; Papamakarios (ICML 2020)   [PDF]</p> </li> <li> <p>Towards Reliable Simulation-Based Inference with Balanced Neural Ratio   Estimation by Delaunoy, Hermans, Rozet, Wehenkel &amp; Louppe (NeurIPS 2022)   [PDF]</p> </li> <li> <p>Contrastive Neural Ratio Estimation by Benjamin Kurt Miller, Christoph   Weniger &amp; Patrick Forr\u00e9 (NeurIPS 2022)   [PDF]</p> </li> </ul>"},{"location":"#diagnostics","title":"Diagnostics","text":"<ul> <li> <p>Simulation-based calibration by Talts, Betancourt, Simpson, Vehtari,   Gelman (arxiv 2018)[Paper]</p> </li> <li> <p>Expected coverage (sample-based) as computed in Deistler, Goncalves, &amp;   Macke (NeurIPS 2022)[Paper] and in   Rozet &amp; Louppe [Paper]</p> </li> <li> <p>Local C2ST by Linhart, Gramfort &amp; Rodrigues (NeurIPS   2023)[Paper]</p> </li> <li> <p>TARP by Lemos, Coogan, Hezaveh &amp; Perreault-Levasseur (ICML   2023)[Paper]</p> </li> </ul>"},{"location":"citation/","title":"Citation","text":"<p>If you use <code>sbi</code> consider citing the sbi software paper, in addition to the original research articles describing the specific sbi-algorithm(s) you are using.</p> <pre><code>@article{tejero-cantero2020sbi,\n  doi = {10.21105/joss.02505},\n  url = {https://doi.org/10.21105/joss.02505},\n  year = {2020},\n  publisher = {The Open Journal},\n  volume = {5},\n  number = {52},\n  pages = {2505},\n  author = {Alvaro Tejero-Cantero and Jan Boelts and Michael Deistler and Jan-Matthis Lueckmann and Conor Durkan and Pedro J. Gon\u00e7alves and David S. Greenberg and Jakob H. Macke},\n  title = {sbi: A toolkit for simulation-based inference},\n  journal = {Journal of Open Source Software}\n}\n</code></pre> <p>The above citation refers to the original version of the <code>sbi</code> project and has a persistent DOI. Additionally, new releases of <code>sbi</code> are citable via Zenodo, where we create a new DOI for every release.</p>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others\u2019 confidential information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct that could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Representing our community includes using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting <code>sbi</code> developer Jan Boelts via email (jan.boelts@mailbox.org) or anonymously via https://forms.gle/AEmwEznWAKdvrBQbA. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla\u2019s code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contribute/","title":"How to contribute","text":"<p>Important</p> <p>By participating in the <code>sbi</code> community, all members are expected to comply with our Code of Conduct. This ensures a positive and inclusive environment for everyone involved.</p>"},{"location":"contribute/#user-experiences-bugs-and-feature-requests","title":"User experiences, bugs, and feature requests","text":"<p>If you are using <code>sbi</code> to infer the parameters of a simulator, we would be delighted to know how it worked for you. If it didn\u2019t work according to plan, please open up an issue or discussion and tell us more about your use case: the dimensionality of the input parameters and of the output, as well as the setup you used to run inference (i.e., number of simulations, number of rounds, etc.).</p> <p>To report bugs and suggest features \u2013 including better documentation \u2013 please equally head over to issues on GitHub and tell us everything.</p>"},{"location":"contribute/#contributing-code","title":"Contributing code","text":"<p>Contributions to the <code>sbi</code> package are always welcome! The preferred way to do it is via pull requests onto our main repository. To give credit to contributors, we consider adding contributors who repeatedly and substantially contributed to <code>sbi</code> to the list of authors of the package at the end of every year. Additionally, we mention all contributors in the releases.</p> <p>Note</p> <p>To avoid doing duplicated work, we strongly suggest that you go take a look at our current open issues and pull requests to see if someone else is already doing it. Also, in case you\u2019re planning to work on something that has not yet been proposed by others (e.g. adding a new feature, adding a new example), it is preferable to first open a new issue explaining what you intend to propose and then working on your pull request after getting some feedback from others.</p>"},{"location":"contribute/#contribution-workflow","title":"Contribution workflow","text":"<p>The following steps describe all parts of the workflow for doing a contribution such as installing locally <code>sbi</code> from source, creating a <code>conda</code> environment, setting up your <code>git</code> repository, etc. We\u2019ve taken strong inspiration from the contribution guides of <code>scikit-learn</code> and <code>mne</code>:</p> <p>Step 1: Create an account on GitHub if you do not already have one.</p> <p>Step 2: Fork the project repository: click on the \u2018Fork\u2019 button near the top of the page. This will create a copy of the <code>sbi</code> codebase under your GitHub user account. See more details on how to fork a repository here.</p> <p>Step 3: Clone your fork of the <code>sbi</code> repo from your GitHub account to your local disk: <pre><code>git clone git@github.com:$USERNAME/sbi.git\ncd sbi\n</code></pre></p> <p>Step 4: Install a recent version of Python (we currently recommend 3.10) for instance using <code>miniforge</code>. We strongly recommend you create a specific <code>conda</code> environment for doing development on <code>sbi</code> as per: <pre><code>conda create -n sbi_dev python=3.10\nconda activate sbi_dev\n</code></pre></p> <p>Step 5: Install <code>sbi</code> in editable mode with <pre><code>pip install -e \".[dev]\"\n</code></pre> This installs the <code>sbi</code> package into the current environment by creating a link to the source code directory (instead of copying the code to pip\u2019s <code>site_packages</code> directory, which is what normally happens). This means that any edits you make to the <code>sbi</code> source code will be reflected the next time you open a Python interpreter and <code>import sbi</code> (the <code>-e</code> flag of pip stands for an \u201ceditable\u201d installation, and the <code>dev</code> flag installs development and testing dependencies). This requires at least Python 3.8.</p> <p>Step 6: Add the upstream remote. This saves a reference to the main <code>sbi</code> repository, which you can use to keep your repository synchronized with the latest changes: <pre><code>git remote add upstream git@github.com:sbi-dev/sbi.git\n</code></pre> Check that the upstream and origin remote aliases are configured correctly by running <code>git remote -v</code> which should display: <pre><code>origin  git@github.com:$USERNAME/sbi.git (fetch)\norigin  git@github.com:$USERNAME/sbi.git (push)\nupstream        git@github.com:sbi-dev/sbi.git (fetch)\nupstream        git@github.com:sbi-dev/sbi.git (push)\n</code></pre></p> <p>Step 7: Install <code>pre-commit</code> to run code style checks before each commit: <pre><code>pip install pre-commit\npre-commit install\n</code></pre></p> <p>You should now have a working installation of <code>sbi</code> and a git repository properly configured for making contributions. The following steps describe the process of modifying code and submitting a pull request:</p> <p>Step 8: Synchronize your main branch with the upstream/main branch. See more details on GitHub Docs: <pre><code>git checkout main\ngit fetch upstream\ngit merge upstream/main\n</code></pre></p> <p>Step 9: Create a feature branch to hold your development changes: <pre><code>git checkout -b my_feature\n</code></pre> and start making changes. Always use a feature branch! It\u2019s good practice to never work on the main branch, as this allows you to easily get back to a working state of the code if needed (e.g., if you\u2019re working on multiple changes at once, or need to pull in recent changes from someone else to get your new feature to work properly). In most cases you should make PRs into the upstream\u2019s main branch.</p> <p>Step 10: Develop your code on your feature branch on the computer, using Git to do the version control. When you\u2019re done editing, add changed files using <code>git add</code> and then <code>git commit</code> to record your changes: <pre><code>git add modified_files\ngit commit -m \"description of your commit\"\n</code></pre> Then push the changes to your GitHub account with: <pre><code>git push -u origin my_feature\n</code></pre> The <code>-u</code> flag ensures that your local branch will be automatically linked with the remote branch, so you can later use <code>git push</code> and <code>git pull</code> without any extra arguments.</p> <p>Step 11: Follow these instructions to create a pull request from your fork. This will send a notification to <code>sbi</code> maintainers and trigger reviews and comments regarding your contribution.</p> <p>Note</p> <p>It is often helpful to keep your local feature branch synchronized with the latest changes of the main <code>sbi</code> repository: <pre><code>git fetch upstream\ngit merge upstream/main\n</code></pre></p>"},{"location":"contribute/#style-conventions-and-testing","title":"Style conventions and testing","text":"<p>All our docstrings and comments are written following the Google Style.</p> <p>For code linting and formating, we use <code>ruff</code>, which is installed alongside <code>sbi</code>.</p> <p>You can exclude slow tests and those which require a GPU with <pre><code>pytest -m \"not slow and not gpu\"\n</code></pre> Additionally, we recommend to run tests with <pre><code>pytest -n auto -m \"not slow and not gpu\"\n</code></pre> in parallel. GPU tests should probably not be run this way. If you see unexpected behavior (tests fail if they shouldn\u2019t), try to run them without <code>-n auto</code> and see if it persists. When writing new tests and debugging things, it may make sense to also run them without <code>-n auto</code>.</p> <p>When you create a PR onto <code>main</code>, our Continuous Integration (CI) actions on GitHub will perform the following checks:</p> <ul> <li><code>ruff</code> for linting and formatting   (including <code>black</code>, <code>isort</code>, and <code>flake8</code>)</li> <li><code>pyright</code> for static type checking.</li> <li><code>pytest</code> for running a subset of   fast tests from our test suite.</li> </ul> <p>If any of these fail, try reproducing and solving the error locally:</p> <ul> <li><code>ruff</code>: Make sure you have <code>pre-commit</code> installed locally with the same version as  specified in the  <code>pyproject.toml</code>. Execute it   using <code>pre-commit run --all-files</code>. <code>ruff</code> tends to give informative error messages   that help you fix the problem. Note that pre-commit only detects problems with <code>ruff</code>   linting and formatting, but does not fix them. You can fix them either by running   <code>ruff check . --fix(linting)</code>, followed by <code>ruff format . --fix(formatting)</code>, or by   hand.</li> <li><code>pyright</code>: Run it locally using <code>pyright sbi/</code> and ensure you are using the same   <code>pyright</code> version as used in the CI (which is the case if you have installed   it with <code>pip install -e \".[dev]\"</code> but note that you have to rerun it once   someone updates the version in the <code>pyproject.toml</code>).</li> <li>Known issues and fixes:<ul> <li>If using <code>**kwargs</code>, you either have to specify all possible types of <code>kwargs</code>, e.g. <code>**kwargs: Union[int, boolean]</code> or use <code>**kwargs: Any</code></li> </ul> </li> <li><code>pytest</code>: On GitHub Actions you can see which test failed. Reproduce it locally, e.g., using <code>pytest -n auto tests/linearGaussian_snpe_test.py</code>. Note that this will run for a few minutes and should result in passes and expected fails (xfailed).</li> <li>Commit and push again until CI tests pass. Don\u2019t hesitate to ask for help by   commenting on the PR.</li> </ul>"},{"location":"contribute/#contributing-to-the-documentation","title":"Contributing to the documentation","text":"<p>Most of the documentation for <code>sbi</code> is written in markdown and the website is generated using <code>mkdocs</code> with <code>mkdocstrings</code> and <code>mike</code>. The tutorials and examples are converted from jupyter notebooks into markdown files to be shown on the website. To work on improvements of the documentation, you should first  install the <code>doc</code> dependencies:</p> <pre><code>pip install -e \".[doc]\"\n</code></pre> <p>Then, you can build the website locally by executing in the <code>docs</code> folder</p> <pre><code>mkdocs serve\n</code></pre> <p>This will build the website on a local host address shown in the terminal. Changes to the website files or a browser refresh will immediately rebuild the website.</p> <p>If you updated the tutorials or examples, you need to convert them to markdown first:</p> <pre><code>cd docs\njupyter nbconvert --to markdown ../tutorials/*.ipynb --output-dir docs/tutorials/\nmkdocs serve\n</code></pre>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#community-and-contributions","title":"Community and Contributions","text":"<p><code>sbi</code> is a community-driven package. We are grateful to all our contributors who have played a significant role in shaping <code>sbi</code>. Their valuable input, suggestions, and direct contributions to the codebase have been instrumental in the development of <code>sbi</code>.</p>"},{"location":"credits/#license","title":"License","text":"<p><code>sbi</code> is licensed under the Apache License (Apache-2.0) and</p> <p>Copyright (C) 2020 \u00c1lvaro Tejero-Cantero, Jakob H. Macke, Jan-Matthis L\u00fcckmann, Michael Deistler, Jan F. B\u00f6lts.</p> <p>Copyright (C) 2020 Conor M. Durkan.</p> <p>All contributors hold the copyright of their specific contributions.</p>"},{"location":"credits/#support","title":"Support","text":"<p><code>sbi</code> has been supported by the German Federal Ministry of Education and Research (BMBF) through project ADIMEM (FKZ 01IS18052 A-D), project SiMaLeSAM (FKZ 01IS21055A) and the T\u00fcbingen AI Center (FKZ 01IS18039A). Since 2024, <code>sbi</code> has been supported by the appliedAI Institute for Europe gGmbH.</p> <p></p>"},{"location":"credits/#important-dependencies-and-prior-art","title":"Important dependencies and prior art","text":"<ul> <li><code>sbi</code> is the successor to <code>delfi</code>, a Theano-based   toolbox for sequential neural posterior estimation developed at   mackelab.If you were using <code>delfi</code>, we strongly recommend   moving your inference over to <code>sbi</code>. Please open issues if you find unexpected   behavior or missing features. We will consider these bugs and give them priority.</li> <li><code>sbi</code> as a PyTorch-based toolbox started as a fork of   conormdurkan/lfi, by Conor   M.Durkan.</li> <li><code>sbi</code> uses <code>PyTorch</code> and tries to align with the interfaces (e.g. for probability   distributions) adopted by <code>PyTorch</code>.</li> <li>See README.md for a   list of publications describing the methods implemented in <code>sbi</code>.</li> </ul>"},{"location":"faq/","title":"Frequently asked questions","text":"<ol> <li>What should I do when my \u2018posterior samples are outside of the prior support\u2019 in SNPE?</li> <li>Can the algorithms deal with invalid data, e.g., NaN or inf?</li> <li>When using multiple workers, I get a pickling error. Can I still use multiprocessing?</li> <li>Can I use the GPU for training the density estimator?</li> <li>How should I save and load objects in <code>sbi</code>?</li> <li>Can I stop neural network training and resume it later?</li> <li>How can I use a prior that is not defined in PyTorch?</li> </ol> <p>See also discussion page and issue tracker on the <code>sbi</code> GitHub repository for recent questions and problems.</p>"},{"location":"install/","title":"Installation","text":"<p><code>sbi</code> requires Python 3.8 or higher. A GPU is not required, but can lead to speed-up in some cases. We recommend using a <code>conda</code> virtual environment (Miniconda installation instructions). If <code>conda</code> is installed on the system, an environment for installing <code>sbi</code> can be created as follows:</p> <pre><code># Create an environment for sbi (indicate Python 3.8 or higher); activate it\n$ conda create -n sbi_env python=3.10 &amp;&amp; conda activate sbi_env\n</code></pre> <p>Independent of whether you are using <code>conda</code> or not, <code>sbi</code> can be installed using <code>pip</code>:</p> <pre><code>pip install sbi\n</code></pre> <p>To test the installation, drop into a Python prompt and run</p> <pre><code>from sbi.examples.minimal import simple\nposterior = simple()\nprint(posterior)\n</code></pre>"},{"location":"faq/question_01_leakage/","title":"What should I do when my \u2018posterior samples are outside the prior support\u2019 in SNPE?","text":"<p>When working with multi-round NPE (i.e., SNPE), you might have experienced the following warning:</p> <pre><code>Only x% posterior samples are within the prior support. It may take a long time to\ncollect the remaining 10000 samples. Consider interrupting (Ctrl-C) and switching to\n'sample_with_mcmc=True'.\n</code></pre> <p>The reason for this issue is described in more detail here, here, and here. The following fixes are possible:</p> <ul> <li> <p>use truncated proposals for SNPE (TSNPE) <pre><code>from sbi.inference import NPE\nfrom sbi.utils import RestrictedPrior, get_density_thresholder\n\ninference = NPE(prior)\nproposal = prior\nfor _ in range(num_rounds):\n    theta = proposal.sample((num_sims,))\n    x = simulator(theta)\n    _ = inference.append_simulations(theta, x).train(force_first_round_loss=True)\n    posterior = inference.build_posterior().set_default_x(x_o)\n\n    accept_reject_fn = get_density_thresholder(posterior, quantile=1e-4)\n    proposal = RestrictedPrior(prior, accept_reject_fn, sample_with=\"rejection\")\n</code></pre></p> </li> <li> <p>sample with MCMC: <code>samples = posterior((num_samples,), x=x_o, sample_with_mcmc=True)</code>. This approach will make sampling slower, but samples will not \u201cleak\u201d.</p> </li> <li> <p>resort to single-round NPE and (if necessary) increase your simulation budget.</p> </li> <li> <p>if your prior is either Gaussian (torch.distributions.MultivariateNormal) or Uniform (sbi.utils.BoxUniform), you can avoid leakage by using a mixture density network as density estimator. I.e., set <code>density_estimator='mdn'</code> when creating the <code>SNPE</code> inference object. When running inference, there should be a print statement \u201cUsing SNPE-C with non-atomic loss\u201d.</p> </li> <li> <p>use a different algorithm, e.g., Sequential NRE and Sequential NLE. Note, however, that these algorithms can have different issues and potential pitfalls.</p> </li> </ul>"},{"location":"faq/question_02_nans/","title":"Can the algorithms deal with invalid data, e.g., NaN or inf?","text":"<p>Yes. By default, whenever a simulation returns at least one <code>NaN</code> or <code>inf</code>, it is completely excluded from the training data. In other words, the simulation is simply discarded.</p> <p>In cases where a very large fraction of simulations return <code>NaN</code> or <code>inf</code>, discarding many simulations can be wasteful. There are two options to deal with this: Either you use the <code>RestrictionEstimator</code> to learn regions in parameter space that do not produce <code>NaN</code> or <code>inf</code>, see here. Alternatively, you can manually substitute the \u2018invalid\u2019 values with a reasonable replacement. For example, at the end of your simulation code, you search for invalid entries and replace them with a floating point number. Importantly, in order for neural network training work well, the floating point number should still be in a reasonable range, i.e., maybe a few standard deviations outside of \u2018good\u2019 values.</p> <p>If you are running multi-round NPE (SNPE), however, things can go fully wrong if invalid data are encountered. In that case, you will get the following warning</p> <pre><code>When invalid simulations are excluded, multi-round SNPE-C can leak into the regions\nwhere parameters led to invalid simulations. This can lead to poor results.\n</code></pre> <p>Hence, if you are running multi-round NPE and a significant fraction of simulations returns at least one invalid number, we strongly recommend manually replacing the value in your simulation code as described above (or resorting to single-round NPE, or using a different <code>sbi</code> method entirely).</p>"},{"location":"faq/question_03_pickling_error/","title":"When using multiple workers, I get a pickling error. Can I still use multiprocessing?","text":"<p>Yes, but you will have to make a few adjustments to your code.</p> <p>Some background: When using <code>num_workers &gt; 1</code>, you might experience an error that a certain object from your simulator could not be pickled (an example can be found here).</p> <p>This can be fixed by forcing <code>sbi</code> to pickle with <code>dill</code> instead of the default <code>cloudpickle</code>. To do so, adjust your code as follows:</p> <ul> <li>Install <code>dill</code>:</li> </ul> <pre><code>pip install dill\n</code></pre> <ul> <li>At the very beginning of your python script, set the pickler to <code>dill</code>:</li> </ul> <pre><code>from joblib.externals.loky import set_loky_pickler\nset_loky_pickler(\"dill\")\n</code></pre> <ul> <li>Move all imports required by your simulator into the simulator:</li> </ul> <pre><code># Imports specified outside of the simulator will break dill:\nimport torch\ndef my_simulator(parameters):\n    return torch.ones(1,10)\n\n# Therefore, move the imports into the simulator:\ndef my_simulator(parameters):\n    import torch\n    return torch.ones(1,10)\n</code></pre>"},{"location":"faq/question_03_pickling_error/#alternative-parallelize-yourself","title":"Alternative: parallelize yourself","text":"<p>You can also write your own code to parallelize simulations with whatever multiprocessing framework you prefer. You can then simulate your data outside of <code>sbi</code> and pass the simulated data using <code>.append_simulations</code>:</p> <pre><code># Given pre-simulated theta and x\ntrainer = SNPE(prior)\ntrainer.append_simulations(theta, x).train()\n</code></pre>"},{"location":"faq/question_03_pickling_error/#some-more-background","title":"Some more background","text":"<p><code>sbi</code> uses <code>joblib</code> to parallelize simulations, which in turn uses <code>pickle</code> or <code>cloudpickle</code> to serialize the simulator. Almost all simulators will be picklable with <code>cloudpickle</code>, but we have experienced issues, e.g., with <code>neuron</code> simulators, see here.</p>"},{"location":"faq/question_04_gpu/","title":"Can I use the GPU for training the density estimator?","text":"<p>TLDR; Yes, by passing <code>device=\"cuda\"</code> and by passing a prior that lives on the device name you passed. But we expect no speed-ups for default density estimators.</p>"},{"location":"faq/question_04_gpu/#setup","title":"Setup","text":"<p>Yes, we support GPU training. When creating the inference object in the flexible interface, you can pass the <code>device</code> as an argument, e.g.,</p> <pre><code>inference = NPE(prior, device=\"cuda\", density_estimator=\"maf\")\n</code></pre> <p>The device is set to <code>\"cpu\"</code> by default. But it can be set to anything, as long as it maps to an existing PyTorch GPU device, e.g., <code>device=\"cuda\"</code> or <code>device=\"cuda:2\"</code>. <code>sbi</code> will take care of copying the <code>net</code> and the training data to and from the <code>device</code>. We also support MPS as a GPU device for GPU-accelarated training on an Apple Silicon chip, e.g., it is possible to pass <code>device=\"mps\"</code>.</p> <p>Note that the prior must be on the training device already, e.g., when passing <code>device=\"cuda:0\"</code>, make sure to pass a prior object that was created on that device, e.g.,</p> <pre><code>prior = torch.distributions.MultivariateNormal(loc=torch.zeros(2,\ndevice=\"cuda:0\"), covariance_matrix=torch.eye(2, device=\"cuda:0\"))\n</code></pre>"},{"location":"faq/question_04_gpu/#performance","title":"Performance","text":"<p>Whether or not you reduce your training time when training on a GPU depends on the problem at hand. We provide a couple of default density estimators for <code>NPE</code>, <code>NLE</code> and <code>NRE</code>, e.g., a mixture density network (<code>density_estimator=\"mdn\"</code>) or a Masked Autoregressive Flow (<code>density_estimator=\"maf\"</code>). For these default density estimators, we do not expect a speed-up. This is because the underlying neural networks are relatively shallow and not tall, e.g., they do not have many parameters or matrix operations that benefit from being executed on the GPU.</p> <p>A speed-up through training on the GPU will most likely become visible when using convolutional modules in your neural networks. E.g., when passing an embedding net for image processing like in this example: https://github.com/sbi-dev/sbi/blob/main/tutorials/05_embedding_net.ipynb.</p>"},{"location":"faq/question_05_pickling/","title":"How should I save and load objects in <code>sbi</code>?","text":"<p><code>NeuralPosterior</code> objects are picklable.</p> <pre><code>import pickle\n\n# ... run inference\nposterior = inference.build_posterior()\n\nwith open(\"/path/to/my_posterior.pkl\", \"wb\") as handle:\n    pickle.dump(posterior, handle)\n</code></pre> <p>Note: posterior objects that were saved under <code>sbi v0.22.0</code> or older cannot be loaded under <code>sbi v0.23.0</code> or newer.</p> <p>Note: posterior objects that were saved under <code>sbi v0.17.2</code> or older cannot be loaded under <code>sbi v0.18.0</code> or newer.</p> <p>Note: if you try to load a posterior that was saved under <code>sbi v0.14.x</code> or earlier under <code>sbi v0.15.x</code> until <code>sbi v0.17.x</code>, you have to add:</p> <pre><code>import sys\nfrom sbi.utils import user_input_checks_utils\n\nsys.modules[\"sbi.user_input.user_input_checks_utils\"] = user_input_checks_utils\n</code></pre> <p>to your script before loading the posterior.</p> <p>As of <code>sbi v0.18.0</code>, <code>NeuralInference</code> objects are also picklable.</p> <pre><code>import pickle\n\n# ... run inference\nposterior = inference.build_posterior()\n\nwith open(\"/path/to/my_inference.pkl\", \"wb\") as handle:\n    pickle.dump(inference, handle)\n</code></pre> <p>However, saving and loading the <code>inference</code> object will slightly modify the object (in order to make it serializable). These modifications lead to the following two changes in behavior:</p> <p>1) Retraining from scratch is not supported, i.e. <code>.train(...,    retrain_from_scratch=True)</code> does not work. 2) When the loaded object calls the <code>.train()</code> method, it generates a new    tensorboard summary writer (instead of appending to the current one).</p>"},{"location":"faq/question_05_pickling/#i-trained-a-model-on-a-gpu-can-i-load-it-on-a-cpu","title":"I trained a model on a GPU. Can I load it on a CPU?","text":"<p>The code snippet below allows to load inference objects on a CPU if they were saved on a GPU. Note that the neural net also needs to be moved to CPU.</p> <pre><code>import io\nimport pickle\n\n#https://stackoverflow.com/questions/57081727/load-pickle-file-obtained-from-gpu-to-cpu\nclass CPU_Unpickler(pickle.Unpickler):\n    def find_class(self, module, name):\n        if module == 'torch.storage' and name == '_load_from_bytes':\n            return lambda b: torch.load(io.BytesIO(b), map_location='cpu')\n        else:\n            return super().find_class(module, name)\n\nwith open(\"/path/to/my_inference.pkl\", \"rb\") as f:\n    inference = CPU_Unpickler(f).load()\n\nposterior = inference.build_posterior(inference._neural_net.to(\"cpu\"))\n</code></pre> <p>Loading inference objects on CPU can be useful for inspection. However, resuming training on CPU for an inference object trained on a GPU is currently not supported. If this is strictly required by your workflow, consider setting <code>inference._device = \"cpu\"</code> before calling <code>inference.train()</code>.</p>"},{"location":"faq/question_06_resume_training/","title":"Can I stop neural network training and resume it later?","text":"<p>Many clusters have a time limit, and <code>sbi</code> might exceed this limit. You can circumvent this problem by stopping and resuming training:</p> <pre><code>inference = NPE(prior=prior)\ninference = inference.append_simulations(theta, x)\ninference.train(max_num_epochs=300)  # Pick `max_num_epochs` such that it does not exceed the runtime.\n\nwith open(\"path/to/my/inference.pkl\", \"wb\") as handle:\n    pickle.dump(inference, handle)\n\n# To resume training:\nwith open(\"path/to/my/inference.pkl\", \"rb\") as handle:\n    inference_from_disk = pickle.load(handle)\ninference_from_disk.train(resume_training=True, max_num_epochs=600)  # Run epochs 301 until 600 (or stop early).\nposterior = inference_from_disk.build_posterior()\n</code></pre>"},{"location":"faq/question_07_custom_prior/","title":"Can I use a custom prior with sbi?","text":"<p>As <code>sbi</code> works with torch distributions only, we recommend using those whenever possible. For example, when you are used to using <code>scipy.stats</code> distributions as priors, then we recommend using the corresponding <code>torch.distributions</code> instead. Most <code>scipy</code> distributions are implemented in <code>PyTorch</code> as well.</p> <p>In case you want to use a custom prior that is not in the set of common distributions that\u2019s possible as well: You need to write a prior class that mimicks the behaviour of a <code>torch.distributions.Distribution</code> class. <code>sbi</code> will wrap this class to make it a fully functional torch <code>Distribution</code>.</p> <p>Essentially, the class needs two methods:</p> <ul> <li><code>.sample(sample_shape)</code>, where sample_shape is a shape tuple, e.g., <code>(n,)</code>,   and returns a batch of n samples, e.g., of shape (n, 2)` for a two dimenional   prior.</li> <li><code>.log_prob(value)</code> method that returns the \u201clog probs\u201d of parameters under the   prior, e.g., for a batches of n parameters with shape <code>(n, ndims)</code> it should   return a log probs array of shape <code>(n,)</code>.</li> </ul> <p>For <code>sbi</code> &gt; 0.17.2 this could look like the following:</p> <pre><code>class CustomUniformPrior:\n    \"\"\"User defined numpy uniform prior.\n\n    Custom prior with user-defined valid .sample and .log_prob methods.\n    \"\"\"\n\n    def __init__(self, lower: Tensor, upper: Tensor, return_numpy: bool = False):\n        self.lower = lower\n        self.upper = upper\n        self.dist = BoxUniform(lower, upper)\n        self.return_numpy = return_numpy\n\n    def sample(self, sample_shape=torch.Size([])):\n        samples = self.dist.sample(sample_shape)\n        return samples.numpy() if self.return_numpy else samples\n\n    def log_prob(self, values):\n        if self.return_numpy:\n            values = torch.as_tensor(values)\n        log_probs = self.dist.log_prob(values)\n        return log_probs.numpy() if self.return_numpy else log_probs\n</code></pre> <p>Once you have such a class, you can wrap it into a <code>Distribution</code> using the <code>process_prior</code> function <code>sbi</code> provides:</p> <pre><code>from sbi.utils import process_prior\n\ncustom_prior = CustomUniformPrior(torch.zeros(2), torch.ones(2))\nprior, *_ = process_prior(custom_prior)  # Keeping only the first return.\n# use this wrapped prior in sbi...\n</code></pre> <p>In <code>sbi</code> it is sometimes required to check the support of the prior, e.g., when the prior support is bounded and one wants to reject samples from the posterior density estimator that lie outside the prior support. In torch <code>Distributions</code> this is handled automatically. However, when using a custom prior, it is not. Thus, if your prior has bounded support (like the one above), it makes sense to pass the bounds to the wrapper function such that <code>sbi</code> can pass them to torch <code>Distributions</code>:</p> <pre><code>from sbi.utils import process_prior\n\ncustom_prior = CustomUniformPrior(torch.zeros(2), torch.ones(2))\nprior = process_prior(custom_prior,\n                      custom_prior_wrapper_kwargs=dict(lower_bound=torch.zeros(2),\n                                                       upper_bound=torch.ones(2)))\n# use this wrapped prior in sbi...\n</code></pre> <p>Note that in <code>custom_prior_wrapper_kwargs</code> you can pass additinal arguments for the wrapper, e.g., <code>validate_args</code> or <code>arg_constraints</code> see the <code>Distribution</code> documentation for more details.</p> <p>If you are using <code>sbi</code> &lt; 0.17.2 and use <code>NLE</code> the code above will produce a <code>NotImplementedError</code> (see #581). In this case, you need to update to a newer version of <code>sbi</code> or use <code>NPE</code> instead.</p>"},{"location":"reference/","title":"API Reference:","text":"<ul> <li>Inference SBI algorithms and helper functions.</li> <li>Neural Networks Utilities to build neural network-based density estimators and feature extractors.</li> <li>Posteriors Posterior classes</li> <li>Potentials Potential function classes for posterior sampling.</li> <li>Analysis Utilities for SBI visualizations and analyses.</li> </ul>"},{"location":"reference/analysis/","title":"Analysis","text":""},{"location":"reference/analysis/#sbi.analysis.plot.pairplot","title":"<code>pairplot(samples, points=None, limits=None, subset=None, upper='hist', lower=None, diag='hist', figsize=(10, 10), labels=None, ticks=None, offdiag=None, diag_kwargs=None, upper_kwargs=None, lower_kwargs=None, fig_kwargs=None, fig=None, axes=None, **kwargs)</code>","text":"<p>Plot samples in a 2D grid showing marginals and pairwise marginals.</p> <p>Each of the diagonal plots can be interpreted as a 1D-marginal of the distribution that the samples were drawn from. Each upper-diagonal plot can be interpreted as a 2D-marginal of the distribution.</p> <p>Parameters:</p> Name Type Description Default <code>samples</code> <code>Union[List[ndarray], List[Tensor], ndarray, Tensor]</code> <p>Samples used to build the histogram.</p> required <code>points</code> <code>Optional[Union[List[ndarray], List[Tensor], ndarray, Tensor]]</code> <p>List of additional points to scatter.</p> <code>None</code> <code>limits</code> <code>Optional[Union[List, Tensor]]</code> <p>Array containing the plot xlim for each parameter dimension. If None, just use the min and max of the passed samples</p> <code>None</code> <code>subset</code> <code>Optional[List[int]]</code> <p>List containing the dimensions to plot. E.g. subset=[1,3] will plot plot only the 1<sup>st</sup> and 3<sup>rd</sup> dimension but will discard the 0<sup>th</sup> and 2<sup>nd</sup> (and, if they exist, the 4<sup>th</sup>, 5<sup>th</sup> and so on).</p> <code>None</code> <code>upper</code> <code>Optional[Union[List[Optional[str]], str]]</code> <p>Plotting style for upper diagonal, {hist, scatter, contour, kde, None}.</p> <code>'hist'</code> <code>lower</code> <code>Optional[Union[List[Optional[str]], str]]</code> <p>Plotting style for upper diagonal, {hist, scatter, contour, kde, None}.</p> <code>None</code> <code>diag</code> <code>Optional[Union[List[Optional[str]], str]]</code> <p>Plotting style for diagonal, {hist, scatter, kde}.</p> <code>'hist'</code> <code>figsize</code> <code>Tuple</code> <p>Size of the entire figure.</p> <code>(10, 10)</code> <code>labels</code> <code>Optional[List[str]]</code> <p>List of strings specifying the names of the parameters.</p> <code>None</code> <code>ticks</code> <code>Optional[Union[List, Tensor]]</code> <p>Position of the ticks.</p> <code>None</code> <code>offdiag</code> <code>Optional[Union[List[Optional[str]], str]]</code> <p>deprecated, use upper instead.</p> <code>None</code> <code>diag_kwargs</code> <code>Optional[Union[List[Optional[Dict]], Dict]]</code> <p>Additional arguments to adjust the diagonal plot, see the source code in <code>_get_default_diag_kwarg()</code></p> <code>None</code> <code>upper_kwargs</code> <code>Optional[Union[List[Optional[Dict]], Dict]]</code> <p>Additional arguments to adjust the upper diagonal plot, see the source code in <code>_get_default_offdiag_kwarg()</code></p> <code>None</code> <code>lower_kwargs</code> <code>Optional[Union[List[Optional[Dict]], Dict]]</code> <p>Additional arguments to adjust the lower diagonal plot, see the source code in <code>_get_default_offdiag_kwarg()</code></p> <code>None</code> <code>fig_kwargs</code> <code>Optional[Dict]</code> <p>Additional arguments to adjust the overall figure, see the source code in <code>_get_default_fig_kwargs()</code></p> <code>None</code> <code>fig</code> <code>Optional[FigureBase]</code> <p>matplotlib figure to plot on.</p> <code>None</code> <code>axes</code> <code>Optional[Axes]</code> <p>matplotlib axes corresponding to fig.</p> <code>None</code> <code>**kwargs</code> <code>Optional[Any]</code> <p>Additional arguments to adjust the plot (deprecated).</p> <code>{}</code> <p>Returns: figure and axis of posterior distribution plot</p> Source code in <code>sbi/analysis/plot.py</code> <pre><code>def pairplot(\n    samples: Union[List[np.ndarray], List[torch.Tensor], np.ndarray, torch.Tensor],\n    points: Optional[\n        Union[List[np.ndarray], List[torch.Tensor], np.ndarray, torch.Tensor]\n    ] = None,\n    limits: Optional[Union[List, torch.Tensor]] = None,\n    subset: Optional[List[int]] = None,\n    upper: Optional[Union[List[Optional[str]], str]] = \"hist\",\n    lower: Optional[Union[List[Optional[str]], str]] = None,\n    diag: Optional[Union[List[Optional[str]], str]] = \"hist\",\n    figsize: Tuple = (10, 10),\n    labels: Optional[List[str]] = None,\n    ticks: Optional[Union[List, torch.Tensor]] = None,\n    offdiag: Optional[Union[List[Optional[str]], str]] = None,\n    diag_kwargs: Optional[Union[List[Optional[Dict]], Dict]] = None,\n    upper_kwargs: Optional[Union[List[Optional[Dict]], Dict]] = None,\n    lower_kwargs: Optional[Union[List[Optional[Dict]], Dict]] = None,\n    fig_kwargs: Optional[Dict] = None,\n    fig: Optional[FigureBase] = None,\n    axes: Optional[Axes] = None,\n    **kwargs: Optional[Any],\n) -&gt; Tuple[FigureBase, Axes]:\n    \"\"\"\n    Plot samples in a 2D grid showing marginals and pairwise marginals.\n\n    Each of the diagonal plots can be interpreted as a 1D-marginal of the distribution\n    that the samples were drawn from. Each upper-diagonal plot can be interpreted as a\n    2D-marginal of the distribution.\n\n    Args:\n        samples: Samples used to build the histogram.\n        points: List of additional points to scatter.\n        limits: Array containing the plot xlim for each parameter dimension. If None,\n            just use the min and max of the passed samples\n        subset: List containing the dimensions to plot. E.g. subset=[1,3] will plot\n            plot only the 1st and 3rd dimension but will discard the 0th and 2nd (and,\n            if they exist, the 4th, 5th and so on).\n        upper: Plotting style for upper diagonal, {hist, scatter, contour, kde,\n            None}.\n        lower: Plotting style for upper diagonal, {hist, scatter, contour, kde,\n            None}.\n        diag: Plotting style for diagonal, {hist, scatter, kde}.\n        figsize: Size of the entire figure.\n        labels: List of strings specifying the names of the parameters.\n        ticks: Position of the ticks.\n        offdiag: deprecated, use upper instead.\n        diag_kwargs: Additional arguments to adjust the diagonal plot,\n            see the source code in `_get_default_diag_kwarg()`\n        upper_kwargs: Additional arguments to adjust the upper diagonal plot,\n            see the source code in `_get_default_offdiag_kwarg()`\n        lower_kwargs: Additional arguments to adjust the lower diagonal plot,\n            see the source code in `_get_default_offdiag_kwarg()`\n        fig_kwargs: Additional arguments to adjust the overall figure,\n            see the source code in `_get_default_fig_kwargs()`\n        fig: matplotlib figure to plot on.\n        axes: matplotlib axes corresponding to fig.\n        **kwargs: Additional arguments to adjust the plot (deprecated).\n\n    Returns: figure and axis of posterior distribution plot\n    \"\"\"\n\n    # Backwards compatibility\n    if len(kwargs) &gt; 0:\n        warn(\n            f\"you passed deprecated arguments **kwargs: {[key for key in kwargs]}, use \"\n            \"fig_kwargs instead. We continue calling the deprecated pairplot function\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        fig, axes = pairplot_dep(\n            samples,\n            points,\n            limits,\n            subset,\n            offdiag,\n            diag,\n            figsize,\n            labels,\n            ticks,\n            upper,\n            fig,\n            axes,\n            **kwargs,\n        )\n        return fig, axes\n\n    samples, dim, limits = prepare_for_plot(samples, limits, points)\n\n    # prepate figure kwargs\n    fig_kwargs_filled = _get_default_fig_kwargs()\n    # update the defaults dictionary with user provided values\n    fig_kwargs_filled = _update(fig_kwargs_filled, fig_kwargs)\n\n    # checks.\n    if fig_kwargs_filled[\"legend\"]:\n        assert len(fig_kwargs_filled[\"samples_labels\"]) &gt;= len(\n            samples\n        ), \"Provide at least as many labels as samples.\"\n    if offdiag is not None:\n        warn(\"offdiag is deprecated, use upper or lower instead.\", stacklevel=2)\n        upper = offdiag\n\n    # Prepare diag\n    diag_list = to_list_string(diag, len(samples))\n    diag_kwargs_list = to_list_kwargs(diag_kwargs, len(samples))\n    diag_func = get_diag_funcs(diag_list)\n    diag_kwargs_filled = []\n    for i, (diag_i, diag_kwargs_i) in enumerate(zip(diag_list, diag_kwargs_list)):\n        diag_kwarg_filled_i = _get_default_diag_kwargs(diag_i, i)\n        # update the defaults dictionary with user provided values\n        diag_kwarg_filled_i = _update(diag_kwarg_filled_i, diag_kwargs_i)\n        diag_kwargs_filled.append(diag_kwarg_filled_i)\n\n    # Prepare upper\n    upper_list = to_list_string(upper, len(samples))\n    upper_kwargs_list = to_list_kwargs(upper_kwargs, len(samples))\n    upper_func = get_offdiag_funcs(upper_list)\n    upper_kwargs_filled = []\n    for i, (upper_i, upper_kwargs_i) in enumerate(zip(upper_list, upper_kwargs_list)):\n        upper_kwarg_filled_i = _get_default_offdiag_kwargs(upper_i, i)\n        # update the defaults dictionary with user provided values\n        upper_kwarg_filled_i = _update(upper_kwarg_filled_i, upper_kwargs_i)\n        upper_kwargs_filled.append(upper_kwarg_filled_i)\n\n    # Prepare lower\n    lower_list = to_list_string(lower, len(samples))\n    lower_kwargs_list = to_list_kwargs(lower_kwargs, len(samples))\n    lower_func = get_offdiag_funcs(lower_list)\n    lower_kwargs_filled = []\n    for i, (lower_i, lower_kwargs_i) in enumerate(zip(lower_list, lower_kwargs_list)):\n        lower_kwarg_filled_i = _get_default_offdiag_kwargs(lower_i, i)\n        # update the defaults dictionary with user provided values\n        lower_kwarg_filled_i = _update(lower_kwarg_filled_i, lower_kwargs_i)\n        lower_kwargs_filled.append(lower_kwarg_filled_i)\n\n    return _arrange_grid(\n        diag_func,\n        upper_func,\n        lower_func,\n        diag_kwargs_filled,\n        upper_kwargs_filled,\n        lower_kwargs_filled,\n        samples,\n        points,\n        limits,\n        subset,\n        figsize,\n        labels,\n        ticks,\n        fig,\n        axes,\n        fig_kwargs_filled,\n    )\n</code></pre>"},{"location":"reference/analysis/#sbi.analysis.plot.marginal_plot","title":"<code>marginal_plot(samples, points=None, limits=None, subset=None, diag='hist', figsize=(10, 2), labels=None, ticks=None, diag_kwargs=None, fig_kwargs=None, fig=None, axes=None, **kwargs)</code>","text":"<p>Plot samples in a row showing 1D marginals of selected dimensions.</p> <p>Each of the plots can be interpreted as a 1D-marginal of the distribution that the samples were drawn from.</p> <p>Parameters:</p> Name Type Description Default <code>samples</code> <code>Union[List[ndarray], List[Tensor], ndarray, Tensor]</code> <p>Samples used to build the histogram.</p> required <code>points</code> <code>Optional[Union[List[ndarray], List[Tensor], ndarray, Tensor]]</code> <p>List of additional points to scatter.</p> <code>None</code> <code>limits</code> <code>Optional[Union[List, Tensor]]</code> <p>Array containing the plot xlim for each parameter dimension. If None, just use the min and max of the passed samples</p> <code>None</code> <code>subset</code> <code>Optional[List[int]]</code> <p>List containing the dimensions to plot. E.g. subset=[1,3] will plot plot only the 1<sup>st</sup> and 3<sup>rd</sup> dimension but will discard the 0<sup>th</sup> and 2<sup>nd</sup> (and, if they exist, the 4<sup>th</sup>, 5<sup>th</sup> and so on).</p> <code>None</code> <code>diag</code> <code>Optional[Union[List[Optional[str]], str]]</code> <p>Plotting style for 1D marginals, {hist, kde cond, None}.</p> <code>'hist'</code> <code>figsize</code> <code>Optional[Tuple]</code> <p>Size of the entire figure.</p> <code>(10, 2)</code> <code>labels</code> <code>Optional[List[str]]</code> <p>List of strings specifying the names of the parameters.</p> <code>None</code> <code>ticks</code> <code>Optional[Union[List, Tensor]]</code> <p>Position of the ticks.</p> <code>None</code> <code>diag_kwargs</code> <code>Optional[Union[List[Optional[Dict]], Dict]]</code> <p>Additional arguments to adjust the diagonal plot, see the source code in <code>_get_default_diag_kwarg()</code></p> <code>None</code> <code>fig_kwargs</code> <code>Optional[Dict]</code> <p>Additional arguments to adjust the overall figure, see the source code in <code>_get_default_fig_kwargs()</code></p> <code>None</code> <code>fig</code> <code>Optional[FigureBase]</code> <p>matplotlib figure to plot on.</p> <code>None</code> <code>axes</code> <code>Optional[Axes]</code> <p>matplotlib axes corresponding to fig.</p> <code>None</code> <code>**kwargs</code> <code>Optional[Any]</code> <p>Additional arguments to adjust the plot (deprecated)</p> <code>{}</code> <p>Returns: figure and axis of posterior distribution plot</p> Source code in <code>sbi/analysis/plot.py</code> <pre><code>def marginal_plot(\n    samples: Union[List[np.ndarray], List[torch.Tensor], np.ndarray, torch.Tensor],\n    points: Optional[\n        Union[List[np.ndarray], List[torch.Tensor], np.ndarray, torch.Tensor]\n    ] = None,\n    limits: Optional[Union[List, torch.Tensor]] = None,\n    subset: Optional[List[int]] = None,\n    diag: Optional[Union[List[Optional[str]], str]] = \"hist\",\n    figsize: Optional[Tuple] = (10, 2),\n    labels: Optional[List[str]] = None,\n    ticks: Optional[Union[List, torch.Tensor]] = None,\n    diag_kwargs: Optional[Union[List[Optional[Dict]], Dict]] = None,\n    fig_kwargs: Optional[Dict] = None,\n    fig: Optional[FigureBase] = None,\n    axes: Optional[Axes] = None,\n    **kwargs: Optional[Any],\n) -&gt; Tuple[FigureBase, Axes]:\n    \"\"\"\n    Plot samples in a row showing 1D marginals of selected dimensions.\n\n    Each of the plots can be interpreted as a 1D-marginal of the distribution\n    that the samples were drawn from.\n\n    Args:\n        samples: Samples used to build the histogram.\n        points: List of additional points to scatter.\n        limits: Array containing the plot xlim for each parameter dimension. If None,\n            just use the min and max of the passed samples\n        subset: List containing the dimensions to plot. E.g. subset=[1,3] will plot\n            plot only the 1st and 3rd dimension but will discard the 0th and 2nd (and,\n            if they exist, the 4th, 5th and so on).\n        diag: Plotting style for 1D marginals, {hist, kde cond, None}.\n        figsize: Size of the entire figure.\n        labels: List of strings specifying the names of the parameters.\n        ticks: Position of the ticks.\n        diag_kwargs: Additional arguments to adjust the diagonal plot,\n            see the source code in `_get_default_diag_kwarg()`\n        fig_kwargs: Additional arguments to adjust the overall figure,\n            see the source code in `_get_default_fig_kwargs()`\n        fig: matplotlib figure to plot on.\n        axes: matplotlib axes corresponding to fig.\n        **kwargs: Additional arguments to adjust the plot (deprecated)\n    Returns: figure and axis of posterior distribution plot\n    \"\"\"\n\n    # backwards compatibility\n    if len(kwargs) &gt; 0:\n        warn(\n            \"**kwargs are deprecated, use fig_kwargs instead. \"\n            \"calling the to be deprecated marginal_plot function\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        fig, axes = marginal_plot_dep(\n            samples,\n            points,\n            limits,\n            subset,\n            diag,\n            figsize,\n            labels,\n            ticks,\n            fig,\n            axes,\n            **kwargs,\n        )\n        return fig, axes\n\n    samples, dim, limits = prepare_for_plot(samples, limits)\n\n    # prepare kwargs and functions of the subplots\n    diag_list = to_list_string(diag, len(samples))\n    diag_kwargs_list = to_list_kwargs(diag_kwargs, len(samples))\n    diag_func = get_diag_funcs(diag_list)\n    diag_kwargs_filled = []\n    for i, (diag_i, diag_kwargs_i) in enumerate(zip(diag_list, diag_kwargs_list)):\n        diag_kwarg_filled_i = _get_default_diag_kwargs(diag_i, i)\n        diag_kwarg_filled_i = _update(diag_kwarg_filled_i, diag_kwargs_i)\n        diag_kwargs_filled.append(diag_kwarg_filled_i)\n\n    # prepare fig_kwargs\n    fig_kwargs_filled = _get_default_fig_kwargs()\n    fig_kwargs_filled = _update(fig_kwargs_filled, fig_kwargs)\n\n    # generate plot\n    return _arrange_grid(\n        diag_func,\n        [None],\n        [None],\n        diag_kwargs_filled,\n        [None],\n        [None],\n        samples,\n        points,\n        limits,\n        subset,\n        figsize,\n        labels,\n        ticks,\n        fig,\n        axes,\n        fig_kwargs_filled,\n    )\n</code></pre>"},{"location":"reference/analysis/#sbi.analysis.plot.conditional_pairplot","title":"<code>conditional_pairplot(density, condition, limits, points=None, subset=None, resolution=50, figsize=(10, 10), labels=None, ticks=None, fig=None, axes=None, **kwargs)</code>","text":"<p>Plot conditional distribution given all other parameters.</p> <p>The conditionals can be interpreted as slices through the <code>density</code> at a location given by <code>condition</code>.</p> <p>For example: Say we have a 3D density with parameters \\(\\theta_0\\), \\(\\theta_1\\), \\(\\theta_2\\) and a condition \\(c\\) passed by the user in the <code>condition</code> argument. For the plot of \\(\\theta_0\\) on the diagonal, this will plot the conditional \\(p(\\theta_0 | \\theta_1=c[1], \\theta_2=c[2])\\). For the upper diagonal of \\(\\theta_1\\) and \\(\\theta_2\\), it will plot \\(p(\\theta_1, \\theta_2 | \\theta_0=c[0])\\). All other diagonals and upper-diagonals are built in the corresponding way.</p> <p>Parameters:</p> Name Type Description Default <code>density</code> <code>Any</code> <p>Probability density with a <code>log_prob()</code> method.</p> required <code>condition</code> <code>Tensor</code> <p>Condition that all but the one/two regarded parameters are fixed to. The condition should be of shape (1, dim_theta), i.e. it could e.g. be a sample from the posterior distribution.</p> required <code>limits</code> <code>Union[List, Tensor]</code> <p>Limits in between which each parameter will be evaluated.</p> required <code>points</code> <code>Optional[Union[List[ndarray], List[Tensor], ndarray, Tensor]]</code> <p>Additional points to scatter.</p> <code>None</code> <code>subset</code> <code>Optional[List[int]]</code> <p>List containing the dimensions to plot. E.g. subset=[1,3] will plot plot only the 1<sup>st</sup> and 3<sup>rd</sup> dimension but will discard the 0<sup>th</sup> and 2<sup>nd</sup> (and, if they exist, the 4<sup>th</sup>, 5<sup>th</sup> and so on)</p> <code>None</code> <code>resolution</code> <code>int</code> <p>Resolution of the grid at which we evaluate the <code>pdf</code>.</p> <code>50</code> <code>figsize</code> <code>Tuple</code> <p>Size of the entire figure.</p> <code>(10, 10)</code> <code>labels</code> <code>Optional[List[str]]</code> <p>List of strings specifying the names of the parameters.</p> <code>None</code> <code>ticks</code> <code>Optional[Union[List, Tensor]]</code> <p>Position of the ticks.</p> <code>None</code> <code>points_colors</code> <p>Colors of the <code>points</code>.</p> required <code>fig</code> <p>matplotlib figure to plot on.</p> <code>None</code> <code>axes</code> <p>matplotlib axes corresponding to fig.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to adjust the plot, e.g., <code>samples_colors</code>, <code>points_colors</code> and many more, see the source code in <code>_get_default_opts()</code> in <code>sbi.analysis.plot</code> for details.</p> <code>{}</code> <p>Returns: figure and axis of posterior distribution plot</p> Source code in <code>sbi/analysis/plot.py</code> <pre><code>def conditional_pairplot(\n    density: Any,\n    condition: torch.Tensor,\n    limits: Union[List, torch.Tensor],\n    points: Optional[\n        Union[List[np.ndarray], List[torch.Tensor], np.ndarray, torch.Tensor]\n    ] = None,\n    subset: Optional[List[int]] = None,\n    resolution: int = 50,\n    figsize: Tuple = (10, 10),\n    labels: Optional[List[str]] = None,\n    ticks: Optional[Union[List, torch.Tensor]] = None,\n    fig=None,\n    axes=None,\n    **kwargs,\n):\n    r\"\"\"\n    Plot conditional distribution given all other parameters.\n\n    The conditionals can be interpreted as slices through the `density` at a location\n    given by `condition`.\n\n    For example:\n    Say we have a 3D density with parameters $\\theta_0$, $\\theta_1$, $\\theta_2$ and\n    a condition $c$ passed by the user in the `condition` argument.\n    For the plot of $\\theta_0$ on the diagonal, this will plot the conditional\n    $p(\\theta_0 | \\theta_1=c[1], \\theta_2=c[2])$. For the upper\n    diagonal of $\\theta_1$ and $\\theta_2$, it will plot\n    $p(\\theta_1, \\theta_2 | \\theta_0=c[0])$. All other diagonals and upper-diagonals\n    are built in the corresponding way.\n\n    Args:\n        density: Probability density with a `log_prob()` method.\n        condition: Condition that all but the one/two regarded parameters are fixed to.\n            The condition should be of shape (1, dim_theta), i.e. it could e.g. be\n            a sample from the posterior distribution.\n        limits: Limits in between which each parameter will be evaluated.\n        points: Additional points to scatter.\n        subset: List containing the dimensions to plot. E.g. subset=[1,3] will plot\n            plot only the 1st and 3rd dimension but will discard the 0th and 2nd (and,\n            if they exist, the 4th, 5th and so on)\n        resolution: Resolution of the grid at which we evaluate the `pdf`.\n        figsize: Size of the entire figure.\n        labels: List of strings specifying the names of the parameters.\n        ticks: Position of the ticks.\n        points_colors: Colors of the `points`.\n\n        fig: matplotlib figure to plot on.\n        axes: matplotlib axes corresponding to fig.\n        **kwargs: Additional arguments to adjust the plot, e.g., `samples_colors`,\n            `points_colors` and many more, see the source code in `_get_default_opts()`\n            in `sbi.analysis.plot` for details.\n\n    Returns: figure and axis of posterior distribution plot\n    \"\"\"\n    device = density._device if hasattr(density, \"_device\") else \"cpu\"\n\n    # Setting these is required because _pairplot_scaffold will check if opts['diag'] is\n    # `None`. This would break if opts has no key 'diag'. Same for 'upper'.\n    diag = \"cond\"\n    offdiag = \"cond\"\n\n    opts = _get_default_opts()\n    # update the defaults dictionary by the current values of the variables (passed by\n    # the user)\n    opts = _update(opts, locals())\n    opts = _update(opts, kwargs)\n    opts[\"lower\"] = None\n\n    dim, limits, eps_margins = prepare_for_conditional_plot(condition, opts)\n    diag_func = get_conditional_diag_func(opts, limits, eps_margins, resolution)\n\n    def offdiag_func(row, col, **kwargs):\n        p_image = (\n            eval_conditional_density(\n                opts[\"density\"],\n                opts[\"condition\"].to(device),\n                limits.to(device),\n                row,\n                col,\n                resolution=resolution,\n                eps_margins1=eps_margins[row],\n                eps_margins2=eps_margins[col],\n            )\n            .to(\"cpu\")\n            .numpy()\n        )\n        plt.imshow(\n            p_image.T,\n            origin=\"lower\",\n            extent=(\n                limits[col, 0].item(),\n                limits[col, 1].item(),\n                limits[row, 0].item(),\n                limits[row, 1].item(),\n            ),\n            aspect=\"auto\",\n        )\n\n    return _arrange_plots(\n        diag_func, offdiag_func, dim, limits, points, opts, fig=fig, axes=axes\n    )\n</code></pre>"},{"location":"reference/analysis/#sbi.analysis.conditional_density.conditional_corrcoeff","title":"<code>conditional_corrcoeff(density, limits, condition, subset=None, resolution=50)</code>","text":"<p>Returns the conditional correlation matrix of a distribution.</p> <p>To compute the conditional distribution, we condition all but two parameters to values from <code>condition</code>, and then compute the Pearson correlation coefficient \\(\\rho\\) between the remaining two parameters under the distribution <code>density</code>. We do so for any pair of parameters specified in <code>subset</code>, thus creating a matrix containing conditional correlations between any pair of parameters.</p> <p>If <code>condition</code> is a batch of conditions, this function computes the conditional correlation matrix for each one of them and returns the mean.</p> <p>Parameters:</p> Name Type Description Default <code>density</code> <code>Any</code> <p>Probability density function with <code>.log_prob()</code> function.</p> required <code>limits</code> <code>Tensor</code> <p>Limits within which to evaluate the <code>density</code>.</p> required <code>condition</code> <code>Tensor</code> <p>Values to condition the <code>density</code> on. If a batch of conditions is passed, we compute the conditional correlation matrix for each of them and return the average conditional correlation matrix.</p> required <code>subset</code> <code>Optional[List[int]]</code> <p>Evaluate the conditional distribution only on a subset of dimensions. If <code>None</code> this function uses all dimensions.</p> <code>None</code> <code>resolution</code> <code>int</code> <p>Number of grid points on which the conditional distribution is evaluated. A higher value increases the accuracy of the estimated correlation but also increases the computational cost.</p> <code>50</code> <p>Returns: Average conditional correlation matrix of shape either <code>(num_dim, num_dim)</code> or <code>(len(subset), len(subset))</code> if <code>subset</code> was specified.</p> Source code in <code>sbi/analysis/conditional_density.py</code> <pre><code>def conditional_corrcoeff(\n    density: Any,\n    limits: Tensor,\n    condition: Tensor,\n    subset: Optional[List[int]] = None,\n    resolution: int = 50,\n) -&gt; Tensor:\n    r\"\"\"Returns the conditional correlation matrix of a distribution.\n\n    To compute the conditional distribution, we condition all but two parameters to\n    values from `condition`, and then compute the Pearson correlation\n    coefficient $\\rho$ between the remaining two parameters under the distribution\n    `density`. We do so for any pair of parameters specified in `subset`, thus\n    creating a matrix containing conditional correlations between any pair of\n    parameters.\n\n    If `condition` is a batch of conditions, this function computes the conditional\n    correlation matrix for each one of them and returns the mean.\n\n    Args:\n        density: Probability density function with `.log_prob()` function.\n        limits: Limits within which to evaluate the `density`.\n        condition: Values to condition the `density` on. If a batch of conditions is\n            passed, we compute the conditional correlation matrix for each of them and\n            return the average conditional correlation matrix.\n        subset: Evaluate the conditional distribution only on a subset of dimensions.\n            If `None` this function uses all dimensions.\n        resolution: Number of grid points on which the conditional distribution is\n            evaluated. A higher value increases the accuracy of the estimated\n            correlation but also increases the computational cost.\n\n    Returns: Average conditional correlation matrix of shape either `(num_dim, num_dim)`\n    or `(len(subset), len(subset))` if `subset` was specified.\n    \"\"\"\n\n    device = density._device if hasattr(density, \"_device\") else \"cpu\"\n\n    subset_ = subset if subset is not None else range(condition.shape[1])\n\n    correlation_matrices = []\n    for cond in condition:\n        correlation_matrices.append(\n            torch.stack([\n                compute_corrcoeff(\n                    eval_conditional_density(\n                        density,\n                        cond.to(device),\n                        limits.to(device),\n                        dim1=dim1,\n                        dim2=dim2,\n                        resolution=resolution,\n                    ),\n                    limits[[dim1, dim2]].to(device),\n                )\n                for dim1 in subset_\n                for dim2 in subset_\n                if dim1 &lt; dim2\n            ])\n        )\n\n    average_correlations = torch.mean(torch.stack(correlation_matrices), dim=0)\n\n    # `average_correlations` is still a vector containing the upper triangular entries.\n    # Below, assemble them into a matrix:\n    av_correlation_matrix = torch.zeros((len(subset_), len(subset_)), device=device)\n    triu_indices = torch.triu_indices(\n        row=len(subset_), col=len(subset_), offset=1, device=device\n    )\n    av_correlation_matrix[triu_indices[0], triu_indices[1]] = average_correlations\n\n    # Make the matrix symmetric by copying upper diagonal to lower diagonal.\n    av_correlation_matrix = torch.triu(av_correlation_matrix) + torch.tril(\n        av_correlation_matrix.T\n    )\n\n    av_correlation_matrix.fill_diagonal_(1.0)\n    return av_correlation_matrix\n</code></pre>"},{"location":"reference/inference/","title":"Inference","text":""},{"location":"reference/inference/#training-algorithms","title":"Training algorithms","text":""},{"location":"reference/inference/#sbi.inference.trainers.npe.npe_a.NPE_A","title":"<code>NPE_A</code>","text":"<p>               Bases: <code>PosteriorEstimator</code></p> Source code in <code>sbi/inference/trainers/npe/npe_a.py</code> <pre><code>class NPE_A(PosteriorEstimator):\n    def __init__(\n        self,\n        prior: Optional[Distribution] = None,\n        density_estimator: Union[str, Callable] = \"mdn_snpe_a\",\n        num_components: int = 10,\n        device: str = \"cpu\",\n        logging_level: Union[int, str] = \"WARNING\",\n        summary_writer: Optional[TensorboardSummaryWriter] = None,\n        show_progress_bars: bool = True,\n    ):\n        r\"\"\"NPE-A [1].\n\n        [1] _Fast epsilon-free Inference of Simulation Models with Bayesian Conditional\n            Density Estimation_, Papamakarios et al., NeurIPS 2016,\n            https://arxiv.org/abs/1605.06376.\n\n        Like all NPE methods, this method trains a deep neural density estimator to\n        directly approximate the posterior. Also like all other NPE methods, in the\n        first round, this density estimator is trained with a maximum-likelihood loss.\n\n        This class implements NPE-A. NPE-A trains across multiple rounds with a\n        maximum-likelihood-loss. This will make training converge to the proposal\n        posterior instead of the true posterior. To correct for this, SNPE-A applies a\n        post-hoc correction after training. This correction has to be performed\n        analytically. Thus, NPE-A is limited to Gaussian distributions for all but the\n        last round. In the last round, NPE-A can use a Mixture of Gaussians.\n\n        Args:\n            prior: A probability distribution that expresses prior knowledge about the\n                parameters, e.g. which ranges are meaningful for them. Any\n                object with `.log_prob()`and `.sample()` (for example, a PyTorch\n                distribution) can be used.\n            density_estimator: If it is a string (only \"mdn_snpe_a\" is valid), use a\n                pre-configured mixture of densities network. Alternatively, a function\n                that builds a custom neural network can be provided. The function will\n                be called with the first batch of simulations (theta, x), which can\n                thus be used for shape inference and potentially for z-scoring. It\n                needs to return a PyTorch `nn.Module` implementing the density\n                estimator. The density estimator needs to provide the methods\n                `.log_prob` and `.sample()`. Note that until the last round only a\n                single (multivariate) Gaussian component is used for training (see\n                Algorithm 1 in [1]). In the last round, this component is replicated\n                `num_components` times, its parameters are perturbed with a very small\n                noise, and then the last training round is done with the expanded\n                Gaussian mixture as estimator for the proposal posterior.\n            num_components: Number of components of the mixture of Gaussians in the\n                last round. This overrides the `num_components` value passed to\n                `posterior_nn()`.\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n            logging_level: Minimum severity of messages to log. One of the strings\n                INFO, WARNING, DEBUG, ERROR and CRITICAL.\n            summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n                file location (default is `&lt;current working directory&gt;/logs`.)\n            show_progress_bars: Whether to show a progressbar during training.\n        \"\"\"\n\n        # Catch invalid inputs.\n        if not ((density_estimator == \"mdn_snpe_a\") or callable(density_estimator)):\n            raise TypeError(\n                \"The `density_estimator` passed to SNPE_A needs to be a \"\n                \"callable or the string 'mdn_snpe_a'!\"\n            )\n\n        # `num_components` will be used to replicate the Gaussian in the last round.\n        self._num_components = num_components\n        self._ran_final_round = False\n\n        # WARNING: sneaky trick ahead. We proxy the parent's `train` here,\n        # requiring the signature to have `num_atoms`, save it for use below, and\n        # continue. It's sneaky because we are using the object (self) as a namespace\n        # to pass arguments between functions, and that's implicit state management.\n        kwargs = del_entries(\n            locals(),\n            entries=(\"self\", \"__class__\", \"num_components\"),\n        )\n        super().__init__(**kwargs)\n\n    def train(\n        self,\n        final_round: bool = False,\n        training_batch_size: int = 200,\n        learning_rate: float = 5e-4,\n        validation_fraction: float = 0.1,\n        stop_after_epochs: int = 20,\n        max_num_epochs: int = 2**31 - 1,\n        clip_max_norm: Optional[float] = 5.0,\n        calibration_kernel: Optional[Callable] = None,\n        resume_training: bool = False,\n        retrain_from_scratch: bool = False,\n        show_train_summary: bool = False,\n        dataloader_kwargs: Optional[Dict] = None,\n        component_perturbation: float = 5e-3,\n    ) -&gt; ConditionalDensityEstimator:\n        r\"\"\"Return density estimator that approximates the proposal posterior.\n\n        [1] _Fast epsilon-free Inference of Simulation Models with Bayesian Conditional\n            Density Estimation_, Papamakarios et al., NeurIPS 2016,\n            https://arxiv.org/abs/1605.06376.\n\n        Training is performed with maximum likelihood on samples from the latest round,\n        which leads the algorithm to converge to the proposal posterior.\n\n        Args:\n            final_round: Whether we are in the last round of training or not. For all\n                but the last round, Algorithm 1 from [1] is executed. In last the\n                round, Algorithm 2 from [1] is executed once.\n            training_batch_size: Training batch size.\n            learning_rate: Learning rate for Adam optimizer.\n            validation_fraction: The fraction of data to use for validation.\n            stop_after_epochs: The number of epochs to wait for improvement on the\n                validation set before terminating training.\n            max_num_epochs: Maximum number of epochs to run. If reached, we stop\n                training even when the validation loss is still decreasing. Otherwise,\n                we train until validation loss increases (see also `stop_after_epochs`).\n            clip_max_norm: Value at which to clip the total gradient norm in order to\n                prevent exploding gradients. Use None for no clipping.\n            calibration_kernel: A function to calibrate the loss with respect to the\n                simulations `x`. See Lueckmann, Gon\u00e7alves et al., NeurIPS 2017.\n            resume_training: Can be used in case training time is limited, e.g. on a\n                cluster. If `True`, the split between train and validation set, the\n                optimizer, the number of epochs, and the best validation log-prob will\n                be restored from the last time `.train()` was called.\n            force_first_round_loss: If `True`, train with maximum likelihood,\n                i.e., potentially ignoring the correction for using a proposal\n                distribution different from the prior.\n            retrain_from_scratch: Whether to retrain the conditional density\n                estimator for the posterior from scratch each round. Not supported for\n                SNPE-A.\n            show_train_summary: Whether to print the number of epochs and validation\n                loss and leakage after the training.\n            dataloader_kwargs: Additional or updated kwargs to be passed to the training\n                and validation dataloaders (like, e.g., a collate_fn)\n            component_perturbation: The standard deviation applied to all weights and\n                biases when, in the last round, the Mixture of Gaussians is build from\n                a single Gaussian. This value can be problem-specific and also depends\n                on the number of mixture components.\n\n        Returns:\n            Density estimator that approximates the distribution $p(\\theta|x)$.\n        \"\"\"\n\n        assert not retrain_from_scratch, \"\"\"Retraining from scratch is not supported in\n            SNPE-A yet. The reason for this is that, if we reininitialized the density\n            estimator, the z-scoring would change, which would break the posthoc\n            correction. This is a pure implementation issue.\"\"\"\n\n        kwargs = del_entries(\n            locals(),\n            entries=(\n                \"self\",\n                \"__class__\",\n                \"final_round\",\n                \"component_perturbation\",\n            ),\n        )\n\n        # SNPE-A always discards the prior samples.\n        kwargs[\"discard_prior_samples\"] = True\n        kwargs[\"force_first_round_loss\"] = True\n\n        self._round = max(self._data_round_index)\n\n        if final_round:\n            # If there is (will be) only one round, train with Algorithm 2 from [1].\n            if self._round == 0:\n                self._build_neural_net = partial(\n                    self._build_neural_net, num_components=self._num_components\n                )\n            # Run Algorithm 2 from [1].\n            elif not self._ran_final_round:\n                # Now switch to the specified number of components. This method will\n                # only be used if `retrain_from_scratch=True`. Otherwise,\n                # the MDN will be built from replicating the single-component net for\n                # `num_component` times (via `_expand_mog()`).\n                self._build_neural_net = partial(\n                    self._build_neural_net, num_components=self._num_components\n                )\n\n                # Extend the MDN to the originally desired number of components.\n                self._expand_mog(eps=component_perturbation)\n            else:\n                warnings.warn(\n                    \"You have already run SNPE-A with `final_round=True`. Running it\"\n                    \"again with this setting will not allow computing the posthoc\"\n                    \"correction applied in SNPE-A. Thus, you will get an error when \"\n                    \"calling `.build_posterior()` after training.\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n        else:\n            # Run Algorithm 1 from [1].\n            # Wrap the function that builds the MDN such that we can make\n            # sure that there is only one component when running.\n            self._build_neural_net = partial(self._build_neural_net, num_components=1)\n\n        if final_round:\n            self._ran_final_round = True\n\n        return super().train(**kwargs)\n\n    def correct_for_proposal(\n        self,\n        density_estimator: Optional[TorchModule] = None,\n    ) -&gt; \"NPE_A_MDN\":\n        r\"\"\"Build mixture of Gaussians that approximates the posterior.\n\n        Returns a `NPE_A_MDN` object, which applies the posthoc-correction required in\n        SNPE-A.\n\n        Args:\n            density_estimator: The density estimator that the posterior is based on.\n                If `None`, use the latest neural density estimator that was trained.\n\n        Returns:\n            Posterior $p(\\theta|x)$  with `.sample()` and `.log_prob()` methods.\n        \"\"\"\n        if density_estimator is None:\n            density_estimator = deepcopy(\n                self._neural_net\n            )  # PosteriorEstimator.train() also returns a deepcopy, mimic this here\n            # If internal net is used device is defined.\n            device = self._device\n        else:\n            # Otherwise, infer it from the device of the net parameters.\n            device = str(next(density_estimator.parameters()).device)\n\n        # Set proposal of the density estimator.\n        # This also evokes the z-scoring correction if necessary.\n        if (\n            self._proposal_roundwise[-1] is self._prior\n            or self._proposal_roundwise[-1] is None\n        ):\n            proposal = self._prior\n            assert isinstance(\n                proposal, (MultivariateNormal, BoxUniform)\n            ), \"\"\"Prior must be `torch.distributions.MultivariateNormal` or `sbi.utils.\n                BoxUniform`\"\"\"\n        else:\n            assert isinstance(\n                self._proposal_roundwise[-1], DirectPosterior\n            ), \"\"\"The proposal you passed to `append_simulations` is neither the prior\n                nor a `DirectPosterior`. SNPE-A currently only supports these scenarios.\n                \"\"\"\n            proposal = self._proposal_roundwise[-1]\n\n        # Create the NPE_A_MDN\n        wrapped_density_estimator = NPE_A_MDN(\n            flow=density_estimator,  # type: ignore\n            proposal=proposal,\n            prior=self._prior,\n            device=device,\n        )\n        return wrapped_density_estimator\n\n    def build_posterior(\n        self,\n        density_estimator: Optional[TorchModule] = None,\n        prior: Optional[Distribution] = None,\n        **kwargs,\n    ) -&gt; \"DirectPosterior\":\n        r\"\"\"Build posterior from the neural density estimator.\n\n        This method first corrects the estimated density with `correct_for_proposal`\n        and then returns a `DirectPosterior`.\n\n        Args:\n            density_estimator: The density estimator that the posterior is based on.\n                If `None`, use the latest neural density estimator that was trained.\n            prior: Prior distribution.\n\n        Returns:\n            Posterior $p(\\theta|x)$  with `.sample()` and `.log_prob()` methods.\n        \"\"\"\n        if prior is None:\n            assert (\n                self._prior is not None\n            ), \"\"\"You did not pass a prior. You have to pass the prior either at\n                initialization `inference = SNPE_A(prior)` or to `.build_posterior\n                (prior=prior)`.\"\"\"\n            prior = self._prior\n\n        wrapped_density_estimator = self.correct_for_proposal(\n            density_estimator=density_estimator\n        )\n        self._posterior = super().build_posterior(\n            density_estimator=wrapped_density_estimator,\n            prior=prior,\n            **kwargs,\n        )\n        return deepcopy(self._posterior)  # type: ignore\n\n    def _log_prob_proposal_posterior(\n        self,\n        theta: Tensor,\n        x: Tensor,\n        masks: Tensor,\n        proposal: Optional[Any],\n    ) -&gt; Tensor:\n        \"\"\"Return the log-probability of the proposal posterior.\n\n        For SNPE-A this is the same as `self._neural_net.log_prob(theta, x)` in\n        `_loss()` to be found in `snpe_base.py`.\n\n        Args:\n            theta: Batch of parameters \u03b8.\n            x: Batch of data.\n            masks: Mask that is True for prior samples in the batch in order to train\n                them with prior loss.\n            proposal: Proposal distribution.\n\n        Returns: Log-probability of the proposal posterior.\n        \"\"\"\n        return self._neural_net.log_prob(theta, x)\n\n    def _expand_mog(self, eps: float = 1e-5):\n        \"\"\"\n        Replicate a singe Gaussian trained with Algorithm 1 before continuing\n        with Algorithm 2. The weights and biases of the associated MDN layers\n        are repeated `num_components` times, slightly perturbed to break the\n        symmetry such that the gradients in the subsequent training are not\n        all identical.\n\n        Args:\n            eps: Standard deviation for the random perturbation.\n        \"\"\"\n        assert isinstance(self._neural_net.net._distribution, MultivariateGaussianMDN)\n\n        # Increase the number of components\n        self._neural_net.net._distribution._num_components = self._num_components\n\n        # Expand the 1-dim Gaussian.\n        for name, param in self._neural_net.named_parameters():\n            if any(\n                key in name for key in [\"logits\", \"means\", \"unconstrained\", \"upper\"]\n            ):\n                if \"bias\" in name:\n                    param.data = param.data.repeat(self._num_components)\n                    param.data.add_(torch.randn_like(param.data) * eps)\n                    param.grad = None  # let autograd construct a new gradient\n                elif \"weight\" in name:\n                    param.data = param.data.repeat(self._num_components, 1)\n                    param.data.add_(torch.randn_like(param.data) * eps)\n                    param.grad = None  # let autograd construct a new gradient\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npe.npe_a.NPE_A.__init__","title":"<code>__init__(prior=None, density_estimator='mdn_snpe_a', num_components=10, device='cpu', logging_level='WARNING', summary_writer=None, show_progress_bars=True)</code>","text":"<p>NPE-A [1].</p> <p>[1] Fast epsilon-free Inference of Simulation Models with Bayesian Conditional     Density Estimation, Papamakarios et al., NeurIPS 2016,     https://arxiv.org/abs/1605.06376.</p> <p>Like all NPE methods, this method trains a deep neural density estimator to directly approximate the posterior. Also like all other NPE methods, in the first round, this density estimator is trained with a maximum-likelihood loss.</p> <p>This class implements NPE-A. NPE-A trains across multiple rounds with a maximum-likelihood-loss. This will make training converge to the proposal posterior instead of the true posterior. To correct for this, SNPE-A applies a post-hoc correction after training. This correction has to be performed analytically. Thus, NPE-A is limited to Gaussian distributions for all but the last round. In the last round, NPE-A can use a Mixture of Gaussians.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Optional[Distribution]</code> <p>A probability distribution that expresses prior knowledge about the parameters, e.g. which ranges are meaningful for them. Any object with <code>.log_prob()</code>and <code>.sample()</code> (for example, a PyTorch distribution) can be used.</p> <code>None</code> <code>density_estimator</code> <code>Union[str, Callable]</code> <p>If it is a string (only \u201cmdn_snpe_a\u201d is valid), use a pre-configured mixture of densities network. Alternatively, a function that builds a custom neural network can be provided. The function will be called with the first batch of simulations (theta, x), which can thus be used for shape inference and potentially for z-scoring. It needs to return a PyTorch <code>nn.Module</code> implementing the density estimator. The density estimator needs to provide the methods <code>.log_prob</code> and <code>.sample()</code>. Note that until the last round only a single (multivariate) Gaussian component is used for training (see Algorithm 1 in [1]). In the last round, this component is replicated <code>num_components</code> times, its parameters are perturbed with a very small noise, and then the last training round is done with the expanded Gaussian mixture as estimator for the proposal posterior.</p> <code>'mdn_snpe_a'</code> <code>num_components</code> <code>int</code> <p>Number of components of the mixture of Gaussians in the last round. This overrides the <code>num_components</code> value passed to <code>posterior_nn()</code>.</p> <code>10</code> <code>device</code> <code>str</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:{0, 1, \u2026}\u201d.</p> <code>'cpu'</code> <code>logging_level</code> <code>Union[int, str]</code> <p>Minimum severity of messages to log. One of the strings INFO, WARNING, DEBUG, ERROR and CRITICAL.</p> <code>'WARNING'</code> <code>summary_writer</code> <code>Optional[TensorboardSummaryWriter]</code> <p>A tensorboard <code>SummaryWriter</code> to control, among others, log file location (default is <code>&lt;current working directory&gt;/logs</code>.)</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during training.</p> <code>True</code> Source code in <code>sbi/inference/trainers/npe/npe_a.py</code> <pre><code>def __init__(\n    self,\n    prior: Optional[Distribution] = None,\n    density_estimator: Union[str, Callable] = \"mdn_snpe_a\",\n    num_components: int = 10,\n    device: str = \"cpu\",\n    logging_level: Union[int, str] = \"WARNING\",\n    summary_writer: Optional[TensorboardSummaryWriter] = None,\n    show_progress_bars: bool = True,\n):\n    r\"\"\"NPE-A [1].\n\n    [1] _Fast epsilon-free Inference of Simulation Models with Bayesian Conditional\n        Density Estimation_, Papamakarios et al., NeurIPS 2016,\n        https://arxiv.org/abs/1605.06376.\n\n    Like all NPE methods, this method trains a deep neural density estimator to\n    directly approximate the posterior. Also like all other NPE methods, in the\n    first round, this density estimator is trained with a maximum-likelihood loss.\n\n    This class implements NPE-A. NPE-A trains across multiple rounds with a\n    maximum-likelihood-loss. This will make training converge to the proposal\n    posterior instead of the true posterior. To correct for this, SNPE-A applies a\n    post-hoc correction after training. This correction has to be performed\n    analytically. Thus, NPE-A is limited to Gaussian distributions for all but the\n    last round. In the last round, NPE-A can use a Mixture of Gaussians.\n\n    Args:\n        prior: A probability distribution that expresses prior knowledge about the\n            parameters, e.g. which ranges are meaningful for them. Any\n            object with `.log_prob()`and `.sample()` (for example, a PyTorch\n            distribution) can be used.\n        density_estimator: If it is a string (only \"mdn_snpe_a\" is valid), use a\n            pre-configured mixture of densities network. Alternatively, a function\n            that builds a custom neural network can be provided. The function will\n            be called with the first batch of simulations (theta, x), which can\n            thus be used for shape inference and potentially for z-scoring. It\n            needs to return a PyTorch `nn.Module` implementing the density\n            estimator. The density estimator needs to provide the methods\n            `.log_prob` and `.sample()`. Note that until the last round only a\n            single (multivariate) Gaussian component is used for training (see\n            Algorithm 1 in [1]). In the last round, this component is replicated\n            `num_components` times, its parameters are perturbed with a very small\n            noise, and then the last training round is done with the expanded\n            Gaussian mixture as estimator for the proposal posterior.\n        num_components: Number of components of the mixture of Gaussians in the\n            last round. This overrides the `num_components` value passed to\n            `posterior_nn()`.\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n        logging_level: Minimum severity of messages to log. One of the strings\n            INFO, WARNING, DEBUG, ERROR and CRITICAL.\n        summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n            file location (default is `&lt;current working directory&gt;/logs`.)\n        show_progress_bars: Whether to show a progressbar during training.\n    \"\"\"\n\n    # Catch invalid inputs.\n    if not ((density_estimator == \"mdn_snpe_a\") or callable(density_estimator)):\n        raise TypeError(\n            \"The `density_estimator` passed to SNPE_A needs to be a \"\n            \"callable or the string 'mdn_snpe_a'!\"\n        )\n\n    # `num_components` will be used to replicate the Gaussian in the last round.\n    self._num_components = num_components\n    self._ran_final_round = False\n\n    # WARNING: sneaky trick ahead. We proxy the parent's `train` here,\n    # requiring the signature to have `num_atoms`, save it for use below, and\n    # continue. It's sneaky because we are using the object (self) as a namespace\n    # to pass arguments between functions, and that's implicit state management.\n    kwargs = del_entries(\n        locals(),\n        entries=(\"self\", \"__class__\", \"num_components\"),\n    )\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npe.npe_a.NPE_A.build_posterior","title":"<code>build_posterior(density_estimator=None, prior=None, **kwargs)</code>","text":"<p>Build posterior from the neural density estimator.</p> <p>This method first corrects the estimated density with <code>correct_for_proposal</code> and then returns a <code>DirectPosterior</code>.</p> <p>Parameters:</p> Name Type Description Default <code>density_estimator</code> <code>Optional[TorchModule]</code> <p>The density estimator that the posterior is based on. If <code>None</code>, use the latest neural density estimator that was trained.</p> <code>None</code> <code>prior</code> <code>Optional[Distribution]</code> <p>Prior distribution.</p> <code>None</code> <p>Returns:</p> Type Description <code>DirectPosterior</code> <p>Posterior \\(p(\\theta|x)\\)  with <code>.sample()</code> and <code>.log_prob()</code> methods.</p> Source code in <code>sbi/inference/trainers/npe/npe_a.py</code> <pre><code>def build_posterior(\n    self,\n    density_estimator: Optional[TorchModule] = None,\n    prior: Optional[Distribution] = None,\n    **kwargs,\n) -&gt; \"DirectPosterior\":\n    r\"\"\"Build posterior from the neural density estimator.\n\n    This method first corrects the estimated density with `correct_for_proposal`\n    and then returns a `DirectPosterior`.\n\n    Args:\n        density_estimator: The density estimator that the posterior is based on.\n            If `None`, use the latest neural density estimator that was trained.\n        prior: Prior distribution.\n\n    Returns:\n        Posterior $p(\\theta|x)$  with `.sample()` and `.log_prob()` methods.\n    \"\"\"\n    if prior is None:\n        assert (\n            self._prior is not None\n        ), \"\"\"You did not pass a prior. You have to pass the prior either at\n            initialization `inference = SNPE_A(prior)` or to `.build_posterior\n            (prior=prior)`.\"\"\"\n        prior = self._prior\n\n    wrapped_density_estimator = self.correct_for_proposal(\n        density_estimator=density_estimator\n    )\n    self._posterior = super().build_posterior(\n        density_estimator=wrapped_density_estimator,\n        prior=prior,\n        **kwargs,\n    )\n    return deepcopy(self._posterior)  # type: ignore\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npe.npe_a.NPE_A.correct_for_proposal","title":"<code>correct_for_proposal(density_estimator=None)</code>","text":"<p>Build mixture of Gaussians that approximates the posterior.</p> <p>Returns a <code>NPE_A_MDN</code> object, which applies the posthoc-correction required in SNPE-A.</p> <p>Parameters:</p> Name Type Description Default <code>density_estimator</code> <code>Optional[TorchModule]</code> <p>The density estimator that the posterior is based on. If <code>None</code>, use the latest neural density estimator that was trained.</p> <code>None</code> <p>Returns:</p> Type Description <code>NPE_A_MDN</code> <p>Posterior \\(p(\\theta|x)\\)  with <code>.sample()</code> and <code>.log_prob()</code> methods.</p> Source code in <code>sbi/inference/trainers/npe/npe_a.py</code> <pre><code>def correct_for_proposal(\n    self,\n    density_estimator: Optional[TorchModule] = None,\n) -&gt; \"NPE_A_MDN\":\n    r\"\"\"Build mixture of Gaussians that approximates the posterior.\n\n    Returns a `NPE_A_MDN` object, which applies the posthoc-correction required in\n    SNPE-A.\n\n    Args:\n        density_estimator: The density estimator that the posterior is based on.\n            If `None`, use the latest neural density estimator that was trained.\n\n    Returns:\n        Posterior $p(\\theta|x)$  with `.sample()` and `.log_prob()` methods.\n    \"\"\"\n    if density_estimator is None:\n        density_estimator = deepcopy(\n            self._neural_net\n        )  # PosteriorEstimator.train() also returns a deepcopy, mimic this here\n        # If internal net is used device is defined.\n        device = self._device\n    else:\n        # Otherwise, infer it from the device of the net parameters.\n        device = str(next(density_estimator.parameters()).device)\n\n    # Set proposal of the density estimator.\n    # This also evokes the z-scoring correction if necessary.\n    if (\n        self._proposal_roundwise[-1] is self._prior\n        or self._proposal_roundwise[-1] is None\n    ):\n        proposal = self._prior\n        assert isinstance(\n            proposal, (MultivariateNormal, BoxUniform)\n        ), \"\"\"Prior must be `torch.distributions.MultivariateNormal` or `sbi.utils.\n            BoxUniform`\"\"\"\n    else:\n        assert isinstance(\n            self._proposal_roundwise[-1], DirectPosterior\n        ), \"\"\"The proposal you passed to `append_simulations` is neither the prior\n            nor a `DirectPosterior`. SNPE-A currently only supports these scenarios.\n            \"\"\"\n        proposal = self._proposal_roundwise[-1]\n\n    # Create the NPE_A_MDN\n    wrapped_density_estimator = NPE_A_MDN(\n        flow=density_estimator,  # type: ignore\n        proposal=proposal,\n        prior=self._prior,\n        device=device,\n    )\n    return wrapped_density_estimator\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npe.npe_a.NPE_A.train","title":"<code>train(final_round=False, training_batch_size=200, learning_rate=0.0005, validation_fraction=0.1, stop_after_epochs=20, max_num_epochs=2 ** 31 - 1, clip_max_norm=5.0, calibration_kernel=None, resume_training=False, retrain_from_scratch=False, show_train_summary=False, dataloader_kwargs=None, component_perturbation=0.005)</code>","text":"<p>Return density estimator that approximates the proposal posterior.</p> <p>[1] Fast epsilon-free Inference of Simulation Models with Bayesian Conditional     Density Estimation, Papamakarios et al., NeurIPS 2016,     https://arxiv.org/abs/1605.06376.</p> <p>Training is performed with maximum likelihood on samples from the latest round, which leads the algorithm to converge to the proposal posterior.</p> <p>Parameters:</p> Name Type Description Default <code>final_round</code> <code>bool</code> <p>Whether we are in the last round of training or not. For all but the last round, Algorithm 1 from [1] is executed. In last the round, Algorithm 2 from [1] is executed once.</p> <code>False</code> <code>training_batch_size</code> <code>int</code> <p>Training batch size.</p> <code>200</code> <code>learning_rate</code> <code>float</code> <p>Learning rate for Adam optimizer.</p> <code>0.0005</code> <code>validation_fraction</code> <code>float</code> <p>The fraction of data to use for validation.</p> <code>0.1</code> <code>stop_after_epochs</code> <code>int</code> <p>The number of epochs to wait for improvement on the validation set before terminating training.</p> <code>20</code> <code>max_num_epochs</code> <code>int</code> <p>Maximum number of epochs to run. If reached, we stop training even when the validation loss is still decreasing. Otherwise, we train until validation loss increases (see also <code>stop_after_epochs</code>).</p> <code>2 ** 31 - 1</code> <code>clip_max_norm</code> <code>Optional[float]</code> <p>Value at which to clip the total gradient norm in order to prevent exploding gradients. Use None for no clipping.</p> <code>5.0</code> <code>calibration_kernel</code> <code>Optional[Callable]</code> <p>A function to calibrate the loss with respect to the simulations <code>x</code>. See Lueckmann, Gon\u00e7alves et al., NeurIPS 2017.</p> <code>None</code> <code>resume_training</code> <code>bool</code> <p>Can be used in case training time is limited, e.g. on a cluster. If <code>True</code>, the split between train and validation set, the optimizer, the number of epochs, and the best validation log-prob will be restored from the last time <code>.train()</code> was called.</p> <code>False</code> <code>force_first_round_loss</code> <p>If <code>True</code>, train with maximum likelihood, i.e., potentially ignoring the correction for using a proposal distribution different from the prior.</p> required <code>retrain_from_scratch</code> <code>bool</code> <p>Whether to retrain the conditional density estimator for the posterior from scratch each round. Not supported for SNPE-A.</p> <code>False</code> <code>show_train_summary</code> <code>bool</code> <p>Whether to print the number of epochs and validation loss and leakage after the training.</p> <code>False</code> <code>dataloader_kwargs</code> <code>Optional[Dict]</code> <p>Additional or updated kwargs to be passed to the training and validation dataloaders (like, e.g., a collate_fn)</p> <code>None</code> <code>component_perturbation</code> <code>float</code> <p>The standard deviation applied to all weights and biases when, in the last round, the Mixture of Gaussians is build from a single Gaussian. This value can be problem-specific and also depends on the number of mixture components.</p> <code>0.005</code> <p>Returns:</p> Type Description <code>ConditionalDensityEstimator</code> <p>Density estimator that approximates the distribution \\(p(\\theta|x)\\).</p> Source code in <code>sbi/inference/trainers/npe/npe_a.py</code> <pre><code>def train(\n    self,\n    final_round: bool = False,\n    training_batch_size: int = 200,\n    learning_rate: float = 5e-4,\n    validation_fraction: float = 0.1,\n    stop_after_epochs: int = 20,\n    max_num_epochs: int = 2**31 - 1,\n    clip_max_norm: Optional[float] = 5.0,\n    calibration_kernel: Optional[Callable] = None,\n    resume_training: bool = False,\n    retrain_from_scratch: bool = False,\n    show_train_summary: bool = False,\n    dataloader_kwargs: Optional[Dict] = None,\n    component_perturbation: float = 5e-3,\n) -&gt; ConditionalDensityEstimator:\n    r\"\"\"Return density estimator that approximates the proposal posterior.\n\n    [1] _Fast epsilon-free Inference of Simulation Models with Bayesian Conditional\n        Density Estimation_, Papamakarios et al., NeurIPS 2016,\n        https://arxiv.org/abs/1605.06376.\n\n    Training is performed with maximum likelihood on samples from the latest round,\n    which leads the algorithm to converge to the proposal posterior.\n\n    Args:\n        final_round: Whether we are in the last round of training or not. For all\n            but the last round, Algorithm 1 from [1] is executed. In last the\n            round, Algorithm 2 from [1] is executed once.\n        training_batch_size: Training batch size.\n        learning_rate: Learning rate for Adam optimizer.\n        validation_fraction: The fraction of data to use for validation.\n        stop_after_epochs: The number of epochs to wait for improvement on the\n            validation set before terminating training.\n        max_num_epochs: Maximum number of epochs to run. If reached, we stop\n            training even when the validation loss is still decreasing. Otherwise,\n            we train until validation loss increases (see also `stop_after_epochs`).\n        clip_max_norm: Value at which to clip the total gradient norm in order to\n            prevent exploding gradients. Use None for no clipping.\n        calibration_kernel: A function to calibrate the loss with respect to the\n            simulations `x`. See Lueckmann, Gon\u00e7alves et al., NeurIPS 2017.\n        resume_training: Can be used in case training time is limited, e.g. on a\n            cluster. If `True`, the split between train and validation set, the\n            optimizer, the number of epochs, and the best validation log-prob will\n            be restored from the last time `.train()` was called.\n        force_first_round_loss: If `True`, train with maximum likelihood,\n            i.e., potentially ignoring the correction for using a proposal\n            distribution different from the prior.\n        retrain_from_scratch: Whether to retrain the conditional density\n            estimator for the posterior from scratch each round. Not supported for\n            SNPE-A.\n        show_train_summary: Whether to print the number of epochs and validation\n            loss and leakage after the training.\n        dataloader_kwargs: Additional or updated kwargs to be passed to the training\n            and validation dataloaders (like, e.g., a collate_fn)\n        component_perturbation: The standard deviation applied to all weights and\n            biases when, in the last round, the Mixture of Gaussians is build from\n            a single Gaussian. This value can be problem-specific and also depends\n            on the number of mixture components.\n\n    Returns:\n        Density estimator that approximates the distribution $p(\\theta|x)$.\n    \"\"\"\n\n    assert not retrain_from_scratch, \"\"\"Retraining from scratch is not supported in\n        SNPE-A yet. The reason for this is that, if we reininitialized the density\n        estimator, the z-scoring would change, which would break the posthoc\n        correction. This is a pure implementation issue.\"\"\"\n\n    kwargs = del_entries(\n        locals(),\n        entries=(\n            \"self\",\n            \"__class__\",\n            \"final_round\",\n            \"component_perturbation\",\n        ),\n    )\n\n    # SNPE-A always discards the prior samples.\n    kwargs[\"discard_prior_samples\"] = True\n    kwargs[\"force_first_round_loss\"] = True\n\n    self._round = max(self._data_round_index)\n\n    if final_round:\n        # If there is (will be) only one round, train with Algorithm 2 from [1].\n        if self._round == 0:\n            self._build_neural_net = partial(\n                self._build_neural_net, num_components=self._num_components\n            )\n        # Run Algorithm 2 from [1].\n        elif not self._ran_final_round:\n            # Now switch to the specified number of components. This method will\n            # only be used if `retrain_from_scratch=True`. Otherwise,\n            # the MDN will be built from replicating the single-component net for\n            # `num_component` times (via `_expand_mog()`).\n            self._build_neural_net = partial(\n                self._build_neural_net, num_components=self._num_components\n            )\n\n            # Extend the MDN to the originally desired number of components.\n            self._expand_mog(eps=component_perturbation)\n        else:\n            warnings.warn(\n                \"You have already run SNPE-A with `final_round=True`. Running it\"\n                \"again with this setting will not allow computing the posthoc\"\n                \"correction applied in SNPE-A. Thus, you will get an error when \"\n                \"calling `.build_posterior()` after training.\",\n                UserWarning,\n                stacklevel=2,\n            )\n    else:\n        # Run Algorithm 1 from [1].\n        # Wrap the function that builds the MDN such that we can make\n        # sure that there is only one component when running.\n        self._build_neural_net = partial(self._build_neural_net, num_components=1)\n\n    if final_round:\n        self._ran_final_round = True\n\n    return super().train(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npe.npe_c.NPE_C","title":"<code>NPE_C</code>","text":"<p>               Bases: <code>PosteriorEstimator</code></p> Source code in <code>sbi/inference/trainers/npe/npe_c.py</code> <pre><code>class NPE_C(PosteriorEstimator):\n    def __init__(\n        self,\n        prior: Optional[Distribution] = None,\n        density_estimator: Union[str, Callable] = \"maf\",\n        device: str = \"cpu\",\n        logging_level: Union[int, str] = \"WARNING\",\n        summary_writer: Optional[TensorboardSummaryWriter] = None,\n        show_progress_bars: bool = True,\n    ):\n        r\"\"\"NPE-C / APT [1].\n\n        [1] _Automatic Posterior Transformation for Likelihood-free Inference_,\n            Greenberg et al., ICML 2019, https://arxiv.org/abs/1905.07488.\n\n        Like all NPE methods, this method trains a deep neural density estimator to\n        directly approximate the posterior. Also like all other NPE methods, in the\n        first round, this density estimator is trained with a maximum-likelihood loss.\n\n        For the sequential mode in which the density estimator is trained across rounds,\n        this class implements two loss variants of NPE-C: the non-atomic and the atomic\n        version. The atomic loss of NPE-C can be used for any density estimator,\n        i.e. also for normalizing flows. However, it suffers from leakage issues. On\n        the other hand, the non-atomic loss can only be used only if the proposal\n        distribution is a mixture of Gaussians, the density estimator is a mixture of\n        Gaussians, and the prior is either Gaussian or Uniform. It does not suffer from\n        leakage issues. At the beginning of each round, we print whether the non-atomic\n        or the atomic version is used.\n\n        In this codebase, we will automatically switch to the non-atomic loss if the\n        following criteria are fulfilled:&lt;br/&gt;\n        - proposal is a `DirectPosterior` with density_estimator `mdn`, as built\n            with `sbi.neural_nets.posterior_nn()`.&lt;br/&gt;\n        - the density estimator is a `mdn`, as built with\n            `sbi.neural_nets.posterior_nn()`.&lt;br/&gt;\n        - `isinstance(prior, MultivariateNormal)` (from `torch.distributions`) or\n            `isinstance(prior, sbi.utils.BoxUniform)`\n\n        Note that custom implementations of any of these densities (or estimators) will\n        not trigger the non-atomic loss, and the algorithm will fall back onto using\n        the atomic loss.\n\n        Args:\n            prior: A probability distribution that expresses prior knowledge about the\n                parameters, e.g. which ranges are meaningful for them.\n            density_estimator: If it is a string, use a pre-configured network of the\n                provided type (one of nsf, maf, mdn, made). Alternatively, a function\n                that builds a custom neural network can be provided. The function will\n                be called with the first batch of simulations (theta, x), which can\n                thus be used for shape inference and potentially for z-scoring. It\n                needs to return a PyTorch `nn.Module` implementing the density\n                estimator. The density estimator needs to provide the methods\n                `.log_prob` and `.sample()`.\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n            logging_level: Minimum severity of messages to log. One of the strings\n                INFO, WARNING, DEBUG, ERROR and CRITICAL.\n            summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n                file location (default is `&lt;current working directory&gt;/logs`.)\n            show_progress_bars: Whether to show a progressbar during training.\n        \"\"\"\n\n        kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n        super().__init__(**kwargs)\n\n    def train(\n        self,\n        num_atoms: int = 10,\n        training_batch_size: int = 200,\n        learning_rate: float = 5e-4,\n        validation_fraction: float = 0.1,\n        stop_after_epochs: int = 20,\n        max_num_epochs: int = 2**31 - 1,\n        clip_max_norm: Optional[float] = 5.0,\n        calibration_kernel: Optional[Callable] = None,\n        resume_training: bool = False,\n        force_first_round_loss: bool = False,\n        discard_prior_samples: bool = False,\n        use_combined_loss: bool = False,\n        retrain_from_scratch: bool = False,\n        show_train_summary: bool = False,\n        dataloader_kwargs: Optional[Dict] = None,\n    ) -&gt; nn.Module:\n        r\"\"\"Return density estimator that approximates the distribution $p(\\theta|x)$.\n\n        Args:\n            num_atoms: Number of atoms to use for classification.\n            training_batch_size: Training batch size.\n            learning_rate: Learning rate for Adam optimizer.\n            validation_fraction: The fraction of data to use for validation.\n            stop_after_epochs: The number of epochs to wait for improvement on the\n                validation set before terminating training.\n            max_num_epochs: Maximum number of epochs to run. If reached, we stop\n                training even when the validation loss is still decreasing. Otherwise,\n                we train until validation loss increases (see also `stop_after_epochs`).\n            clip_max_norm: Value at which to clip the total gradient norm in order to\n                prevent exploding gradients. Use None for no clipping.\n            calibration_kernel: A function to calibrate the loss with respect to the\n                simulations `x`. See Lueckmann, Gon\u00e7alves et al., NeurIPS 2017.\n            resume_training: Can be used in case training time is limited, e.g. on a\n                cluster. If `True`, the split between train and validation set, the\n                optimizer, the number of epochs, and the best validation log-prob will\n                be restored from the last time `.train()` was called.\n            force_first_round_loss: If `True`, train with maximum likelihood,\n                i.e., potentially ignoring the correction for using a proposal\n                distribution different from the prior.\n            discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n                from the prior. Training may be sped up by ignoring such less targeted\n                samples.\n            use_combined_loss: Whether to train the neural net also on prior samples\n                using maximum likelihood in addition to training it on all samples using\n                atomic loss. The extra MLE loss helps prevent density leaking with\n                bounded priors.\n            retrain_from_scratch: Whether to retrain the conditional density\n                estimator for the posterior from scratch each round.\n            show_train_summary: Whether to print the number of epochs and validation\n                loss and leakage after the training.\n            dataloader_kwargs: Additional or updated kwargs to be passed to the training\n                and validation dataloaders (like, e.g., a collate_fn)\n\n        Returns:\n            Density estimator that approximates the distribution $p(\\theta|x)$.\n        \"\"\"\n\n        # WARNING: sneaky trick ahead. We proxy the parent's `train` here,\n        # requiring the signature to have `num_atoms`, save it for use below, and\n        # continue. It's sneaky because we are using the object (self) as a namespace\n        # to pass arguments between functions, and that's implicit state management.\n        self._num_atoms = num_atoms\n        self._use_combined_loss = use_combined_loss\n        kwargs = del_entries(\n            locals(),\n            entries=(\"self\", \"__class__\", \"num_atoms\", \"use_combined_loss\"),\n        )\n\n        self._round = max(self._data_round_index)\n\n        if self._round &gt; 0:\n            # Set the proposal to the last proposal that was passed by the user. For\n            # atomic SNPE, it does not matter what the proposal is. For non-atomic\n            # SNPE, we only use the latest data that was passed, i.e. the one from the\n            # last proposal.\n            proposal = self._proposal_roundwise[-1]\n            self.use_non_atomic_loss = (\n                isinstance(proposal, DirectPosterior)\n                and isinstance(proposal.posterior_estimator.net._distribution, mdn)\n                and isinstance(self._neural_net.net._distribution, mdn)\n                and check_dist_class(\n                    self._prior, class_to_check=(Uniform, MultivariateNormal)\n                )[0]\n            )\n\n            algorithm = \"non-atomic\" if self.use_non_atomic_loss else \"atomic\"\n            print(f\"Using SNPE-C with {algorithm} loss\")\n\n            if self.use_non_atomic_loss:\n                # Take care of z-scoring, pre-compute and store prior terms.\n                self._set_state_for_mog_proposal()\n\n        return super().train(**kwargs)\n\n    def _set_state_for_mog_proposal(self) -&gt; None:\n        \"\"\"Set state variables that are used at each training step of non-atomic SNPE-C.\n\n        Three things are computed:\n        1) Check if z-scoring was requested. To do so, we check if the `_transform`\n            argument of the net had been a `CompositeTransform`. See pyknos mdn.py.\n        2) Define a (potentially standardized) prior. It's standardized if z-scoring\n            had been requested.\n        3) Compute (Precision * mean) for the prior. This quantity is used at every\n            training step if the prior is Gaussian.\n        \"\"\"\n\n        self.z_score_theta = isinstance(\n            self._neural_net.net._transform, CompositeTransform\n        )\n\n        self._set_maybe_z_scored_prior()\n\n        if isinstance(self._maybe_z_scored_prior, MultivariateNormal):\n            self.prec_m_prod_prior = torch.mv(\n                self._maybe_z_scored_prior.precision_matrix,  # type: ignore\n                self._maybe_z_scored_prior.loc,  # type: ignore\n            )\n\n    def _set_maybe_z_scored_prior(self) -&gt; None:\n        r\"\"\"Compute and store potentially standardized prior (if z-scoring was done).\n\n        The proposal posterior is:\n        $pp(\\theta|x) = 1/Z * q(\\theta|x) * prop(\\theta) / p(\\theta)$\n\n        Let's denote z-scored theta by `a`: a = (theta - mean) / std\n        Then pp'(a|x) = 1/Z_2 * q'(a|x) * prop'(a) / p'(a)$\n\n        The ' indicates that the evaluation occurs in standardized space. The constant\n        scaling factor has been absorbed into Z_2.\n        From the above equation, we see that we need to evaluate the prior **in\n        standardized space**. We build the standardized prior in this function.\n\n        The standardize transform that is applied to the samples theta does not use\n        the exact prior mean and std (due to implementation issues). Hence, the z-scored\n        prior will not be exactly have mean=0 and std=1.\n        \"\"\"\n\n        if self.z_score_theta:\n            scale = self._neural_net.net._transform._transforms[0]._scale\n            shift = self._neural_net.net._transform._transforms[0]._shift\n\n            # Following the definintion of the linear transform in\n            # `standardizing_transform` in `sbiutils.py`:\n            # shift=-mean / std\n            # scale=1 / std\n            # Solving these equations for mean and std:\n            estim_prior_std = 1 / scale\n            estim_prior_mean = -shift * estim_prior_std\n\n            # Compute the discrepancy of the true prior mean and std and the mean and\n            # std that was empirically estimated from samples.\n            # N(theta|m,s) = N((theta-m_e)/s_e|(m-m_e)/s_e, s/s_e)\n            # Above: m,s are true prior mean and std. m_e,s_e are estimated prior mean\n            # and std (estimated from samples and used to build standardize transform).\n            almost_zero_mean = (self._prior.mean - estim_prior_mean) / estim_prior_std\n            almost_one_std = torch.sqrt(self._prior.variance) / estim_prior_std\n\n            if isinstance(self._prior, MultivariateNormal):\n                self._maybe_z_scored_prior = MultivariateNormal(\n                    almost_zero_mean, torch.diag(almost_one_std)\n                )\n            else:\n                range_ = torch.sqrt(almost_one_std * 3.0)\n                self._maybe_z_scored_prior = BoxUniform(\n                    almost_zero_mean - range_, almost_zero_mean + range_\n                )\n        else:\n            self._maybe_z_scored_prior = self._prior\n\n    def _log_prob_proposal_posterior(\n        self,\n        theta: Tensor,\n        x: Tensor,\n        masks: Tensor,\n        proposal: DirectPosterior,\n    ) -&gt; Tensor:\n        \"\"\"Return the log-probability of the proposal posterior.\n\n        If the proposal is a MoG, the density estimator is a MoG, and the prior is\n        either Gaussian or uniform, we use non-atomic loss. Else, use atomic loss (which\n        suffers from leakage).\n\n        Args:\n            theta: Batch of parameters \u03b8.\n            x: Batch of data.\n            masks: Mask that is True for prior samples in the batch in order to train\n                them with prior loss.\n            proposal: Proposal distribution.\n\n        Returns: Log-probability of the proposal posterior.\n        \"\"\"\n\n        if self.use_non_atomic_loss:\n            if not (\n                hasattr(self._neural_net.net, \"_distribution\")\n                and isinstance(self._neural_net.net._distribution, mdn)\n            ):\n                raise ValueError(\n                    \"The density estimator must be a MDNtext for non-atomic loss.\"\n                )\n\n            return self._log_prob_proposal_posterior_mog(theta, x, proposal)\n        else:\n            if not hasattr(self._neural_net, \"log_prob\"):\n                raise ValueError(\n                    \"The neural estimator must have a log_prob method, for\\\n                                 atomic loss. It should at best follow the \\\n                                 sbi.neural_nets 'DensityEstiamtor' interface.\"\n                )\n            return self._log_prob_proposal_posterior_atomic(theta, x, masks)\n\n    def _log_prob_proposal_posterior_atomic(\n        self, theta: Tensor, x: Tensor, masks: Tensor\n    ):\n        \"\"\"Return log probability of the proposal posterior for atomic proposals.\n\n        We have two main options when evaluating the proposal posterior.\n            (1) Generate atoms from the proposal prior.\n            (2) Generate atoms from a more targeted distribution, such as the most\n                recent posterior.\n        If we choose the latter, it is likely beneficial not to do this in the first\n        round, since we would be sampling from a randomly-initialized neural density\n        estimator.\n\n        Args:\n            theta: Batch of parameters \u03b8.\n            x: Batch of data.\n            masks: Mask that is True for prior samples in the batch in order to train\n                them with prior loss.\n\n        Returns:\n            Log-probability of the proposal posterior.\n        \"\"\"\n        batch_size = theta.shape[0]\n\n        num_atoms = int(\n            clamp_and_warn(\"num_atoms\", self._num_atoms, min_val=2, max_val=batch_size)\n        )\n\n        # Each set of parameter atoms is evaluated using the same x,\n        # so we repeat rows of the data x, e.g. [1, 2] -&gt; [1, 1, 2, 2]\n        repeated_x = repeat_rows(x, num_atoms)\n\n        # To generate the full set of atoms for a given item in the batch,\n        # we sample without replacement num_atoms - 1 times from the rest\n        # of the theta in the batch.\n        probs = ones(batch_size, batch_size) * (1 - eye(batch_size)) / (batch_size - 1)\n\n        choices = torch.multinomial(probs, num_samples=num_atoms - 1, replacement=False)\n        contrasting_theta = theta[choices]\n\n        # We can now create our sets of atoms from the contrasting parameter sets\n        # we have generated.\n        atomic_theta = torch.cat((theta[:, None, :], contrasting_theta), dim=1).reshape(\n            batch_size * num_atoms, -1\n        )\n\n        # Get (batch_size * num_atoms) log prob prior evals.\n        log_prob_prior = self._prior.log_prob(atomic_theta)\n        log_prob_prior = log_prob_prior.reshape(batch_size, num_atoms)\n        assert_all_finite(log_prob_prior, \"prior eval\")\n\n        # Evaluate large batch giving (batch_size * num_atoms) log prob posterior evals.\n        atomic_theta = reshape_to_sample_batch_event(\n            atomic_theta, atomic_theta.shape[1:]\n        )\n        repeated_x = reshape_to_batch_event(\n            repeated_x, self._neural_net.condition_shape\n        )\n        log_prob_posterior = self._neural_net.log_prob(atomic_theta, repeated_x)\n        assert_all_finite(log_prob_posterior, \"posterior eval\")\n        log_prob_posterior = log_prob_posterior.reshape(batch_size, num_atoms)\n\n        # Compute unnormalized proposal posterior.\n        unnormalized_log_prob = log_prob_posterior - log_prob_prior\n\n        # Normalize proposal posterior across discrete set of atoms.\n        log_prob_proposal_posterior = unnormalized_log_prob[:, 0] - torch.logsumexp(\n            unnormalized_log_prob, dim=-1\n        )\n        assert_all_finite(log_prob_proposal_posterior, \"proposal posterior eval\")\n\n        # XXX This evaluates the posterior on _all_ prior samples\n        if self._use_combined_loss:\n            theta = reshape_to_sample_batch_event(theta, self._neural_net.input_shape)\n            x = reshape_to_batch_event(x, self._neural_net.condition_shape)\n            log_prob_posterior_non_atomic = self._neural_net.log_prob(theta, x)\n            # squeeze to remove sample dimension, which is always one during the loss\n            # evaluation of `SNPE_C` (because we have one theta vector per x vector).\n            log_prob_posterior_non_atomic = log_prob_posterior_non_atomic.squeeze(dim=0)\n            masks = masks.reshape(-1)\n            log_prob_proposal_posterior = (\n                masks * log_prob_posterior_non_atomic + log_prob_proposal_posterior\n            )\n\n        return log_prob_proposal_posterior\n\n    def _log_prob_proposal_posterior_mog(\n        self, theta: Tensor, x: Tensor, proposal: DirectPosterior\n    ) -&gt; Tensor:\n        \"\"\"Return log-probability of the proposal posterior for MoG proposal.\n\n        For MoG proposals and MoG density estimators, this can be done in closed form\n        and does not require atomic loss (i.e. there will be no leakage issues).\n\n        Notation:\n\n        m are mean vectors.\n        prec are precision matrices.\n        cov are covariance matrices.\n\n        _p at the end indicates that it is the proposal.\n        _d indicates that it is the density estimator.\n        _pp indicates the proposal posterior.\n\n        All tensors will have shapes (batch_dim, num_components, ...)\n\n        Args:\n            theta: Batch of parameters \u03b8.\n            x: Batch of data.\n            proposal: Proposal distribution.\n\n        Returns:\n            Log-probability of the proposal posterior.\n        \"\"\"\n\n        # Evaluate the proposal. MDNs do not have functionality to run the embedding_net\n        # and then get the mixture_components (**without** calling log_prob()). Hence,\n        # we call them separately here.\n        encoded_x = proposal.posterior_estimator.net._embedding_net(proposal.default_x)\n        dist = (\n            proposal.posterior_estimator.net._distribution\n        )  # defined to avoid ugly black formatting.\n        logits_p, m_p, prec_p, _, _ = dist.get_mixture_components(encoded_x)\n        norm_logits_p = logits_p - torch.logsumexp(logits_p, dim=-1, keepdim=True)\n\n        # Evaluate the density estimator.\n        encoded_x = self._neural_net.net._embedding_net(x)\n        dist = self._neural_net.net._distribution  # defined to avoid black formatting.\n        logits_d, m_d, prec_d, _, _ = dist.get_mixture_components(encoded_x)\n        norm_logits_d = logits_d - torch.logsumexp(logits_d, dim=-1, keepdim=True)\n\n        # z-score theta if it z-scoring had been requested.\n        theta = self._maybe_z_score_theta(theta)\n\n        # Compute the MoG parameters of the proposal posterior.\n        (\n            logits_pp,\n            m_pp,\n            prec_pp,\n            cov_pp,\n        ) = self._automatic_posterior_transformation(\n            norm_logits_p, m_p, prec_p, norm_logits_d, m_d, prec_d\n        )\n\n        # Compute the log_prob of theta under the product.\n        log_prob_proposal_posterior = mog_log_prob(theta, logits_pp, m_pp, prec_pp)\n        assert_all_finite(\n            log_prob_proposal_posterior,\n            \"\"\"the evaluation of the MoG proposal posterior. This is likely due to a\n            numerical instability in the training procedure. Please create an issue on\n            Github.\"\"\",\n        )\n\n        return log_prob_proposal_posterior\n\n    def _automatic_posterior_transformation(\n        self,\n        logits_p: Tensor,\n        means_p: Tensor,\n        precisions_p: Tensor,\n        logits_d: Tensor,\n        means_d: Tensor,\n        precisions_d: Tensor,\n    ):\n        r\"\"\"Returns the MoG parameters of the proposal posterior.\n\n        The proposal posterior is:\n        $pp(\\theta|x) = 1/Z * q(\\theta|x) * prop(\\theta) / p(\\theta)$\n        In words: proposal posterior = posterior estimate * proposal / prior.\n\n        If the posterior estimate and the proposal are MoG and the prior is either\n        Gaussian or uniform, we can solve this in closed-form. The is implemented in\n        this function.\n\n        This function implements Appendix A1 from Greenberg et al. 2019.\n\n        We have to build L*K components. How do we do this?\n        Example: proposal has two components, density estimator has three components.\n        Let's call the two components of the proposal i,j and the three components\n        of the density estimator x,y,z. We have to multiply every component of the\n        proposal with every component of the density estimator. So, what we do is:\n        1) for the proposal, build: i,i,i,j,j,j. Done with torch.repeat_interleave()\n        2) for the density estimator, build: x,y,z,x,y,z. Done with torch.repeat()\n        3) Multiply them with simple matrix operations.\n\n        Args:\n            logits_p: Component weight of each Gaussian of the proposal.\n            means_p: Mean of each Gaussian of the proposal.\n            precisions_p: Precision matrix of each Gaussian of the proposal.\n            logits_d: Component weight for each Gaussian of the density estimator.\n            means_d: Mean of each Gaussian of the density estimator.\n            precisions_d: Precision matrix of each Gaussian of the density estimator.\n\n        Returns: (Component weight, mean, precision matrix, covariance matrix) of each\n            Gaussian of the proposal posterior. Has L*K terms (proposal has L terms,\n            density estimator has K terms).\n        \"\"\"\n\n        precisions_pp, covariances_pp = self._precisions_proposal_posterior(\n            precisions_p, precisions_d\n        )\n\n        means_pp = self._means_proposal_posterior(\n            covariances_pp, means_p, precisions_p, means_d, precisions_d\n        )\n\n        logits_pp = self._logits_proposal_posterior(\n            means_pp,\n            precisions_pp,\n            covariances_pp,\n            logits_p,\n            means_p,\n            precisions_p,\n            logits_d,\n            means_d,\n            precisions_d,\n        )\n\n        return logits_pp, means_pp, precisions_pp, covariances_pp\n\n    def _precisions_proposal_posterior(\n        self, precisions_p: Tensor, precisions_d: Tensor\n    ):\n        \"\"\"Return the precisions and covariances of the proposal posterior.\n\n        Args:\n            precisions_p: Precision matrices of the proposal distribution.\n            precisions_d: Precision matrices of the density estimator.\n\n        Returns: (Precisions, Covariances) of the proposal posterior. L*K terms.\n        \"\"\"\n\n        num_comps_p = precisions_p.shape[1]\n        num_comps_d = precisions_d.shape[1]\n\n        precisions_p_rep = precisions_p.repeat_interleave(num_comps_d, dim=1)\n        precisions_d_rep = precisions_d.repeat(1, num_comps_p, 1, 1)\n\n        precisions_pp = precisions_p_rep + precisions_d_rep\n        if isinstance(self._maybe_z_scored_prior, MultivariateNormal):\n            precisions_pp -= self._maybe_z_scored_prior.precision_matrix\n\n        covariances_pp = torch.inverse(precisions_pp)\n\n        return precisions_pp, covariances_pp\n\n    def _means_proposal_posterior(\n        self,\n        covariances_pp: Tensor,\n        means_p: Tensor,\n        precisions_p: Tensor,\n        means_d: Tensor,\n        precisions_d: Tensor,\n    ):\n        \"\"\"Return the means of the proposal posterior.\n\n        means_pp = C_ix * (P_i * m_i + P_x * m_x - P_o * m_o).\n\n        Args:\n            covariances_pp: Covariance matrices of the proposal posterior.\n            means_p: Means of the proposal distribution.\n            precisions_p: Precision matrices of the proposal distribution.\n            means_d: Means of the density estimator.\n            precisions_d: Precision matrices of the density estimator.\n\n        Returns: Means of the proposal posterior. L*K terms.\n        \"\"\"\n\n        num_comps_p = precisions_p.shape[1]\n        num_comps_d = precisions_d.shape[1]\n\n        # First, compute the product P_i * m_i and P_j * m_j\n        prec_m_prod_p = batched_mixture_mv(precisions_p, means_p)\n        prec_m_prod_d = batched_mixture_mv(precisions_d, means_d)\n\n        # Repeat them to allow for matrix operations: same trick as for the precisions.\n        prec_m_prod_p_rep = prec_m_prod_p.repeat_interleave(num_comps_d, dim=1)\n        prec_m_prod_d_rep = prec_m_prod_d.repeat(1, num_comps_p, 1)\n\n        # Means = C_ij * (P_i * m_i + P_x * m_x - P_o * m_o).\n        summed_cov_m_prod_rep = prec_m_prod_p_rep + prec_m_prod_d_rep\n        if isinstance(self._maybe_z_scored_prior, MultivariateNormal):\n            summed_cov_m_prod_rep -= self.prec_m_prod_prior\n\n        means_pp = batched_mixture_mv(covariances_pp, summed_cov_m_prod_rep)\n\n        return means_pp\n\n    @staticmethod\n    def _logits_proposal_posterior(\n        means_pp: Tensor,\n        precisions_pp: Tensor,\n        covariances_pp: Tensor,\n        logits_p: Tensor,\n        means_p: Tensor,\n        precisions_p: Tensor,\n        logits_d: Tensor,\n        means_d: Tensor,\n        precisions_d: Tensor,\n    ):\n        \"\"\"Return the component weights (i.e. logits) of the proposal posterior.\n\n        Args:\n            means_pp: Means of the proposal posterior.\n            precisions_pp: Precision matrices of the proposal posterior.\n            covariances_pp: Covariance matrices of the proposal posterior.\n            logits_p: Component weights (i.e. logits) of the proposal distribution.\n            means_p: Means of the proposal distribution.\n            precisions_p: Precision matrices of the proposal distribution.\n            logits_d: Component weights (i.e. logits) of the density estimator.\n            means_d: Means of the density estimator.\n            precisions_d: Precision matrices of the density estimator.\n\n        Returns: Component weights of the proposal posterior. L*K terms.\n        \"\"\"\n\n        num_comps_p = precisions_p.shape[1]\n        num_comps_d = precisions_d.shape[1]\n\n        # Compute log(alpha_i * beta_j)\n        logits_p_rep = logits_p.repeat_interleave(num_comps_d, dim=1)\n        logits_d_rep = logits_d.repeat(1, num_comps_p)\n        logit_factors = logits_p_rep + logits_d_rep\n\n        # Compute sqrt(det()/(det()*det()))\n        logdet_covariances_pp = torch.logdet(covariances_pp)\n        logdet_covariances_p = -torch.logdet(precisions_p)\n        logdet_covariances_d = -torch.logdet(precisions_d)\n\n        # Repeat the proposal and density estimator terms such that there are LK terms.\n        # Same trick as has been used above.\n        logdet_covariances_p_rep = logdet_covariances_p.repeat_interleave(\n            num_comps_d, dim=1\n        )\n        logdet_covariances_d_rep = logdet_covariances_d.repeat(1, num_comps_p)\n\n        log_sqrt_det_ratio = 0.5 * (\n            logdet_covariances_pp\n            - (logdet_covariances_p_rep + logdet_covariances_d_rep)\n        )\n\n        # Compute for proposal, density estimator, and proposal posterior:\n        # mu_i.T * P_i * mu_i\n        exponent_p = batched_mixture_vmv(precisions_p, means_p)\n        exponent_d = batched_mixture_vmv(precisions_d, means_d)\n        exponent_pp = batched_mixture_vmv(precisions_pp, means_pp)\n\n        # Extend proposal and density estimator exponents to get LK terms.\n        exponent_p_rep = exponent_p.repeat_interleave(num_comps_d, dim=1)\n        exponent_d_rep = exponent_d.repeat(1, num_comps_p)\n        exponent = -0.5 * (exponent_p_rep + exponent_d_rep - exponent_pp)\n\n        logits_pp = logit_factors + log_sqrt_det_ratio + exponent\n\n        return logits_pp\n\n    def _maybe_z_score_theta(self, theta: Tensor) -&gt; Tensor:\n        \"\"\"Return potentially standardized theta if z-scoring was requested.\"\"\"\n\n        if self.z_score_theta:\n            theta, _ = self._neural_net.net._transform(theta)\n\n        return theta\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npe.npe_c.NPE_C.__init__","title":"<code>__init__(prior=None, density_estimator='maf', device='cpu', logging_level='WARNING', summary_writer=None, show_progress_bars=True)</code>","text":"<p>NPE-C / APT [1].</p> <p>[1] Automatic Posterior Transformation for Likelihood-free Inference,     Greenberg et al., ICML 2019, https://arxiv.org/abs/1905.07488.</p> <p>Like all NPE methods, this method trains a deep neural density estimator to directly approximate the posterior. Also like all other NPE methods, in the first round, this density estimator is trained with a maximum-likelihood loss.</p> <p>For the sequential mode in which the density estimator is trained across rounds, this class implements two loss variants of NPE-C: the non-atomic and the atomic version. The atomic loss of NPE-C can be used for any density estimator, i.e. also for normalizing flows. However, it suffers from leakage issues. On the other hand, the non-atomic loss can only be used only if the proposal distribution is a mixture of Gaussians, the density estimator is a mixture of Gaussians, and the prior is either Gaussian or Uniform. It does not suffer from leakage issues. At the beginning of each round, we print whether the non-atomic or the atomic version is used.</p> <p>In this codebase, we will automatically switch to the non-atomic loss if the following criteria are fulfilled: - proposal is a <code>DirectPosterior</code> with density_estimator <code>mdn</code>, as built     with <code>sbi.neural_nets.posterior_nn()</code>. - the density estimator is a <code>mdn</code>, as built with     <code>sbi.neural_nets.posterior_nn()</code>. - <code>isinstance(prior, MultivariateNormal)</code> (from <code>torch.distributions</code>) or     <code>isinstance(prior, sbi.utils.BoxUniform)</code></p> <p>Note that custom implementations of any of these densities (or estimators) will not trigger the non-atomic loss, and the algorithm will fall back onto using the atomic loss.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Optional[Distribution]</code> <p>A probability distribution that expresses prior knowledge about the parameters, e.g. which ranges are meaningful for them.</p> <code>None</code> <code>density_estimator</code> <code>Union[str, Callable]</code> <p>If it is a string, use a pre-configured network of the provided type (one of nsf, maf, mdn, made). Alternatively, a function that builds a custom neural network can be provided. The function will be called with the first batch of simulations (theta, x), which can thus be used for shape inference and potentially for z-scoring. It needs to return a PyTorch <code>nn.Module</code> implementing the density estimator. The density estimator needs to provide the methods <code>.log_prob</code> and <code>.sample()</code>.</p> <code>'maf'</code> <code>device</code> <code>str</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:{0, 1, \u2026}\u201d.</p> <code>'cpu'</code> <code>logging_level</code> <code>Union[int, str]</code> <p>Minimum severity of messages to log. One of the strings INFO, WARNING, DEBUG, ERROR and CRITICAL.</p> <code>'WARNING'</code> <code>summary_writer</code> <code>Optional[TensorboardSummaryWriter]</code> <p>A tensorboard <code>SummaryWriter</code> to control, among others, log file location (default is <code>&lt;current working directory&gt;/logs</code>.)</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during training.</p> <code>True</code> Source code in <code>sbi/inference/trainers/npe/npe_c.py</code> <pre><code>def __init__(\n    self,\n    prior: Optional[Distribution] = None,\n    density_estimator: Union[str, Callable] = \"maf\",\n    device: str = \"cpu\",\n    logging_level: Union[int, str] = \"WARNING\",\n    summary_writer: Optional[TensorboardSummaryWriter] = None,\n    show_progress_bars: bool = True,\n):\n    r\"\"\"NPE-C / APT [1].\n\n    [1] _Automatic Posterior Transformation for Likelihood-free Inference_,\n        Greenberg et al., ICML 2019, https://arxiv.org/abs/1905.07488.\n\n    Like all NPE methods, this method trains a deep neural density estimator to\n    directly approximate the posterior. Also like all other NPE methods, in the\n    first round, this density estimator is trained with a maximum-likelihood loss.\n\n    For the sequential mode in which the density estimator is trained across rounds,\n    this class implements two loss variants of NPE-C: the non-atomic and the atomic\n    version. The atomic loss of NPE-C can be used for any density estimator,\n    i.e. also for normalizing flows. However, it suffers from leakage issues. On\n    the other hand, the non-atomic loss can only be used only if the proposal\n    distribution is a mixture of Gaussians, the density estimator is a mixture of\n    Gaussians, and the prior is either Gaussian or Uniform. It does not suffer from\n    leakage issues. At the beginning of each round, we print whether the non-atomic\n    or the atomic version is used.\n\n    In this codebase, we will automatically switch to the non-atomic loss if the\n    following criteria are fulfilled:&lt;br/&gt;\n    - proposal is a `DirectPosterior` with density_estimator `mdn`, as built\n        with `sbi.neural_nets.posterior_nn()`.&lt;br/&gt;\n    - the density estimator is a `mdn`, as built with\n        `sbi.neural_nets.posterior_nn()`.&lt;br/&gt;\n    - `isinstance(prior, MultivariateNormal)` (from `torch.distributions`) or\n        `isinstance(prior, sbi.utils.BoxUniform)`\n\n    Note that custom implementations of any of these densities (or estimators) will\n    not trigger the non-atomic loss, and the algorithm will fall back onto using\n    the atomic loss.\n\n    Args:\n        prior: A probability distribution that expresses prior knowledge about the\n            parameters, e.g. which ranges are meaningful for them.\n        density_estimator: If it is a string, use a pre-configured network of the\n            provided type (one of nsf, maf, mdn, made). Alternatively, a function\n            that builds a custom neural network can be provided. The function will\n            be called with the first batch of simulations (theta, x), which can\n            thus be used for shape inference and potentially for z-scoring. It\n            needs to return a PyTorch `nn.Module` implementing the density\n            estimator. The density estimator needs to provide the methods\n            `.log_prob` and `.sample()`.\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n        logging_level: Minimum severity of messages to log. One of the strings\n            INFO, WARNING, DEBUG, ERROR and CRITICAL.\n        summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n            file location (default is `&lt;current working directory&gt;/logs`.)\n        show_progress_bars: Whether to show a progressbar during training.\n    \"\"\"\n\n    kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npe.npe_c.NPE_C.train","title":"<code>train(num_atoms=10, training_batch_size=200, learning_rate=0.0005, validation_fraction=0.1, stop_after_epochs=20, max_num_epochs=2 ** 31 - 1, clip_max_norm=5.0, calibration_kernel=None, resume_training=False, force_first_round_loss=False, discard_prior_samples=False, use_combined_loss=False, retrain_from_scratch=False, show_train_summary=False, dataloader_kwargs=None)</code>","text":"<p>Return density estimator that approximates the distribution \\(p(\\theta|x)\\).</p> <p>Parameters:</p> Name Type Description Default <code>num_atoms</code> <code>int</code> <p>Number of atoms to use for classification.</p> <code>10</code> <code>training_batch_size</code> <code>int</code> <p>Training batch size.</p> <code>200</code> <code>learning_rate</code> <code>float</code> <p>Learning rate for Adam optimizer.</p> <code>0.0005</code> <code>validation_fraction</code> <code>float</code> <p>The fraction of data to use for validation.</p> <code>0.1</code> <code>stop_after_epochs</code> <code>int</code> <p>The number of epochs to wait for improvement on the validation set before terminating training.</p> <code>20</code> <code>max_num_epochs</code> <code>int</code> <p>Maximum number of epochs to run. If reached, we stop training even when the validation loss is still decreasing. Otherwise, we train until validation loss increases (see also <code>stop_after_epochs</code>).</p> <code>2 ** 31 - 1</code> <code>clip_max_norm</code> <code>Optional[float]</code> <p>Value at which to clip the total gradient norm in order to prevent exploding gradients. Use None for no clipping.</p> <code>5.0</code> <code>calibration_kernel</code> <code>Optional[Callable]</code> <p>A function to calibrate the loss with respect to the simulations <code>x</code>. See Lueckmann, Gon\u00e7alves et al., NeurIPS 2017.</p> <code>None</code> <code>resume_training</code> <code>bool</code> <p>Can be used in case training time is limited, e.g. on a cluster. If <code>True</code>, the split between train and validation set, the optimizer, the number of epochs, and the best validation log-prob will be restored from the last time <code>.train()</code> was called.</p> <code>False</code> <code>force_first_round_loss</code> <code>bool</code> <p>If <code>True</code>, train with maximum likelihood, i.e., potentially ignoring the correction for using a proposal distribution different from the prior.</p> <code>False</code> <code>discard_prior_samples</code> <code>bool</code> <p>Whether to discard samples simulated in round 1, i.e. from the prior. Training may be sped up by ignoring such less targeted samples.</p> <code>False</code> <code>use_combined_loss</code> <code>bool</code> <p>Whether to train the neural net also on prior samples using maximum likelihood in addition to training it on all samples using atomic loss. The extra MLE loss helps prevent density leaking with bounded priors.</p> <code>False</code> <code>retrain_from_scratch</code> <code>bool</code> <p>Whether to retrain the conditional density estimator for the posterior from scratch each round.</p> <code>False</code> <code>show_train_summary</code> <code>bool</code> <p>Whether to print the number of epochs and validation loss and leakage after the training.</p> <code>False</code> <code>dataloader_kwargs</code> <code>Optional[Dict]</code> <p>Additional or updated kwargs to be passed to the training and validation dataloaders (like, e.g., a collate_fn)</p> <code>None</code> <p>Returns:</p> Type Description <code>Module</code> <p>Density estimator that approximates the distribution \\(p(\\theta|x)\\).</p> Source code in <code>sbi/inference/trainers/npe/npe_c.py</code> <pre><code>def train(\n    self,\n    num_atoms: int = 10,\n    training_batch_size: int = 200,\n    learning_rate: float = 5e-4,\n    validation_fraction: float = 0.1,\n    stop_after_epochs: int = 20,\n    max_num_epochs: int = 2**31 - 1,\n    clip_max_norm: Optional[float] = 5.0,\n    calibration_kernel: Optional[Callable] = None,\n    resume_training: bool = False,\n    force_first_round_loss: bool = False,\n    discard_prior_samples: bool = False,\n    use_combined_loss: bool = False,\n    retrain_from_scratch: bool = False,\n    show_train_summary: bool = False,\n    dataloader_kwargs: Optional[Dict] = None,\n) -&gt; nn.Module:\n    r\"\"\"Return density estimator that approximates the distribution $p(\\theta|x)$.\n\n    Args:\n        num_atoms: Number of atoms to use for classification.\n        training_batch_size: Training batch size.\n        learning_rate: Learning rate for Adam optimizer.\n        validation_fraction: The fraction of data to use for validation.\n        stop_after_epochs: The number of epochs to wait for improvement on the\n            validation set before terminating training.\n        max_num_epochs: Maximum number of epochs to run. If reached, we stop\n            training even when the validation loss is still decreasing. Otherwise,\n            we train until validation loss increases (see also `stop_after_epochs`).\n        clip_max_norm: Value at which to clip the total gradient norm in order to\n            prevent exploding gradients. Use None for no clipping.\n        calibration_kernel: A function to calibrate the loss with respect to the\n            simulations `x`. See Lueckmann, Gon\u00e7alves et al., NeurIPS 2017.\n        resume_training: Can be used in case training time is limited, e.g. on a\n            cluster. If `True`, the split between train and validation set, the\n            optimizer, the number of epochs, and the best validation log-prob will\n            be restored from the last time `.train()` was called.\n        force_first_round_loss: If `True`, train with maximum likelihood,\n            i.e., potentially ignoring the correction for using a proposal\n            distribution different from the prior.\n        discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n            from the prior. Training may be sped up by ignoring such less targeted\n            samples.\n        use_combined_loss: Whether to train the neural net also on prior samples\n            using maximum likelihood in addition to training it on all samples using\n            atomic loss. The extra MLE loss helps prevent density leaking with\n            bounded priors.\n        retrain_from_scratch: Whether to retrain the conditional density\n            estimator for the posterior from scratch each round.\n        show_train_summary: Whether to print the number of epochs and validation\n            loss and leakage after the training.\n        dataloader_kwargs: Additional or updated kwargs to be passed to the training\n            and validation dataloaders (like, e.g., a collate_fn)\n\n    Returns:\n        Density estimator that approximates the distribution $p(\\theta|x)$.\n    \"\"\"\n\n    # WARNING: sneaky trick ahead. We proxy the parent's `train` here,\n    # requiring the signature to have `num_atoms`, save it for use below, and\n    # continue. It's sneaky because we are using the object (self) as a namespace\n    # to pass arguments between functions, and that's implicit state management.\n    self._num_atoms = num_atoms\n    self._use_combined_loss = use_combined_loss\n    kwargs = del_entries(\n        locals(),\n        entries=(\"self\", \"__class__\", \"num_atoms\", \"use_combined_loss\"),\n    )\n\n    self._round = max(self._data_round_index)\n\n    if self._round &gt; 0:\n        # Set the proposal to the last proposal that was passed by the user. For\n        # atomic SNPE, it does not matter what the proposal is. For non-atomic\n        # SNPE, we only use the latest data that was passed, i.e. the one from the\n        # last proposal.\n        proposal = self._proposal_roundwise[-1]\n        self.use_non_atomic_loss = (\n            isinstance(proposal, DirectPosterior)\n            and isinstance(proposal.posterior_estimator.net._distribution, mdn)\n            and isinstance(self._neural_net.net._distribution, mdn)\n            and check_dist_class(\n                self._prior, class_to_check=(Uniform, MultivariateNormal)\n            )[0]\n        )\n\n        algorithm = \"non-atomic\" if self.use_non_atomic_loss else \"atomic\"\n        print(f\"Using SNPE-C with {algorithm} loss\")\n\n        if self.use_non_atomic_loss:\n            # Take care of z-scoring, pre-compute and store prior terms.\n            self._set_state_for_mog_proposal()\n\n    return super().train(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.fmpe.fmpe.FMPE","title":"<code>FMPE</code>","text":"<p>               Bases: <code>NeuralInference</code></p> <p>Implements the Flow Matching Posterior Estimator (FMPE) for simulation-based inference.</p> Source code in <code>sbi/inference/trainers/fmpe/fmpe.py</code> <pre><code>class FMPE(NeuralInference):\n    \"\"\"Implements the Flow Matching Posterior Estimator (FMPE) for\n    simulation-based inference.\n    \"\"\"\n\n    def __init__(\n        self,\n        prior: Optional[Distribution],\n        density_estimator: Union[str, Callable] = \"mlp\",\n        device: str = \"cpu\",\n        logging_level: Union[int, str] = \"WARNING\",\n        summary_writer: Optional[SummaryWriter] = None,\n        show_progress_bars: bool = True,\n    ) -&gt; None:\n        \"\"\"Initialization method for the FMPE class.\n\n        Args:\n            prior: Prior distribution.\n            density_estimator: Neural network architecture used to learn the vector\n                field for flow matching. Can be a string, e.g., 'mlp' or 'resnet', or a\n                `Callable` that builds a corresponding neural network.\n            device: Device to use for training.\n            logging_level: Logging level.\n            summary_writer: Summary writer for tensorboard.\n            show_progress_bars: Whether to show progress bars.\n        \"\"\"\n        # obtain the shape of the prior samples\n        if isinstance(density_estimator, str):\n            self._build_neural_net = flowmatching_nn(model=density_estimator)\n        else:\n            self._build_neural_net = density_estimator\n\n        super().__init__(\n            prior=prior,\n            device=device,\n            logging_level=logging_level,\n            summary_writer=summary_writer,\n            show_progress_bars=show_progress_bars,\n        )\n\n    def append_simulations(\n        self,\n        theta: torch.Tensor,\n        x: torch.Tensor,\n        proposal: Optional[DirectPosterior] = None,\n        exclude_invalid_x: Optional[bool] = None,\n        data_device: Optional[str] = None,\n    ) -&gt; NeuralInference:\n        if (\n            proposal is None\n            or proposal is self._prior\n            or (\n                isinstance(proposal, RestrictedPrior) and proposal._prior is self._prior\n            )\n        ):\n            current_round = 0\n        else:\n            raise NotImplementedError(\n                \"Sequential FMPE with proposal different from prior is not implemented.\"\n            )\n\n        if exclude_invalid_x is None:\n            exclude_invalid_x = current_round == 0\n\n        if data_device is None:\n            data_device = self._device\n\n        theta, x = validate_theta_and_x(\n            theta, x, data_device=data_device, training_device=self._device\n        )\n\n        is_valid_x, num_nans, num_infs = handle_invalid_x(\n            x, exclude_invalid_x=exclude_invalid_x\n        )\n\n        x = x[is_valid_x]\n        theta = theta[is_valid_x]\n\n        # Check for problematic z-scoring\n        warn_if_zscoring_changes_data(x)\n        # Check whether there are NaNs or Infs in the data and remove accordingly.\n        npe_msg_on_invalid_x(\n            num_nans=num_nans,\n            num_infs=num_infs,\n            exclude_invalid_x=exclude_invalid_x,\n            algorithm=\"Single-round FMPE\",\n        )\n\n        self._data_round_index.append(current_round)\n        prior_masks = mask_sims_from_prior(int(current_round &gt; 0), theta.size(0))\n\n        self._theta_roundwise.append(theta)\n        self._x_roundwise.append(x)\n        self._prior_masks.append(prior_masks)\n\n        return self\n\n    def train(\n        self,\n        training_batch_size: int = 200,\n        learning_rate: float = 5e-4,\n        validation_fraction: float = 0.1,\n        stop_after_epochs: int = 20,\n        max_num_epochs: int = 2**31 - 1,\n        clip_max_norm: Optional[float] = 5.0,\n        resume_training: bool = False,\n        force_first_round_loss: bool = False,\n        show_train_summary: bool = False,\n        dataloader_kwargs: Optional[dict] = None,\n    ) -&gt; ConditionalDensityEstimator:\n        \"\"\"Train the flow matching estimator.\n\n        Args:\n            training_batch_size: Batch size for training. Defaults to 50.\n            learning_rate: Learning rate for training. Defaults to 5e-4.\n            validation_fraction: Fraction of the data to use for validation.\n            stop_after_epochs: Number of epochs to train for. Defaults to 20.\n            max_num_epochs: Maximum number of epochs to train for.\n            clip_max_norm: Maximum norm for gradient clipping. Defaults to 5.0.\n            resume_training: Can be used in case training time is limited, e.g. on a\n                cluster. If `True`, the split between train and validation set, the\n                optimizer, the number of epochs, and the best validation log-prob will\n                be restored from the last time `.train()` was called.\n            force_first_round_loss: Whether to allow training with\n                simulations that have not been sampled from the prior, e.g., in a\n                sequential inference setting. Note that can lead to biased inference\n                results.\n            show_train_summary: Whether to show the training summary. Defaults to False.\n            dataloader_kwargs: Additional keyword arguments for the dataloader.\n\n        Returns:\n            DensityEstimator: Trained flow matching estimator.\n        \"\"\"\n\n        # Load data from most recent round.\n        self._round = max(self._data_round_index)\n\n        if self._round == 0 and self._neural_net is not None:\n            assert force_first_round_loss or resume_training, (\n                \"You have already trained this neural network. After you had trained \"\n                \"the network, you again appended simulations with `append_simulations\"\n                \"(theta, x)`, but you did not provide a proposal. If the new \"\n                \"simulations are sampled from the prior, you can set \"\n                \"`.train(..., force_first_round_loss=True`). However, if the new \"\n                \"simulations were not sampled from the prior, you should pass the \"\n                \"proposal, i.e. `append_simulations(theta, x, proposal)`. If \"\n                \"your samples are not sampled from the prior and you do not pass a \"\n                \"proposal and you set `force_first_round_loss=True`, the result of \"\n                \"FMPE will not be the true posterior. Instead, it will be the proposal \"\n                \"posterior, which (usually) is more narrow than the true posterior.\"\n            )\n\n        start_idx = 0  # as there is no multi-round FMPE yet\n\n        train_loader, val_loader = self.get_dataloaders(\n            start_idx,\n            training_batch_size,\n            validation_fraction,\n            resume_training=resume_training,\n            dataloader_kwargs=dataloader_kwargs,\n        )\n\n        if self._neural_net is None:\n            # Get theta, x to initialize NN\n            theta, x, _ = self.get_simulations(starting_round=start_idx)\n\n            # Use only training data for building the neural net (z-scoring transforms)\n            self._neural_net = self._build_neural_net(\n                theta[self.train_indices].to(\"cpu\"),\n                x[self.train_indices].to(\"cpu\"),\n            )\n\n            del theta, x\n\n        # Move entire net to device for training.\n        self._neural_net.to(self._device)\n\n        # initialize optimizer and training parameters\n        if not resume_training:\n            self.optimizer = Adam(\n                list(self._neural_net.net.parameters()), lr=learning_rate\n            )\n            self.epoch = 0\n            # NOTE: in the FMPE context we use MSE loss, not log probs.\n            self._val_loss = float(\"Inf\")\n\n        while self.epoch &lt;= max_num_epochs and not self._converged(\n            self.epoch, stop_after_epochs\n        ):\n            self._neural_net.net.train()\n            train_loss_sum = 0\n            epoch_start_time = time.time()\n            for batch in train_loader:\n                self.optimizer.zero_grad()\n                # get batches on current device.\n                theta_batch, x_batch = (\n                    batch[0].to(self._device),\n                    batch[1].to(self._device),\n                )\n\n                train_loss = self._neural_net.loss(theta_batch, x_batch).mean()\n                train_loss_sum += train_loss.item()\n\n                train_loss.backward()\n                if clip_max_norm is not None:\n                    clip_grad_norm_(\n                        self._neural_net.net.parameters(), max_norm=clip_max_norm\n                    )\n                self.optimizer.step()\n\n            self.epoch += 1\n\n            train_loss_average = train_loss_sum / len(train_loader)  # type: ignore\n            self._summary[\"training_loss\"].append(train_loss_average)\n\n            # Calculate validation performance.\n            self._neural_net.eval()\n            val_loss_sum = 0\n\n            with torch.no_grad():\n                for batch in val_loader:\n                    theta_batch, x_batch = (\n                        batch[0].to(self._device),\n                        batch[1].to(self._device),\n                    )\n                    # Aggregate the validation losses.\n                    val_losses = self._neural_net.loss(theta_batch, x_batch)\n                    val_loss_sum += val_losses.sum().item()\n\n            # Take mean over all validation samples.\n            self._val_loss = val_loss_sum / (\n                len(val_loader) * val_loader.batch_size  # type: ignore\n            )\n            # Log validation loss for every epoch.\n            self._summary[\"validation_loss\"].append(self._val_loss)\n            self._summary[\"epoch_durations_sec\"].append(time.time() - epoch_start_time)\n\n            self._maybe_show_progress(self._show_progress_bars, self.epoch)\n\n        self._report_convergence_at_end(self.epoch, stop_after_epochs, max_num_epochs)\n\n        # Update summary.\n        self._summary[\"epochs_trained\"].append(self.epoch)\n        self._summary[\"best_validation_loss\"].append(self._best_val_loss)\n\n        # Update tensorboard and summary dict.\n        self._summarize(round_=self._round)\n\n        # Update description for progress bar.\n        if show_train_summary:\n            print(self._describe_round(self._round, self._summary))\n\n        # Avoid keeping the gradients in the resulting network, which can\n        # cause memory leakage when benchmarking.\n        self._neural_net.zero_grad(set_to_none=True)\n\n        return deepcopy(self._neural_net)\n\n    def build_posterior(\n        self,\n        density_estimator: Optional[ConditionalDensityEstimator] = None,\n        prior: Optional[Distribution] = None,\n        sample_with: str = \"direct\",\n        direct_sampling_parameters: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ) -&gt; DirectPosterior:\n        \"\"\"Build the posterior distribution.\n\n        Args:\n            density_estimator: Density estimator for the posterior.\n            prior: Prior distribution.\n            sample_with: Sampling method, currently only \"direct\" is supported.\n            direct_sampling_parameters: kwargs for DirectPosterior.\n\n        Returns:\n            DirectPosterior: Posterior distribution.\n        \"\"\"\n        if sample_with != \"direct\":\n            raise NotImplementedError(\n                \"Currently, only direct sampling is supported for FMPE.\"\n            )\n\n        if prior is None:\n            assert self._prior is not None, (\n                \"You did not pass a prior. You have to pass the prior either at \"\n                \"initialization `inference = SNPE(prior)` or to \"\n                \"`.build_posterior(prior=prior)`.\"\n            )\n            prior = self._prior\n        else:\n            utils.check_prior(prior)\n\n        if density_estimator is None:\n            posterior_estimator = self._neural_net\n            # If internal net is used device is defined.\n            device = self._device\n        else:\n            posterior_estimator = density_estimator\n            # Otherwise, infer it from the device of the net parameters.\n            device = next(density_estimator.parameters()).device.type\n\n        self._posterior = DirectPosterior(\n            posterior_estimator=posterior_estimator,  # type: ignore\n            prior=prior,\n            device=device,\n            **direct_sampling_parameters or {},\n        )\n\n        return deepcopy(self._posterior)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.fmpe.fmpe.FMPE.__init__","title":"<code>__init__(prior, density_estimator='mlp', device='cpu', logging_level='WARNING', summary_writer=None, show_progress_bars=True)</code>","text":"<p>Initialization method for the FMPE class.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Optional[Distribution]</code> <p>Prior distribution.</p> required <code>density_estimator</code> <code>Union[str, Callable]</code> <p>Neural network architecture used to learn the vector field for flow matching. Can be a string, e.g., \u2018mlp\u2019 or \u2018resnet\u2019, or a <code>Callable</code> that builds a corresponding neural network.</p> <code>'mlp'</code> <code>device</code> <code>str</code> <p>Device to use for training.</p> <code>'cpu'</code> <code>logging_level</code> <code>Union[int, str]</code> <p>Logging level.</p> <code>'WARNING'</code> <code>summary_writer</code> <code>Optional[SummaryWriter]</code> <p>Summary writer for tensorboard.</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show progress bars.</p> <code>True</code> Source code in <code>sbi/inference/trainers/fmpe/fmpe.py</code> <pre><code>def __init__(\n    self,\n    prior: Optional[Distribution],\n    density_estimator: Union[str, Callable] = \"mlp\",\n    device: str = \"cpu\",\n    logging_level: Union[int, str] = \"WARNING\",\n    summary_writer: Optional[SummaryWriter] = None,\n    show_progress_bars: bool = True,\n) -&gt; None:\n    \"\"\"Initialization method for the FMPE class.\n\n    Args:\n        prior: Prior distribution.\n        density_estimator: Neural network architecture used to learn the vector\n            field for flow matching. Can be a string, e.g., 'mlp' or 'resnet', or a\n            `Callable` that builds a corresponding neural network.\n        device: Device to use for training.\n        logging_level: Logging level.\n        summary_writer: Summary writer for tensorboard.\n        show_progress_bars: Whether to show progress bars.\n    \"\"\"\n    # obtain the shape of the prior samples\n    if isinstance(density_estimator, str):\n        self._build_neural_net = flowmatching_nn(model=density_estimator)\n    else:\n        self._build_neural_net = density_estimator\n\n    super().__init__(\n        prior=prior,\n        device=device,\n        logging_level=logging_level,\n        summary_writer=summary_writer,\n        show_progress_bars=show_progress_bars,\n    )\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.fmpe.fmpe.FMPE.build_posterior","title":"<code>build_posterior(density_estimator=None, prior=None, sample_with='direct', direct_sampling_parameters=None, **kwargs)</code>","text":"<p>Build the posterior distribution.</p> <p>Parameters:</p> Name Type Description Default <code>density_estimator</code> <code>Optional[ConditionalDensityEstimator]</code> <p>Density estimator for the posterior.</p> <code>None</code> <code>prior</code> <code>Optional[Distribution]</code> <p>Prior distribution.</p> <code>None</code> <code>sample_with</code> <code>str</code> <p>Sampling method, currently only \u201cdirect\u201d is supported.</p> <code>'direct'</code> <code>direct_sampling_parameters</code> <code>Optional[Dict[str, Any]]</code> <p>kwargs for DirectPosterior.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DirectPosterior</code> <code>DirectPosterior</code> <p>Posterior distribution.</p> Source code in <code>sbi/inference/trainers/fmpe/fmpe.py</code> <pre><code>def build_posterior(\n    self,\n    density_estimator: Optional[ConditionalDensityEstimator] = None,\n    prior: Optional[Distribution] = None,\n    sample_with: str = \"direct\",\n    direct_sampling_parameters: Optional[Dict[str, Any]] = None,\n    **kwargs,\n) -&gt; DirectPosterior:\n    \"\"\"Build the posterior distribution.\n\n    Args:\n        density_estimator: Density estimator for the posterior.\n        prior: Prior distribution.\n        sample_with: Sampling method, currently only \"direct\" is supported.\n        direct_sampling_parameters: kwargs for DirectPosterior.\n\n    Returns:\n        DirectPosterior: Posterior distribution.\n    \"\"\"\n    if sample_with != \"direct\":\n        raise NotImplementedError(\n            \"Currently, only direct sampling is supported for FMPE.\"\n        )\n\n    if prior is None:\n        assert self._prior is not None, (\n            \"You did not pass a prior. You have to pass the prior either at \"\n            \"initialization `inference = SNPE(prior)` or to \"\n            \"`.build_posterior(prior=prior)`.\"\n        )\n        prior = self._prior\n    else:\n        utils.check_prior(prior)\n\n    if density_estimator is None:\n        posterior_estimator = self._neural_net\n        # If internal net is used device is defined.\n        device = self._device\n    else:\n        posterior_estimator = density_estimator\n        # Otherwise, infer it from the device of the net parameters.\n        device = next(density_estimator.parameters()).device.type\n\n    self._posterior = DirectPosterior(\n        posterior_estimator=posterior_estimator,  # type: ignore\n        prior=prior,\n        device=device,\n        **direct_sampling_parameters or {},\n    )\n\n    return deepcopy(self._posterior)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.fmpe.fmpe.FMPE.train","title":"<code>train(training_batch_size=200, learning_rate=0.0005, validation_fraction=0.1, stop_after_epochs=20, max_num_epochs=2 ** 31 - 1, clip_max_norm=5.0, resume_training=False, force_first_round_loss=False, show_train_summary=False, dataloader_kwargs=None)</code>","text":"<p>Train the flow matching estimator.</p> <p>Parameters:</p> Name Type Description Default <code>training_batch_size</code> <code>int</code> <p>Batch size for training. Defaults to 50.</p> <code>200</code> <code>learning_rate</code> <code>float</code> <p>Learning rate for training. Defaults to 5e-4.</p> <code>0.0005</code> <code>validation_fraction</code> <code>float</code> <p>Fraction of the data to use for validation.</p> <code>0.1</code> <code>stop_after_epochs</code> <code>int</code> <p>Number of epochs to train for. Defaults to 20.</p> <code>20</code> <code>max_num_epochs</code> <code>int</code> <p>Maximum number of epochs to train for.</p> <code>2 ** 31 - 1</code> <code>clip_max_norm</code> <code>Optional[float]</code> <p>Maximum norm for gradient clipping. Defaults to 5.0.</p> <code>5.0</code> <code>resume_training</code> <code>bool</code> <p>Can be used in case training time is limited, e.g. on a cluster. If <code>True</code>, the split between train and validation set, the optimizer, the number of epochs, and the best validation log-prob will be restored from the last time <code>.train()</code> was called.</p> <code>False</code> <code>force_first_round_loss</code> <code>bool</code> <p>Whether to allow training with simulations that have not been sampled from the prior, e.g., in a sequential inference setting. Note that can lead to biased inference results.</p> <code>False</code> <code>show_train_summary</code> <code>bool</code> <p>Whether to show the training summary. Defaults to False.</p> <code>False</code> <code>dataloader_kwargs</code> <code>Optional[dict]</code> <p>Additional keyword arguments for the dataloader.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DensityEstimator</code> <code>ConditionalDensityEstimator</code> <p>Trained flow matching estimator.</p> Source code in <code>sbi/inference/trainers/fmpe/fmpe.py</code> <pre><code>def train(\n    self,\n    training_batch_size: int = 200,\n    learning_rate: float = 5e-4,\n    validation_fraction: float = 0.1,\n    stop_after_epochs: int = 20,\n    max_num_epochs: int = 2**31 - 1,\n    clip_max_norm: Optional[float] = 5.0,\n    resume_training: bool = False,\n    force_first_round_loss: bool = False,\n    show_train_summary: bool = False,\n    dataloader_kwargs: Optional[dict] = None,\n) -&gt; ConditionalDensityEstimator:\n    \"\"\"Train the flow matching estimator.\n\n    Args:\n        training_batch_size: Batch size for training. Defaults to 50.\n        learning_rate: Learning rate for training. Defaults to 5e-4.\n        validation_fraction: Fraction of the data to use for validation.\n        stop_after_epochs: Number of epochs to train for. Defaults to 20.\n        max_num_epochs: Maximum number of epochs to train for.\n        clip_max_norm: Maximum norm for gradient clipping. Defaults to 5.0.\n        resume_training: Can be used in case training time is limited, e.g. on a\n            cluster. If `True`, the split between train and validation set, the\n            optimizer, the number of epochs, and the best validation log-prob will\n            be restored from the last time `.train()` was called.\n        force_first_round_loss: Whether to allow training with\n            simulations that have not been sampled from the prior, e.g., in a\n            sequential inference setting. Note that can lead to biased inference\n            results.\n        show_train_summary: Whether to show the training summary. Defaults to False.\n        dataloader_kwargs: Additional keyword arguments for the dataloader.\n\n    Returns:\n        DensityEstimator: Trained flow matching estimator.\n    \"\"\"\n\n    # Load data from most recent round.\n    self._round = max(self._data_round_index)\n\n    if self._round == 0 and self._neural_net is not None:\n        assert force_first_round_loss or resume_training, (\n            \"You have already trained this neural network. After you had trained \"\n            \"the network, you again appended simulations with `append_simulations\"\n            \"(theta, x)`, but you did not provide a proposal. If the new \"\n            \"simulations are sampled from the prior, you can set \"\n            \"`.train(..., force_first_round_loss=True`). However, if the new \"\n            \"simulations were not sampled from the prior, you should pass the \"\n            \"proposal, i.e. `append_simulations(theta, x, proposal)`. If \"\n            \"your samples are not sampled from the prior and you do not pass a \"\n            \"proposal and you set `force_first_round_loss=True`, the result of \"\n            \"FMPE will not be the true posterior. Instead, it will be the proposal \"\n            \"posterior, which (usually) is more narrow than the true posterior.\"\n        )\n\n    start_idx = 0  # as there is no multi-round FMPE yet\n\n    train_loader, val_loader = self.get_dataloaders(\n        start_idx,\n        training_batch_size,\n        validation_fraction,\n        resume_training=resume_training,\n        dataloader_kwargs=dataloader_kwargs,\n    )\n\n    if self._neural_net is None:\n        # Get theta, x to initialize NN\n        theta, x, _ = self.get_simulations(starting_round=start_idx)\n\n        # Use only training data for building the neural net (z-scoring transforms)\n        self._neural_net = self._build_neural_net(\n            theta[self.train_indices].to(\"cpu\"),\n            x[self.train_indices].to(\"cpu\"),\n        )\n\n        del theta, x\n\n    # Move entire net to device for training.\n    self._neural_net.to(self._device)\n\n    # initialize optimizer and training parameters\n    if not resume_training:\n        self.optimizer = Adam(\n            list(self._neural_net.net.parameters()), lr=learning_rate\n        )\n        self.epoch = 0\n        # NOTE: in the FMPE context we use MSE loss, not log probs.\n        self._val_loss = float(\"Inf\")\n\n    while self.epoch &lt;= max_num_epochs and not self._converged(\n        self.epoch, stop_after_epochs\n    ):\n        self._neural_net.net.train()\n        train_loss_sum = 0\n        epoch_start_time = time.time()\n        for batch in train_loader:\n            self.optimizer.zero_grad()\n            # get batches on current device.\n            theta_batch, x_batch = (\n                batch[0].to(self._device),\n                batch[1].to(self._device),\n            )\n\n            train_loss = self._neural_net.loss(theta_batch, x_batch).mean()\n            train_loss_sum += train_loss.item()\n\n            train_loss.backward()\n            if clip_max_norm is not None:\n                clip_grad_norm_(\n                    self._neural_net.net.parameters(), max_norm=clip_max_norm\n                )\n            self.optimizer.step()\n\n        self.epoch += 1\n\n        train_loss_average = train_loss_sum / len(train_loader)  # type: ignore\n        self._summary[\"training_loss\"].append(train_loss_average)\n\n        # Calculate validation performance.\n        self._neural_net.eval()\n        val_loss_sum = 0\n\n        with torch.no_grad():\n            for batch in val_loader:\n                theta_batch, x_batch = (\n                    batch[0].to(self._device),\n                    batch[1].to(self._device),\n                )\n                # Aggregate the validation losses.\n                val_losses = self._neural_net.loss(theta_batch, x_batch)\n                val_loss_sum += val_losses.sum().item()\n\n        # Take mean over all validation samples.\n        self._val_loss = val_loss_sum / (\n            len(val_loader) * val_loader.batch_size  # type: ignore\n        )\n        # Log validation loss for every epoch.\n        self._summary[\"validation_loss\"].append(self._val_loss)\n        self._summary[\"epoch_durations_sec\"].append(time.time() - epoch_start_time)\n\n        self._maybe_show_progress(self._show_progress_bars, self.epoch)\n\n    self._report_convergence_at_end(self.epoch, stop_after_epochs, max_num_epochs)\n\n    # Update summary.\n    self._summary[\"epochs_trained\"].append(self.epoch)\n    self._summary[\"best_validation_loss\"].append(self._best_val_loss)\n\n    # Update tensorboard and summary dict.\n    self._summarize(round_=self._round)\n\n    # Update description for progress bar.\n    if show_train_summary:\n        print(self._describe_round(self._round, self._summary))\n\n    # Avoid keeping the gradients in the resulting network, which can\n    # cause memory leakage when benchmarking.\n    self._neural_net.zero_grad(set_to_none=True)\n\n    return deepcopy(self._neural_net)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npse.npse.NPSE","title":"<code>NPSE</code>","text":"<p>               Bases: <code>NeuralInference</code></p> Source code in <code>sbi/inference/trainers/npse/npse.py</code> <pre><code>class NPSE(NeuralInference):\n    def __init__(\n        self,\n        prior: Optional[Distribution] = None,\n        score_estimator: Union[str, Callable] = \"mlp\",\n        sde_type: str = \"ve\",\n        device: str = \"cpu\",\n        logging_level: Union[int, str] = \"WARNING\",\n        summary_writer: Optional[SummaryWriter] = None,\n        show_progress_bars: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Base class for Neural Posterior Score Estimation methods.\n\n        Instead of performing conditonal *density* estimation, NPSE methods perform\n        conditional *score* estimation i.e. they estimate the gradient of the log\n        density using denoising score matching loss.\n\n        NOTE: NPSE does not support multi-round inference with flexible proposals yet.\n        You can try to run multi-round with truncated proposals, but note that this is\n        not tested yet.\n\n        Args:\n            prior: Prior distribution.\n            score_estimator: Neural network architecture for the score estimator. Can be\n                a string (e.g. 'mlp' or 'ada_mlp') or a callable that returns a neural\n                network.\n            sde_type: Type of SDE to use. Must be one of ['vp', 've', 'subvp'].\n            device: Device to run the training on.\n            logging_level: Logging level for the training. Can be an integer or a\n                string.\n            summary_writer: Tensorboard summary writer.\n            show_progress_bars: Whether to show progress bars during training.\n            kwargs: Additional keyword arguments.\n\n        References:\n            - Geffner, Tomas, George Papamakarios, and Andriy Mnih. \"Score modeling for\n              simulation-based inference.\" ICML 2023.\n            - Sharrock, Louis, et al. \"Sequential neural score estimation: Likelihood-\n              free inference with conditional score based diffusion models.\" ICML 2024.\n        \"\"\"\n\n        super().__init__(\n            prior=prior,\n            device=device,\n            logging_level=logging_level,\n            summary_writer=summary_writer,\n            show_progress_bars=show_progress_bars,\n        )\n\n        # As detailed in the docstring, `score_estimator` is either a string or\n        # a callable. The function creating the neural network is attached to\n        # `_build_neural_net`. It will be called in the first round and receive\n        # thetas and xs as inputs, so that they can be used for shape inference and\n        # potentially for z-scoring.\n        check_estimator_arg(score_estimator)\n        if isinstance(score_estimator, str):\n            self._build_neural_net = posterior_score_nn(\n                sde_type=sde_type, score_net_type=score_estimator, **kwargs\n            )\n        else:\n            self._build_neural_net = score_estimator\n\n        self._proposal_roundwise = []\n\n    def append_simulations(\n        self,\n        theta: Tensor,\n        x: Tensor,\n        proposal: Optional[DirectPosterior] = None,\n        exclude_invalid_x: Optional[bool] = None,\n        data_device: Optional[str] = None,\n    ) -&gt; \"NPSE\":\n        r\"\"\"Store parameters and simulation outputs to use them for later training.\n\n        Data are stored as entries in lists for each type of variable (parameter/data).\n\n        Stores $\\theta$, $x$, prior_masks (indicating if simulations are coming from the\n        prior or not) and an index indicating which round the batch of simulations came\n        from.\n\n        Args:\n            theta: Parameter sets.\n            x: Simulation outputs.\n            proposal: The distribution that the parameters $\\theta$ were sampled from.\n                Pass `None` if the parameters were sampled from the prior. If not\n                `None`, it will trigger a different loss-function.\n            exclude_invalid_x: Whether invalid simulations are discarded during\n                training. For single-round SNPE, it is fine to discard invalid\n                simulations, but for multi-round SNPE (atomic), discarding invalid\n                simulations gives systematically wrong results. If `None`, it will\n                be `True` in the first round and `False` in later rounds.\n            data_device: Where to store the data, default is on the same device where\n                the training is happening. If training a large dataset on a GPU with not\n                much VRAM can set to 'cpu' to store data on system memory instead.\n\n        Returns:\n            NeuralInference object (returned so that this function is chainable).\n        \"\"\"\n        assert (\n            proposal is None\n        ), \"Multi-round NPSE is not yet implemented. Please use single-round NPSE.\"\n        current_round = 0\n\n        if exclude_invalid_x is None:\n            exclude_invalid_x = current_round == 0\n\n        if data_device is None:\n            data_device = self._device\n\n        theta, x = validate_theta_and_x(\n            theta, x, data_device=data_device, training_device=self._device\n        )\n\n        is_valid_x, num_nans, num_infs = handle_invalid_x(\n            x, exclude_invalid_x=exclude_invalid_x\n        )\n\n        x = x[is_valid_x]\n        theta = theta[is_valid_x]\n\n        # Check for problematic z-scoring\n        warn_if_zscoring_changes_data(x)\n\n        npe_msg_on_invalid_x(num_nans, num_infs, exclude_invalid_x, \"Single-round NPE\")\n\n        self._data_round_index.append(current_round)\n        prior_masks = mask_sims_from_prior(int(current_round &gt; 0), theta.size(0))\n\n        self._theta_roundwise.append(theta)\n        self._x_roundwise.append(x)\n        self._prior_masks.append(prior_masks)\n\n        self._proposal_roundwise.append(proposal)\n\n        if self._prior is None or isinstance(self._prior, ImproperEmpirical):\n            theta_prior = self.get_simulations()[0].to(self._device)\n            self._prior = ImproperEmpirical(\n                theta_prior, ones(theta_prior.shape[0], device=self._device)\n            )\n\n        return self\n\n    def train(\n        self,\n        training_batch_size: int = 200,\n        learning_rate: float = 5e-4,\n        validation_fraction: float = 0.1,\n        stop_after_epochs: int = 200,\n        max_num_epochs: int = 2**31 - 1,\n        clip_max_norm: Optional[float] = 5.0,\n        calibration_kernel: Optional[Callable] = None,\n        ema_loss_decay: float = 0.1,\n        resume_training: bool = False,\n        force_first_round_loss: bool = False,\n        discard_prior_samples: bool = False,\n        retrain_from_scratch: bool = False,\n        show_train_summary: bool = False,\n        dataloader_kwargs: Optional[dict] = None,\n    ) -&gt; ConditionalScoreEstimator:\n        r\"\"\"Returns a score estimator that approximates the score\n        $\\nabla_\\theta \\log p(\\theta|x)$.\n\n        Args:\n            training_batch_size: Training batch size.\n            learning_rate: Learning rate for Adam optimizer.\n            validation_fraction: The fraction of data to use for validation.\n            stop_after_epochs: The number of epochs to wait for improvement on the\n                validation set before terminating training.\n            max_num_epochs: Maximum number of epochs to run. If reached, we stop\n                training even when the validation loss is still decreasing. Otherwise,\n                we train until validation loss increases (see also `stop_after_epochs`).\n            clip_max_norm: Value at which to clip the total gradient norm in order to\n                prevent exploding gradients. Use None for no clipping.\n            calibration_kernel: A function to calibrate the loss with respect\n                to the simulations `x` (optional). See Lueckmann, Gon\u00e7alves et al.,\n                NeurIPS 2017. If `None`, no calibration is used.\n            resume_training: Can be used in case training time is limited, e.g. on a\n                cluster. If `True`, the split between train and validation set, the\n                optimizer, the number of epochs, and the best validation log-prob will\n                be restored from the last time `.train()` was called.\n            force_first_round_loss: If `True`, train with maximum likelihood,\n                i.e., potentially ignoring the correction for using a proposal\n                distribution different from the prior.\n            discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n                from the prior. Training may be sped up by ignoring such less targeted\n                samples.\n            retrain_from_scratch: Whether to retrain the conditional density\n                estimator for the posterior from scratch each round.\n            show_train_summary: Whether to print the number of epochs and validation\n                loss after the training.\n            dataloader_kwargs: Additional or updated kwargs to be passed to the training\n                and validation dataloaders (like, e.g., a collate_fn)\n\n        Returns:\n            Score estimator that approximates the posterior score.\n        \"\"\"\n        # Load data from most recent round.\n        self._round = max(self._data_round_index)\n\n        if self._round == 0 and self._neural_net is not None:\n            assert force_first_round_loss or resume_training, (\n                \"You have already trained this neural network. After you had trained \"\n                \"the network, you again appended simulations with `append_simulations\"\n                \"(theta, x)`, but you did not provide a proposal. If the new \"\n                \"simulations are sampled from the prior, you can set \"\n                \"`.train(..., force_first_round_loss=True`). However, if the new \"\n                \"simulations were not sampled from the prior, you should pass the \"\n                \"proposal, i.e. `append_simulations(theta, x, proposal)`. If \"\n                \"your samples are not sampled from the prior and you do not pass a \"\n                \"proposal and you set `force_first_round_loss=True`, the result of \"\n                \"NPSE will not be the true posterior. Instead, it will be the proposal \"\n                \"posterior, which (usually) is more narrow than the true posterior.\"\n            )\n\n        # Calibration kernels proposed in Lueckmann, Gon\u00e7alves et al., 2017.\n        if calibration_kernel is None:\n\n            def default_calibration_kernel(x):\n                return ones([len(x)], device=self._device)\n\n            calibration_kernel = default_calibration_kernel\n\n        # Starting index for the training set (1 = discard round-0 samples).\n        start_idx = int(discard_prior_samples and self._round &gt; 0)\n\n        # Set the proposal to the last proposal that was passed by the user. For\n        # atomic SNPE, it does not matter what the proposal is. For non-atomic\n        # SNPE, we only use the latest data that was passed, i.e. the one from the\n        # last proposal.\n        proposal = self._proposal_roundwise[-1]\n\n        train_loader, val_loader = self.get_dataloaders(\n            start_idx,\n            training_batch_size,\n            validation_fraction,\n            resume_training,\n            dataloader_kwargs=dataloader_kwargs,\n        )\n        # First round or if retraining from scratch:\n        # Call the `self._build_neural_net` with the rounds' thetas and xs as\n        # arguments, which will build the neural network.\n        if self._neural_net is None or retrain_from_scratch:\n            # Get theta,x to initialize NN\n            theta, x, _ = self.get_simulations(starting_round=start_idx)\n            # Use only training data for building the neural net (z-scoring transforms)\n\n            self._neural_net = self._build_neural_net(\n                theta[self.train_indices].to(\"cpu\"),\n                x[self.train_indices].to(\"cpu\"),\n            )\n\n            test_posterior_net_for_multi_d_x(\n                self._neural_net,\n                theta.to(\"cpu\"),\n                x.to(\"cpu\"),\n            )\n\n            del theta, x\n\n        # Move entire net to device for training.\n        self._neural_net.to(self._device)\n\n        if not resume_training:\n            self.optimizer = Adam(list(self._neural_net.parameters()), lr=learning_rate)\n\n            self.epoch, self._val_loss = 0, float(\"Inf\")\n\n        while self.epoch &lt;= max_num_epochs and not self._converged(\n            self.epoch, stop_after_epochs\n        ):\n            # Train for a single epoch.\n            self._neural_net.train()\n            train_loss_sum = 0\n            epoch_start_time = time.time()\n            for batch in train_loader:\n                self.optimizer.zero_grad()\n                # Get batches on current device.\n                theta_batch, x_batch, masks_batch = (\n                    batch[0].to(self._device),\n                    batch[1].to(self._device),\n                    batch[2].to(self._device),\n                )\n\n                train_losses = self._loss(\n                    theta_batch,\n                    x_batch,\n                    masks_batch,\n                    proposal,\n                    calibration_kernel,\n                    force_first_round_loss=force_first_round_loss,\n                )\n\n                train_loss = torch.mean(train_losses)\n\n                train_loss_sum += train_losses.sum().item()\n\n                train_loss.backward()\n                if clip_max_norm is not None:\n                    clip_grad_norm_(\n                        self._neural_net.parameters(), max_norm=clip_max_norm\n                    )\n                self.optimizer.step()\n\n            self.epoch += 1\n\n            train_loss_average = train_loss_sum / (\n                len(train_loader) * train_loader.batch_size  # type: ignore\n            )\n\n            # NOTE: Due to the inherently noisy nature we do instead log a exponential\n            # moving average of the training loss.\n            if len(self._summary[\"training_loss\"]) == 0:\n                self._summary[\"training_loss\"].append(train_loss_average)\n            else:\n                previous_loss = self._summary[\"training_loss\"][-1]\n                self._summary[\"training_loss\"].append(\n                    (1.0 - ema_loss_decay) * previous_loss\n                    + ema_loss_decay * train_loss_average\n                )\n\n            # Calculate validation performance.\n            self._neural_net.eval()\n            val_loss_sum = 0\n\n            with torch.no_grad():\n                for batch in val_loader:\n                    theta_batch, x_batch, masks_batch = (\n                        batch[0].to(self._device),\n                        batch[1].to(self._device),\n                        batch[2].to(self._device),\n                    )\n                    # Take negative loss here to get validation log_prob.\n                    val_losses = self._loss(\n                        theta_batch,\n                        x_batch,\n                        masks_batch,\n                        proposal,\n                        calibration_kernel,\n                        force_first_round_loss=force_first_round_loss,\n                    )\n                    val_loss_sum += val_losses.sum().item()\n\n            # Take mean over all validation samples.\n            val_loss = val_loss_sum / (\n                len(val_loader) * val_loader.batch_size  # type: ignore\n            )\n\n            # NOTE: Due to the inherently noisy nature we do instead log a exponential\n            # moving average of the validation loss.\n            if len(self._summary[\"validation_loss\"]) == 0:\n                val_loss_ema = val_loss\n            else:\n                previous_loss = self._summary[\"validation_loss\"][-1]\n                val_loss_ema = (\n                    1 - ema_loss_decay\n                ) * previous_loss + ema_loss_decay * val_loss\n\n            self._val_loss = val_loss_ema\n            self._summary[\"validation_loss\"].append(self._val_loss)\n            self._summary[\"epoch_durations_sec\"].append(time.time() - epoch_start_time)\n\n            self._maybe_show_progress(self._show_progress_bars, self.epoch)\n\n        self._report_convergence_at_end(self.epoch, stop_after_epochs, max_num_epochs)\n\n        # Update summary.\n        self._summary[\"epochs_trained\"].append(self.epoch)\n        self._summary[\"best_validation_loss\"].append(self._val_loss)\n\n        # Update tensorboard and summary dict.\n        self._summarize(round_=self._round)\n\n        # Update description for progress bar.\n        if show_train_summary:\n            print(self._describe_round(self._round, self._summary))\n\n        # Avoid keeping the gradients in the resulting network, which can\n        # cause memory leakage when benchmarking.\n        self._neural_net.zero_grad(set_to_none=True)\n\n        return deepcopy(self._neural_net)\n\n    def build_posterior(\n        self,\n        score_estimator: Optional[ConditionalScoreEstimator] = None,\n        prior: Optional[Distribution] = None,\n        sample_with: str = \"sde\",\n    ) -&gt; ScorePosterior:\n        r\"\"\"Build posterior from the score estimator.\n\n        For NPSE, the posterior distribution that is returned here implements the\n        following functionality over the raw neural density estimator:\n        - correct the calculation of the log probability such that it compensates for\n            the leakage.\n        - reject samples that lie outside of the prior bounds.\n\n        Args:\n            score_estimator: The score estimator that the posterior is based on.\n                If `None`, use the latest neural score estimator that was trained.\n            prior: Prior distribution.\n            sample_with: Method to use for sampling from the posterior. Can be one of\n                'sde' (default) or 'ode'. The 'sde' method uses the score to\n                do a Langevin diffusion step, while the 'ode' method uses the score to\n                define a probabilistic ODE and solves it with a numerical ODE solver.\n\n        Returns:\n            Posterior $p(\\theta|x)$  with `.sample()` and `.log_prob()` methods.\n        \"\"\"\n        if prior is None:\n            assert self._prior is not None, (\n                \"You did not pass a prior. You have to pass the prior either at \"\n                \"initialization `inference = NPSE(prior)` or to \"\n                \"`.build_posterior(prior=prior)`.\"\n            )\n            prior = self._prior\n        else:\n            utils.check_prior(prior)\n\n        if score_estimator is None:\n            score_estimator = self._neural_net\n            # If internal net is used device is defined.\n            device = self._device\n        # Otherwise, infer it from the device of the net parameters.\n        else:\n            # TODO: Add protocol for checking if the score estimator has forward and\n            # loss methods with the correct signature.\n            device = str(next(score_estimator.parameters()).device)\n\n        posterior = ScorePosterior(\n            score_estimator,  # type: ignore\n            prior,\n            device=device,\n            sample_with=sample_with,\n        )\n\n        self._posterior = posterior\n        # Store models at end of each round.\n        self._model_bank.append(deepcopy(self._posterior))\n\n        return deepcopy(self._posterior)\n\n    def _loss_proposal_posterior(\n        self,\n        theta: Tensor,\n        x: Tensor,\n        masks: Tensor,\n        proposal: Optional[Any],\n    ) -&gt; Tensor:\n        raise NotImplementedError(\"Multi-round NPSE is not yet implemented.\")\n\n    def _loss(\n        self,\n        theta: Tensor,\n        x: Tensor,\n        masks: Tensor,\n        proposal: Optional[Any],\n        calibration_kernel: Callable,\n        force_first_round_loss: bool = False,\n    ) -&gt; Tensor:\n        \"\"\"Return loss from score estimator. Currently only single-round NPSE\n         is implemented, i.e., no proposal correction is applied for later rounds.\n\n        The loss is the negative log prob. Irrespective of the round or SNPE method\n        (A, B, or C), it can be weighted with a calibration kernel.\n\n        Returns:\n            Calibration kernel-weighted negative log prob.\n            force_first_round_loss: If `True`, train with maximum likelihood,\n                i.e., potentially ignoring the correction for using a proposal\n                distribution different from the prior.\n        \"\"\"\n        if self._round == 0 or force_first_round_loss:\n            # First round loss.\n            loss = self._neural_net.loss(theta, x)\n        else:\n            raise NotImplementedError(\n                \"Multi-round NPSE with arbitrary proposals is not implemented\"\n            )\n\n        return calibration_kernel(x) * loss\n\n    def _converged(self, epoch: int, stop_after_epochs: int) -&gt; bool:\n        \"\"\"Check if training has converged.\n\n        Unlike the `._converged` method in base.py, this method does not reset to the\n        best model. We noticed that this improves performance. Deleting this method\n        will make C2ST tests fail. This is because the loss is very stochastic, so\n        resetting might reset to an underfitted model. Ideally, we would write a\n        custom `._converged()` method which checks whether the loss is still going\n        down **for all t**.\n\n        Args:\n            epoch: Current epoch.\n            stop_after_epochs: Number of epochs to wait for improvement on the\n                validation set before terminating training.\n\n        Returns:\n            Whether training has converged.\n        \"\"\"\n        converged = False\n\n        # No checkpointing, just check if the validation loss has improved.\n\n        # (Re)-start the epoch count with the first epoch or any improvement.\n        if epoch == 0 or self._val_loss &lt; self._best_val_loss:\n            self._best_val_loss = self._val_loss\n            self._epochs_since_last_improvement = 0\n        else:\n            self._epochs_since_last_improvement += 1\n\n        # If no validation improvement over many epochs, stop training.\n        if self._epochs_since_last_improvement &gt; stop_after_epochs - 1:\n            converged = True\n\n        return converged\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npse.npse.NPSE.__init__","title":"<code>__init__(prior=None, score_estimator='mlp', sde_type='ve', device='cpu', logging_level='WARNING', summary_writer=None, show_progress_bars=True, **kwargs)</code>","text":"<p>Base class for Neural Posterior Score Estimation methods.</p> <p>Instead of performing conditonal density estimation, NPSE methods perform conditional score estimation i.e. they estimate the gradient of the log density using denoising score matching loss.</p> <p>NOTE: NPSE does not support multi-round inference with flexible proposals yet. You can try to run multi-round with truncated proposals, but note that this is not tested yet.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Optional[Distribution]</code> <p>Prior distribution.</p> <code>None</code> <code>score_estimator</code> <code>Union[str, Callable]</code> <p>Neural network architecture for the score estimator. Can be a string (e.g. \u2018mlp\u2019 or \u2018ada_mlp\u2019) or a callable that returns a neural network.</p> <code>'mlp'</code> <code>sde_type</code> <code>str</code> <p>Type of SDE to use. Must be one of [\u2018vp\u2019, \u2018ve\u2019, \u2018subvp\u2019].</p> <code>'ve'</code> <code>device</code> <code>str</code> <p>Device to run the training on.</p> <code>'cpu'</code> <code>logging_level</code> <code>Union[int, str]</code> <p>Logging level for the training. Can be an integer or a string.</p> <code>'WARNING'</code> <code>summary_writer</code> <code>Optional[SummaryWriter]</code> <p>Tensorboard summary writer.</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show progress bars during training.</p> <code>True</code> <code>kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> References <ul> <li>Geffner, Tomas, George Papamakarios, and Andriy Mnih. \u201cScore modeling for   simulation-based inference.\u201d ICML 2023.</li> <li>Sharrock, Louis, et al. \u201cSequential neural score estimation: Likelihood-   free inference with conditional score based diffusion models.\u201d ICML 2024.</li> </ul> Source code in <code>sbi/inference/trainers/npse/npse.py</code> <pre><code>def __init__(\n    self,\n    prior: Optional[Distribution] = None,\n    score_estimator: Union[str, Callable] = \"mlp\",\n    sde_type: str = \"ve\",\n    device: str = \"cpu\",\n    logging_level: Union[int, str] = \"WARNING\",\n    summary_writer: Optional[SummaryWriter] = None,\n    show_progress_bars: bool = True,\n    **kwargs,\n):\n    \"\"\"Base class for Neural Posterior Score Estimation methods.\n\n    Instead of performing conditonal *density* estimation, NPSE methods perform\n    conditional *score* estimation i.e. they estimate the gradient of the log\n    density using denoising score matching loss.\n\n    NOTE: NPSE does not support multi-round inference with flexible proposals yet.\n    You can try to run multi-round with truncated proposals, but note that this is\n    not tested yet.\n\n    Args:\n        prior: Prior distribution.\n        score_estimator: Neural network architecture for the score estimator. Can be\n            a string (e.g. 'mlp' or 'ada_mlp') or a callable that returns a neural\n            network.\n        sde_type: Type of SDE to use. Must be one of ['vp', 've', 'subvp'].\n        device: Device to run the training on.\n        logging_level: Logging level for the training. Can be an integer or a\n            string.\n        summary_writer: Tensorboard summary writer.\n        show_progress_bars: Whether to show progress bars during training.\n        kwargs: Additional keyword arguments.\n\n    References:\n        - Geffner, Tomas, George Papamakarios, and Andriy Mnih. \"Score modeling for\n          simulation-based inference.\" ICML 2023.\n        - Sharrock, Louis, et al. \"Sequential neural score estimation: Likelihood-\n          free inference with conditional score based diffusion models.\" ICML 2024.\n    \"\"\"\n\n    super().__init__(\n        prior=prior,\n        device=device,\n        logging_level=logging_level,\n        summary_writer=summary_writer,\n        show_progress_bars=show_progress_bars,\n    )\n\n    # As detailed in the docstring, `score_estimator` is either a string or\n    # a callable. The function creating the neural network is attached to\n    # `_build_neural_net`. It will be called in the first round and receive\n    # thetas and xs as inputs, so that they can be used for shape inference and\n    # potentially for z-scoring.\n    check_estimator_arg(score_estimator)\n    if isinstance(score_estimator, str):\n        self._build_neural_net = posterior_score_nn(\n            sde_type=sde_type, score_net_type=score_estimator, **kwargs\n        )\n    else:\n        self._build_neural_net = score_estimator\n\n    self._proposal_roundwise = []\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npse.npse.NPSE.append_simulations","title":"<code>append_simulations(theta, x, proposal=None, exclude_invalid_x=None, data_device=None)</code>","text":"<p>Store parameters and simulation outputs to use them for later training.</p> <p>Data are stored as entries in lists for each type of variable (parameter/data).</p> <p>Stores \\(\\theta\\), \\(x\\), prior_masks (indicating if simulations are coming from the prior or not) and an index indicating which round the batch of simulations came from.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Tensor</code> <p>Parameter sets.</p> required <code>x</code> <code>Tensor</code> <p>Simulation outputs.</p> required <code>proposal</code> <code>Optional[DirectPosterior]</code> <p>The distribution that the parameters \\(\\theta\\) were sampled from. Pass <code>None</code> if the parameters were sampled from the prior. If not <code>None</code>, it will trigger a different loss-function.</p> <code>None</code> <code>exclude_invalid_x</code> <code>Optional[bool]</code> <p>Whether invalid simulations are discarded during training. For single-round SNPE, it is fine to discard invalid simulations, but for multi-round SNPE (atomic), discarding invalid simulations gives systematically wrong results. If <code>None</code>, it will be <code>True</code> in the first round and <code>False</code> in later rounds.</p> <code>None</code> <code>data_device</code> <code>Optional[str]</code> <p>Where to store the data, default is on the same device where the training is happening. If training a large dataset on a GPU with not much VRAM can set to \u2018cpu\u2019 to store data on system memory instead.</p> <code>None</code> <p>Returns:</p> Type Description <code>NPSE</code> <p>NeuralInference object (returned so that this function is chainable).</p> Source code in <code>sbi/inference/trainers/npse/npse.py</code> <pre><code>def append_simulations(\n    self,\n    theta: Tensor,\n    x: Tensor,\n    proposal: Optional[DirectPosterior] = None,\n    exclude_invalid_x: Optional[bool] = None,\n    data_device: Optional[str] = None,\n) -&gt; \"NPSE\":\n    r\"\"\"Store parameters and simulation outputs to use them for later training.\n\n    Data are stored as entries in lists for each type of variable (parameter/data).\n\n    Stores $\\theta$, $x$, prior_masks (indicating if simulations are coming from the\n    prior or not) and an index indicating which round the batch of simulations came\n    from.\n\n    Args:\n        theta: Parameter sets.\n        x: Simulation outputs.\n        proposal: The distribution that the parameters $\\theta$ were sampled from.\n            Pass `None` if the parameters were sampled from the prior. If not\n            `None`, it will trigger a different loss-function.\n        exclude_invalid_x: Whether invalid simulations are discarded during\n            training. For single-round SNPE, it is fine to discard invalid\n            simulations, but for multi-round SNPE (atomic), discarding invalid\n            simulations gives systematically wrong results. If `None`, it will\n            be `True` in the first round and `False` in later rounds.\n        data_device: Where to store the data, default is on the same device where\n            the training is happening. If training a large dataset on a GPU with not\n            much VRAM can set to 'cpu' to store data on system memory instead.\n\n    Returns:\n        NeuralInference object (returned so that this function is chainable).\n    \"\"\"\n    assert (\n        proposal is None\n    ), \"Multi-round NPSE is not yet implemented. Please use single-round NPSE.\"\n    current_round = 0\n\n    if exclude_invalid_x is None:\n        exclude_invalid_x = current_round == 0\n\n    if data_device is None:\n        data_device = self._device\n\n    theta, x = validate_theta_and_x(\n        theta, x, data_device=data_device, training_device=self._device\n    )\n\n    is_valid_x, num_nans, num_infs = handle_invalid_x(\n        x, exclude_invalid_x=exclude_invalid_x\n    )\n\n    x = x[is_valid_x]\n    theta = theta[is_valid_x]\n\n    # Check for problematic z-scoring\n    warn_if_zscoring_changes_data(x)\n\n    npe_msg_on_invalid_x(num_nans, num_infs, exclude_invalid_x, \"Single-round NPE\")\n\n    self._data_round_index.append(current_round)\n    prior_masks = mask_sims_from_prior(int(current_round &gt; 0), theta.size(0))\n\n    self._theta_roundwise.append(theta)\n    self._x_roundwise.append(x)\n    self._prior_masks.append(prior_masks)\n\n    self._proposal_roundwise.append(proposal)\n\n    if self._prior is None or isinstance(self._prior, ImproperEmpirical):\n        theta_prior = self.get_simulations()[0].to(self._device)\n        self._prior = ImproperEmpirical(\n            theta_prior, ones(theta_prior.shape[0], device=self._device)\n        )\n\n    return self\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npse.npse.NPSE.build_posterior","title":"<code>build_posterior(score_estimator=None, prior=None, sample_with='sde')</code>","text":"<p>Build posterior from the score estimator.</p> <p>For NPSE, the posterior distribution that is returned here implements the following functionality over the raw neural density estimator: - correct the calculation of the log probability such that it compensates for     the leakage. - reject samples that lie outside of the prior bounds.</p> <p>Parameters:</p> Name Type Description Default <code>score_estimator</code> <code>Optional[ConditionalScoreEstimator]</code> <p>The score estimator that the posterior is based on. If <code>None</code>, use the latest neural score estimator that was trained.</p> <code>None</code> <code>prior</code> <code>Optional[Distribution]</code> <p>Prior distribution.</p> <code>None</code> <code>sample_with</code> <code>str</code> <p>Method to use for sampling from the posterior. Can be one of \u2018sde\u2019 (default) or \u2018ode\u2019. The \u2018sde\u2019 method uses the score to do a Langevin diffusion step, while the \u2018ode\u2019 method uses the score to define a probabilistic ODE and solves it with a numerical ODE solver.</p> <code>'sde'</code> <p>Returns:</p> Type Description <code>ScorePosterior</code> <p>Posterior \\(p(\\theta|x)\\)  with <code>.sample()</code> and <code>.log_prob()</code> methods.</p> Source code in <code>sbi/inference/trainers/npse/npse.py</code> <pre><code>def build_posterior(\n    self,\n    score_estimator: Optional[ConditionalScoreEstimator] = None,\n    prior: Optional[Distribution] = None,\n    sample_with: str = \"sde\",\n) -&gt; ScorePosterior:\n    r\"\"\"Build posterior from the score estimator.\n\n    For NPSE, the posterior distribution that is returned here implements the\n    following functionality over the raw neural density estimator:\n    - correct the calculation of the log probability such that it compensates for\n        the leakage.\n    - reject samples that lie outside of the prior bounds.\n\n    Args:\n        score_estimator: The score estimator that the posterior is based on.\n            If `None`, use the latest neural score estimator that was trained.\n        prior: Prior distribution.\n        sample_with: Method to use for sampling from the posterior. Can be one of\n            'sde' (default) or 'ode'. The 'sde' method uses the score to\n            do a Langevin diffusion step, while the 'ode' method uses the score to\n            define a probabilistic ODE and solves it with a numerical ODE solver.\n\n    Returns:\n        Posterior $p(\\theta|x)$  with `.sample()` and `.log_prob()` methods.\n    \"\"\"\n    if prior is None:\n        assert self._prior is not None, (\n            \"You did not pass a prior. You have to pass the prior either at \"\n            \"initialization `inference = NPSE(prior)` or to \"\n            \"`.build_posterior(prior=prior)`.\"\n        )\n        prior = self._prior\n    else:\n        utils.check_prior(prior)\n\n    if score_estimator is None:\n        score_estimator = self._neural_net\n        # If internal net is used device is defined.\n        device = self._device\n    # Otherwise, infer it from the device of the net parameters.\n    else:\n        # TODO: Add protocol for checking if the score estimator has forward and\n        # loss methods with the correct signature.\n        device = str(next(score_estimator.parameters()).device)\n\n    posterior = ScorePosterior(\n        score_estimator,  # type: ignore\n        prior,\n        device=device,\n        sample_with=sample_with,\n    )\n\n    self._posterior = posterior\n    # Store models at end of each round.\n    self._model_bank.append(deepcopy(self._posterior))\n\n    return deepcopy(self._posterior)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.npse.npse.NPSE.train","title":"<code>train(training_batch_size=200, learning_rate=0.0005, validation_fraction=0.1, stop_after_epochs=200, max_num_epochs=2 ** 31 - 1, clip_max_norm=5.0, calibration_kernel=None, ema_loss_decay=0.1, resume_training=False, force_first_round_loss=False, discard_prior_samples=False, retrain_from_scratch=False, show_train_summary=False, dataloader_kwargs=None)</code>","text":"<p>Returns a score estimator that approximates the score \\(\\nabla_\\theta \\log p(\\theta|x)\\).</p> <p>Parameters:</p> Name Type Description Default <code>training_batch_size</code> <code>int</code> <p>Training batch size.</p> <code>200</code> <code>learning_rate</code> <code>float</code> <p>Learning rate for Adam optimizer.</p> <code>0.0005</code> <code>validation_fraction</code> <code>float</code> <p>The fraction of data to use for validation.</p> <code>0.1</code> <code>stop_after_epochs</code> <code>int</code> <p>The number of epochs to wait for improvement on the validation set before terminating training.</p> <code>200</code> <code>max_num_epochs</code> <code>int</code> <p>Maximum number of epochs to run. If reached, we stop training even when the validation loss is still decreasing. Otherwise, we train until validation loss increases (see also <code>stop_after_epochs</code>).</p> <code>2 ** 31 - 1</code> <code>clip_max_norm</code> <code>Optional[float]</code> <p>Value at which to clip the total gradient norm in order to prevent exploding gradients. Use None for no clipping.</p> <code>5.0</code> <code>calibration_kernel</code> <code>Optional[Callable]</code> <p>A function to calibrate the loss with respect to the simulations <code>x</code> (optional). See Lueckmann, Gon\u00e7alves et al., NeurIPS 2017. If <code>None</code>, no calibration is used.</p> <code>None</code> <code>resume_training</code> <code>bool</code> <p>Can be used in case training time is limited, e.g. on a cluster. If <code>True</code>, the split between train and validation set, the optimizer, the number of epochs, and the best validation log-prob will be restored from the last time <code>.train()</code> was called.</p> <code>False</code> <code>force_first_round_loss</code> <code>bool</code> <p>If <code>True</code>, train with maximum likelihood, i.e., potentially ignoring the correction for using a proposal distribution different from the prior.</p> <code>False</code> <code>discard_prior_samples</code> <code>bool</code> <p>Whether to discard samples simulated in round 1, i.e. from the prior. Training may be sped up by ignoring such less targeted samples.</p> <code>False</code> <code>retrain_from_scratch</code> <code>bool</code> <p>Whether to retrain the conditional density estimator for the posterior from scratch each round.</p> <code>False</code> <code>show_train_summary</code> <code>bool</code> <p>Whether to print the number of epochs and validation loss after the training.</p> <code>False</code> <code>dataloader_kwargs</code> <code>Optional[dict]</code> <p>Additional or updated kwargs to be passed to the training and validation dataloaders (like, e.g., a collate_fn)</p> <code>None</code> <p>Returns:</p> Type Description <code>ConditionalScoreEstimator</code> <p>Score estimator that approximates the posterior score.</p> Source code in <code>sbi/inference/trainers/npse/npse.py</code> <pre><code>def train(\n    self,\n    training_batch_size: int = 200,\n    learning_rate: float = 5e-4,\n    validation_fraction: float = 0.1,\n    stop_after_epochs: int = 200,\n    max_num_epochs: int = 2**31 - 1,\n    clip_max_norm: Optional[float] = 5.0,\n    calibration_kernel: Optional[Callable] = None,\n    ema_loss_decay: float = 0.1,\n    resume_training: bool = False,\n    force_first_round_loss: bool = False,\n    discard_prior_samples: bool = False,\n    retrain_from_scratch: bool = False,\n    show_train_summary: bool = False,\n    dataloader_kwargs: Optional[dict] = None,\n) -&gt; ConditionalScoreEstimator:\n    r\"\"\"Returns a score estimator that approximates the score\n    $\\nabla_\\theta \\log p(\\theta|x)$.\n\n    Args:\n        training_batch_size: Training batch size.\n        learning_rate: Learning rate for Adam optimizer.\n        validation_fraction: The fraction of data to use for validation.\n        stop_after_epochs: The number of epochs to wait for improvement on the\n            validation set before terminating training.\n        max_num_epochs: Maximum number of epochs to run. If reached, we stop\n            training even when the validation loss is still decreasing. Otherwise,\n            we train until validation loss increases (see also `stop_after_epochs`).\n        clip_max_norm: Value at which to clip the total gradient norm in order to\n            prevent exploding gradients. Use None for no clipping.\n        calibration_kernel: A function to calibrate the loss with respect\n            to the simulations `x` (optional). See Lueckmann, Gon\u00e7alves et al.,\n            NeurIPS 2017. If `None`, no calibration is used.\n        resume_training: Can be used in case training time is limited, e.g. on a\n            cluster. If `True`, the split between train and validation set, the\n            optimizer, the number of epochs, and the best validation log-prob will\n            be restored from the last time `.train()` was called.\n        force_first_round_loss: If `True`, train with maximum likelihood,\n            i.e., potentially ignoring the correction for using a proposal\n            distribution different from the prior.\n        discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n            from the prior. Training may be sped up by ignoring such less targeted\n            samples.\n        retrain_from_scratch: Whether to retrain the conditional density\n            estimator for the posterior from scratch each round.\n        show_train_summary: Whether to print the number of epochs and validation\n            loss after the training.\n        dataloader_kwargs: Additional or updated kwargs to be passed to the training\n            and validation dataloaders (like, e.g., a collate_fn)\n\n    Returns:\n        Score estimator that approximates the posterior score.\n    \"\"\"\n    # Load data from most recent round.\n    self._round = max(self._data_round_index)\n\n    if self._round == 0 and self._neural_net is not None:\n        assert force_first_round_loss or resume_training, (\n            \"You have already trained this neural network. After you had trained \"\n            \"the network, you again appended simulations with `append_simulations\"\n            \"(theta, x)`, but you did not provide a proposal. If the new \"\n            \"simulations are sampled from the prior, you can set \"\n            \"`.train(..., force_first_round_loss=True`). However, if the new \"\n            \"simulations were not sampled from the prior, you should pass the \"\n            \"proposal, i.e. `append_simulations(theta, x, proposal)`. If \"\n            \"your samples are not sampled from the prior and you do not pass a \"\n            \"proposal and you set `force_first_round_loss=True`, the result of \"\n            \"NPSE will not be the true posterior. Instead, it will be the proposal \"\n            \"posterior, which (usually) is more narrow than the true posterior.\"\n        )\n\n    # Calibration kernels proposed in Lueckmann, Gon\u00e7alves et al., 2017.\n    if calibration_kernel is None:\n\n        def default_calibration_kernel(x):\n            return ones([len(x)], device=self._device)\n\n        calibration_kernel = default_calibration_kernel\n\n    # Starting index for the training set (1 = discard round-0 samples).\n    start_idx = int(discard_prior_samples and self._round &gt; 0)\n\n    # Set the proposal to the last proposal that was passed by the user. For\n    # atomic SNPE, it does not matter what the proposal is. For non-atomic\n    # SNPE, we only use the latest data that was passed, i.e. the one from the\n    # last proposal.\n    proposal = self._proposal_roundwise[-1]\n\n    train_loader, val_loader = self.get_dataloaders(\n        start_idx,\n        training_batch_size,\n        validation_fraction,\n        resume_training,\n        dataloader_kwargs=dataloader_kwargs,\n    )\n    # First round or if retraining from scratch:\n    # Call the `self._build_neural_net` with the rounds' thetas and xs as\n    # arguments, which will build the neural network.\n    if self._neural_net is None or retrain_from_scratch:\n        # Get theta,x to initialize NN\n        theta, x, _ = self.get_simulations(starting_round=start_idx)\n        # Use only training data for building the neural net (z-scoring transforms)\n\n        self._neural_net = self._build_neural_net(\n            theta[self.train_indices].to(\"cpu\"),\n            x[self.train_indices].to(\"cpu\"),\n        )\n\n        test_posterior_net_for_multi_d_x(\n            self._neural_net,\n            theta.to(\"cpu\"),\n            x.to(\"cpu\"),\n        )\n\n        del theta, x\n\n    # Move entire net to device for training.\n    self._neural_net.to(self._device)\n\n    if not resume_training:\n        self.optimizer = Adam(list(self._neural_net.parameters()), lr=learning_rate)\n\n        self.epoch, self._val_loss = 0, float(\"Inf\")\n\n    while self.epoch &lt;= max_num_epochs and not self._converged(\n        self.epoch, stop_after_epochs\n    ):\n        # Train for a single epoch.\n        self._neural_net.train()\n        train_loss_sum = 0\n        epoch_start_time = time.time()\n        for batch in train_loader:\n            self.optimizer.zero_grad()\n            # Get batches on current device.\n            theta_batch, x_batch, masks_batch = (\n                batch[0].to(self._device),\n                batch[1].to(self._device),\n                batch[2].to(self._device),\n            )\n\n            train_losses = self._loss(\n                theta_batch,\n                x_batch,\n                masks_batch,\n                proposal,\n                calibration_kernel,\n                force_first_round_loss=force_first_round_loss,\n            )\n\n            train_loss = torch.mean(train_losses)\n\n            train_loss_sum += train_losses.sum().item()\n\n            train_loss.backward()\n            if clip_max_norm is not None:\n                clip_grad_norm_(\n                    self._neural_net.parameters(), max_norm=clip_max_norm\n                )\n            self.optimizer.step()\n\n        self.epoch += 1\n\n        train_loss_average = train_loss_sum / (\n            len(train_loader) * train_loader.batch_size  # type: ignore\n        )\n\n        # NOTE: Due to the inherently noisy nature we do instead log a exponential\n        # moving average of the training loss.\n        if len(self._summary[\"training_loss\"]) == 0:\n            self._summary[\"training_loss\"].append(train_loss_average)\n        else:\n            previous_loss = self._summary[\"training_loss\"][-1]\n            self._summary[\"training_loss\"].append(\n                (1.0 - ema_loss_decay) * previous_loss\n                + ema_loss_decay * train_loss_average\n            )\n\n        # Calculate validation performance.\n        self._neural_net.eval()\n        val_loss_sum = 0\n\n        with torch.no_grad():\n            for batch in val_loader:\n                theta_batch, x_batch, masks_batch = (\n                    batch[0].to(self._device),\n                    batch[1].to(self._device),\n                    batch[2].to(self._device),\n                )\n                # Take negative loss here to get validation log_prob.\n                val_losses = self._loss(\n                    theta_batch,\n                    x_batch,\n                    masks_batch,\n                    proposal,\n                    calibration_kernel,\n                    force_first_round_loss=force_first_round_loss,\n                )\n                val_loss_sum += val_losses.sum().item()\n\n        # Take mean over all validation samples.\n        val_loss = val_loss_sum / (\n            len(val_loader) * val_loader.batch_size  # type: ignore\n        )\n\n        # NOTE: Due to the inherently noisy nature we do instead log a exponential\n        # moving average of the validation loss.\n        if len(self._summary[\"validation_loss\"]) == 0:\n            val_loss_ema = val_loss\n        else:\n            previous_loss = self._summary[\"validation_loss\"][-1]\n            val_loss_ema = (\n                1 - ema_loss_decay\n            ) * previous_loss + ema_loss_decay * val_loss\n\n        self._val_loss = val_loss_ema\n        self._summary[\"validation_loss\"].append(self._val_loss)\n        self._summary[\"epoch_durations_sec\"].append(time.time() - epoch_start_time)\n\n        self._maybe_show_progress(self._show_progress_bars, self.epoch)\n\n    self._report_convergence_at_end(self.epoch, stop_after_epochs, max_num_epochs)\n\n    # Update summary.\n    self._summary[\"epochs_trained\"].append(self.epoch)\n    self._summary[\"best_validation_loss\"].append(self._val_loss)\n\n    # Update tensorboard and summary dict.\n    self._summarize(round_=self._round)\n\n    # Update description for progress bar.\n    if show_train_summary:\n        print(self._describe_round(self._round, self._summary))\n\n    # Avoid keeping the gradients in the resulting network, which can\n    # cause memory leakage when benchmarking.\n    self._neural_net.zero_grad(set_to_none=True)\n\n    return deepcopy(self._neural_net)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nle.nle_a.NLE_A","title":"<code>NLE_A</code>","text":"<p>               Bases: <code>LikelihoodEstimator</code></p> Source code in <code>sbi/inference/trainers/nle/nle_a.py</code> <pre><code>class NLE_A(LikelihoodEstimator):\n    def __init__(\n        self,\n        prior: Optional[Distribution] = None,\n        density_estimator: Union[str, Callable] = \"maf\",\n        device: str = \"cpu\",\n        logging_level: Union[int, str] = \"WARNING\",\n        summary_writer: Optional[TensorboardSummaryWriter] = None,\n        show_progress_bars: bool = True,\n    ):\n        r\"\"\"Neural Likelihood Estimation [1].\n\n        [1] Sequential Neural Likelihood: Fast Likelihood-free Inference with\n        Autoregressive Flows_, Papamakarios et al., AISTATS 2019,\n        https://arxiv.org/abs/1805.07226\n\n        Args:\n            prior: A probability distribution that expresses prior knowledge about the\n                parameters, e.g. which ranges are meaningful for them. If `None`, the\n                prior must be passed to `.build_posterior()`.\n            density_estimator: If it is a string, use a pre-configured network of the\n                provided type (one of nsf, maf, mdn, made). Alternatively, a function\n                that builds a custom neural network can be provided. The function will\n                be called with the first batch of simulations (theta, x), which can\n                thus be used for shape inference and potentially for z-scoring. It\n                needs to return a PyTorch `nn.Module` implementing the density\n                estimator. The density estimator needs to provide the methods\n                `.log_prob` and `.sample()`.\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n            logging_level: Minimum severity of messages to log. One of the strings\n                INFO, WARNING, DEBUG, ERROR and CRITICAL.\n            summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n                file location (default is `&lt;current working directory&gt;/logs`.)\n            show_progress_bars: Whether to show a progressbar during simulation and\n                sampling.\n        \"\"\"\n\n        kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nle.nle_a.NLE_A.__init__","title":"<code>__init__(prior=None, density_estimator='maf', device='cpu', logging_level='WARNING', summary_writer=None, show_progress_bars=True)</code>","text":"<p>Neural Likelihood Estimation [1].</p> <p>[1] Sequential Neural Likelihood: Fast Likelihood-free Inference with Autoregressive Flows_, Papamakarios et al., AISTATS 2019, https://arxiv.org/abs/1805.07226</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Optional[Distribution]</code> <p>A probability distribution that expresses prior knowledge about the parameters, e.g. which ranges are meaningful for them. If <code>None</code>, the prior must be passed to <code>.build_posterior()</code>.</p> <code>None</code> <code>density_estimator</code> <code>Union[str, Callable]</code> <p>If it is a string, use a pre-configured network of the provided type (one of nsf, maf, mdn, made). Alternatively, a function that builds a custom neural network can be provided. The function will be called with the first batch of simulations (theta, x), which can thus be used for shape inference and potentially for z-scoring. It needs to return a PyTorch <code>nn.Module</code> implementing the density estimator. The density estimator needs to provide the methods <code>.log_prob</code> and <code>.sample()</code>.</p> <code>'maf'</code> <code>device</code> <code>str</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:{0, 1, \u2026}\u201d.</p> <code>'cpu'</code> <code>logging_level</code> <code>Union[int, str]</code> <p>Minimum severity of messages to log. One of the strings INFO, WARNING, DEBUG, ERROR and CRITICAL.</p> <code>'WARNING'</code> <code>summary_writer</code> <code>Optional[TensorboardSummaryWriter]</code> <p>A tensorboard <code>SummaryWriter</code> to control, among others, log file location (default is <code>&lt;current working directory&gt;/logs</code>.)</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during simulation and sampling.</p> <code>True</code> Source code in <code>sbi/inference/trainers/nle/nle_a.py</code> <pre><code>def __init__(\n    self,\n    prior: Optional[Distribution] = None,\n    density_estimator: Union[str, Callable] = \"maf\",\n    device: str = \"cpu\",\n    logging_level: Union[int, str] = \"WARNING\",\n    summary_writer: Optional[TensorboardSummaryWriter] = None,\n    show_progress_bars: bool = True,\n):\n    r\"\"\"Neural Likelihood Estimation [1].\n\n    [1] Sequential Neural Likelihood: Fast Likelihood-free Inference with\n    Autoregressive Flows_, Papamakarios et al., AISTATS 2019,\n    https://arxiv.org/abs/1805.07226\n\n    Args:\n        prior: A probability distribution that expresses prior knowledge about the\n            parameters, e.g. which ranges are meaningful for them. If `None`, the\n            prior must be passed to `.build_posterior()`.\n        density_estimator: If it is a string, use a pre-configured network of the\n            provided type (one of nsf, maf, mdn, made). Alternatively, a function\n            that builds a custom neural network can be provided. The function will\n            be called with the first batch of simulations (theta, x), which can\n            thus be used for shape inference and potentially for z-scoring. It\n            needs to return a PyTorch `nn.Module` implementing the density\n            estimator. The density estimator needs to provide the methods\n            `.log_prob` and `.sample()`.\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n        logging_level: Minimum severity of messages to log. One of the strings\n            INFO, WARNING, DEBUG, ERROR and CRITICAL.\n        summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n            file location (default is `&lt;current working directory&gt;/logs`.)\n        show_progress_bars: Whether to show a progressbar during simulation and\n            sampling.\n    \"\"\"\n\n    kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.nre_a.NRE_A","title":"<code>NRE_A</code>","text":"<p>               Bases: <code>RatioEstimator</code></p> Source code in <code>sbi/inference/trainers/nre/nre_a.py</code> <pre><code>class NRE_A(RatioEstimator):\n    def __init__(\n        self,\n        prior: Optional[Distribution] = None,\n        classifier: Union[str, Callable] = \"resnet\",\n        device: str = \"cpu\",\n        logging_level: Union[int, str] = \"warning\",\n        summary_writer: Optional[TensorboardSummaryWriter] = None,\n        show_progress_bars: bool = True,\n    ):\n        r\"\"\"AALR[1], here known as NRE_A.\n\n        [1] _Likelihood-free MCMC with Amortized Approximate Likelihood Ratios_, Hermans\n            et al., ICML 2020, https://arxiv.org/abs/1903.04057\n\n        Args:\n            prior: A probability distribution that expresses prior knowledge about the\n                parameters, e.g. which ranges are meaningful for them. If `None`, the\n                prior must be passed to `.build_posterior()`.\n            classifier: Classifier trained to approximate likelihood ratios. If it is\n                a string, use a pre-configured network of the provided type (one of\n                linear, mlp, resnet). Alternatively, a function that builds a custom\n                neural network can be provided. The function will be called with the\n                first batch of simulations (theta, x), which can thus be used for shape\n                inference and potentially for z-scoring. It needs to return a PyTorch\n                `nn.Module` implementing the classifier.\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n            logging_level: Minimum severity of messages to log. One of the strings\n                INFO, WARNING, DEBUG, ERROR and CRITICAL.\n            summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n                file location (default is `&lt;current working directory&gt;/logs`.)\n            show_progress_bars: Whether to show a progressbar during simulation and\n                sampling.\n        \"\"\"\n\n        kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n        super().__init__(**kwargs)\n\n    def train(\n        self,\n        training_batch_size: int = 200,\n        learning_rate: float = 5e-4,\n        validation_fraction: float = 0.1,\n        stop_after_epochs: int = 20,\n        max_num_epochs: int = 2**31 - 1,\n        clip_max_norm: Optional[float] = 5.0,\n        resume_training: bool = False,\n        discard_prior_samples: bool = False,\n        retrain_from_scratch: bool = False,\n        show_train_summary: bool = False,\n        dataloader_kwargs: Optional[Dict] = None,\n        loss_kwargs: Optional[Dict[str, Any]] = None,\n    ) -&gt; nn.Module:\n        r\"\"\"Return classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n\n        Args:\n            training_batch_size: Training batch size.\n            learning_rate: Learning rate for Adam optimizer.\n            validation_fraction: The fraction of data to use for validation.\n            stop_after_epochs: The number of epochs to wait for improvement on the\n                validation set before terminating training.\n            max_num_epochs: Maximum number of epochs to run. If reached, we stop\n                training even when the validation loss is still decreasing. Otherwise,\n                we train until validation loss increases (see also `stop_after_epochs`).\n            clip_max_norm: Value at which to clip the total gradient norm in order to\n                prevent exploding gradients. Use None for no clipping.\n            resume_training: Can be used in case training time is limited, e.g. on a\n                cluster. If `True`, the split between train and validation set, the\n                optimizer, the number of epochs, and the best validation log-prob will\n                be restored from the last time `.train()` was called.\n            discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n                from the prior. Training may be sped up by ignoring such less targeted\n                samples.\n            retrain_from_scratch: Whether to retrain the conditional density\n                estimator for the posterior from scratch each round.\n            show_train_summary: Whether to print the number of epochs and validation\n                loss and leakage after the training.\n            dataloader_kwargs: Additional or updated kwargs to be passed to the training\n                and validation dataloaders (like, e.g., a collate_fn)\n            loss_kwargs: Additional or updated kwargs to be passed to the self._loss fn.\n\n        Returns:\n            Classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n        \"\"\"\n\n        # AALR is defined for `num_atoms=2`.\n        # Proxy to `super().__call__` to ensure right parameter.\n        kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n        return super().train(**kwargs, num_atoms=2)\n\n    def _loss(self, theta: Tensor, x: Tensor, num_atoms: int) -&gt; Tensor:\n        \"\"\"Returns the binary cross-entropy loss for the trained classifier.\n\n        The classifier takes as input a $(\\theta,x)$ pair. It is trained to predict 1\n        if the pair was sampled from the joint $p(\\theta,x)$, and to predict 0 if the\n        pair was sampled from the marginals $p(\\theta)p(x)$.\n        \"\"\"\n\n        assert theta.shape[0] == x.shape[0], \"Batch sizes for theta and x must match.\"\n        batch_size = theta.shape[0]\n\n        logits = self._classifier_logits(theta, x, num_atoms)\n        likelihood = torch.sigmoid(logits).squeeze()\n\n        # Alternating pairs where there is one sampled from the joint and one\n        # sampled from the marginals. The first element is sampled from the\n        # joint p(theta, x) and is labelled 1. The second element is sampled\n        # from the marginals p(theta)p(x) and is labelled 0. And so on.\n        labels = ones(2 * batch_size, device=self._device)  # two atoms\n        labels[1::2] = 0.0\n\n        # Binary cross entropy to learn the likelihood (AALR-specific)\n        return nn.BCELoss()(likelihood, labels)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.nre_a.NRE_A.__init__","title":"<code>__init__(prior=None, classifier='resnet', device='cpu', logging_level='warning', summary_writer=None, show_progress_bars=True)</code>","text":"<p>AALR[1], here known as NRE_A.</p> <p>[1] Likelihood-free MCMC with Amortized Approximate Likelihood Ratios, Hermans     et al., ICML 2020, https://arxiv.org/abs/1903.04057</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Optional[Distribution]</code> <p>A probability distribution that expresses prior knowledge about the parameters, e.g. which ranges are meaningful for them. If <code>None</code>, the prior must be passed to <code>.build_posterior()</code>.</p> <code>None</code> <code>classifier</code> <code>Union[str, Callable]</code> <p>Classifier trained to approximate likelihood ratios. If it is a string, use a pre-configured network of the provided type (one of linear, mlp, resnet). Alternatively, a function that builds a custom neural network can be provided. The function will be called with the first batch of simulations (theta, x), which can thus be used for shape inference and potentially for z-scoring. It needs to return a PyTorch <code>nn.Module</code> implementing the classifier.</p> <code>'resnet'</code> <code>device</code> <code>str</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:{0, 1, \u2026}\u201d.</p> <code>'cpu'</code> <code>logging_level</code> <code>Union[int, str]</code> <p>Minimum severity of messages to log. One of the strings INFO, WARNING, DEBUG, ERROR and CRITICAL.</p> <code>'warning'</code> <code>summary_writer</code> <code>Optional[TensorboardSummaryWriter]</code> <p>A tensorboard <code>SummaryWriter</code> to control, among others, log file location (default is <code>&lt;current working directory&gt;/logs</code>.)</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during simulation and sampling.</p> <code>True</code> Source code in <code>sbi/inference/trainers/nre/nre_a.py</code> <pre><code>def __init__(\n    self,\n    prior: Optional[Distribution] = None,\n    classifier: Union[str, Callable] = \"resnet\",\n    device: str = \"cpu\",\n    logging_level: Union[int, str] = \"warning\",\n    summary_writer: Optional[TensorboardSummaryWriter] = None,\n    show_progress_bars: bool = True,\n):\n    r\"\"\"AALR[1], here known as NRE_A.\n\n    [1] _Likelihood-free MCMC with Amortized Approximate Likelihood Ratios_, Hermans\n        et al., ICML 2020, https://arxiv.org/abs/1903.04057\n\n    Args:\n        prior: A probability distribution that expresses prior knowledge about the\n            parameters, e.g. which ranges are meaningful for them. If `None`, the\n            prior must be passed to `.build_posterior()`.\n        classifier: Classifier trained to approximate likelihood ratios. If it is\n            a string, use a pre-configured network of the provided type (one of\n            linear, mlp, resnet). Alternatively, a function that builds a custom\n            neural network can be provided. The function will be called with the\n            first batch of simulations (theta, x), which can thus be used for shape\n            inference and potentially for z-scoring. It needs to return a PyTorch\n            `nn.Module` implementing the classifier.\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n        logging_level: Minimum severity of messages to log. One of the strings\n            INFO, WARNING, DEBUG, ERROR and CRITICAL.\n        summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n            file location (default is `&lt;current working directory&gt;/logs`.)\n        show_progress_bars: Whether to show a progressbar during simulation and\n            sampling.\n    \"\"\"\n\n    kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.nre_a.NRE_A.train","title":"<code>train(training_batch_size=200, learning_rate=0.0005, validation_fraction=0.1, stop_after_epochs=20, max_num_epochs=2 ** 31 - 1, clip_max_norm=5.0, resume_training=False, discard_prior_samples=False, retrain_from_scratch=False, show_train_summary=False, dataloader_kwargs=None, loss_kwargs=None)</code>","text":"<p>Return classifier that approximates the ratio \\(p(\\theta,x)/p(\\theta)p(x)\\).</p> <p>Parameters:</p> Name Type Description Default <code>training_batch_size</code> <code>int</code> <p>Training batch size.</p> <code>200</code> <code>learning_rate</code> <code>float</code> <p>Learning rate for Adam optimizer.</p> <code>0.0005</code> <code>validation_fraction</code> <code>float</code> <p>The fraction of data to use for validation.</p> <code>0.1</code> <code>stop_after_epochs</code> <code>int</code> <p>The number of epochs to wait for improvement on the validation set before terminating training.</p> <code>20</code> <code>max_num_epochs</code> <code>int</code> <p>Maximum number of epochs to run. If reached, we stop training even when the validation loss is still decreasing. Otherwise, we train until validation loss increases (see also <code>stop_after_epochs</code>).</p> <code>2 ** 31 - 1</code> <code>clip_max_norm</code> <code>Optional[float]</code> <p>Value at which to clip the total gradient norm in order to prevent exploding gradients. Use None for no clipping.</p> <code>5.0</code> <code>resume_training</code> <code>bool</code> <p>Can be used in case training time is limited, e.g. on a cluster. If <code>True</code>, the split between train and validation set, the optimizer, the number of epochs, and the best validation log-prob will be restored from the last time <code>.train()</code> was called.</p> <code>False</code> <code>discard_prior_samples</code> <code>bool</code> <p>Whether to discard samples simulated in round 1, i.e. from the prior. Training may be sped up by ignoring such less targeted samples.</p> <code>False</code> <code>retrain_from_scratch</code> <code>bool</code> <p>Whether to retrain the conditional density estimator for the posterior from scratch each round.</p> <code>False</code> <code>show_train_summary</code> <code>bool</code> <p>Whether to print the number of epochs and validation loss and leakage after the training.</p> <code>False</code> <code>dataloader_kwargs</code> <code>Optional[Dict]</code> <p>Additional or updated kwargs to be passed to the training and validation dataloaders (like, e.g., a collate_fn)</p> <code>None</code> <code>loss_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Additional or updated kwargs to be passed to the self._loss fn.</p> <code>None</code> <p>Returns:</p> Type Description <code>Module</code> <p>Classifier that approximates the ratio \\(p(\\theta,x)/p(\\theta)p(x)\\).</p> Source code in <code>sbi/inference/trainers/nre/nre_a.py</code> <pre><code>def train(\n    self,\n    training_batch_size: int = 200,\n    learning_rate: float = 5e-4,\n    validation_fraction: float = 0.1,\n    stop_after_epochs: int = 20,\n    max_num_epochs: int = 2**31 - 1,\n    clip_max_norm: Optional[float] = 5.0,\n    resume_training: bool = False,\n    discard_prior_samples: bool = False,\n    retrain_from_scratch: bool = False,\n    show_train_summary: bool = False,\n    dataloader_kwargs: Optional[Dict] = None,\n    loss_kwargs: Optional[Dict[str, Any]] = None,\n) -&gt; nn.Module:\n    r\"\"\"Return classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n\n    Args:\n        training_batch_size: Training batch size.\n        learning_rate: Learning rate for Adam optimizer.\n        validation_fraction: The fraction of data to use for validation.\n        stop_after_epochs: The number of epochs to wait for improvement on the\n            validation set before terminating training.\n        max_num_epochs: Maximum number of epochs to run. If reached, we stop\n            training even when the validation loss is still decreasing. Otherwise,\n            we train until validation loss increases (see also `stop_after_epochs`).\n        clip_max_norm: Value at which to clip the total gradient norm in order to\n            prevent exploding gradients. Use None for no clipping.\n        resume_training: Can be used in case training time is limited, e.g. on a\n            cluster. If `True`, the split between train and validation set, the\n            optimizer, the number of epochs, and the best validation log-prob will\n            be restored from the last time `.train()` was called.\n        discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n            from the prior. Training may be sped up by ignoring such less targeted\n            samples.\n        retrain_from_scratch: Whether to retrain the conditional density\n            estimator for the posterior from scratch each round.\n        show_train_summary: Whether to print the number of epochs and validation\n            loss and leakage after the training.\n        dataloader_kwargs: Additional or updated kwargs to be passed to the training\n            and validation dataloaders (like, e.g., a collate_fn)\n        loss_kwargs: Additional or updated kwargs to be passed to the self._loss fn.\n\n    Returns:\n        Classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n    \"\"\"\n\n    # AALR is defined for `num_atoms=2`.\n    # Proxy to `super().__call__` to ensure right parameter.\n    kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n    return super().train(**kwargs, num_atoms=2)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.nre_b.NRE_B","title":"<code>NRE_B</code>","text":"<p>               Bases: <code>RatioEstimator</code></p> Source code in <code>sbi/inference/trainers/nre/nre_b.py</code> <pre><code>class NRE_B(RatioEstimator):\n    def __init__(\n        self,\n        prior: Optional[Distribution] = None,\n        classifier: Union[str, Callable] = \"resnet\",\n        device: str = \"cpu\",\n        logging_level: Union[int, str] = \"warning\",\n        summary_writer: Optional[TensorboardSummaryWriter] = None,\n        show_progress_bars: bool = True,\n    ):\n        r\"\"\"SRE[1], here known as NRE_B.\n\n        [1] _On Contrastive Learning for Likelihood-free Inference_, Durkan et al.,\n            ICML 2020, https://arxiv.org/pdf/2002.03712\n\n        Args:\n            prior: A probability distribution that expresses prior knowledge about the\n                parameters, e.g. which ranges are meaningful for them. If `None`, the\n                prior must be passed to `.build_posterior()`.\n            classifier: Classifier trained to approximate likelihood ratios. If it is\n                a string, use a pre-configured network of the provided type (one of\n                linear, mlp, resnet). Alternatively, a function that builds a custom\n                neural network can be provided. The function will be called with the\n                first batch of simulations (theta, x), which can thus be used for shape\n                inference and potentially for z-scoring. It needs to return a PyTorch\n                `nn.Module` implementing the classifier.\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n            logging_level: Minimum severity of messages to log. One of the strings\n                INFO, WARNING, DEBUG, ERROR and CRITICAL.\n            summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n                file location (default is `&lt;current working directory&gt;/logs`.)\n            show_progress_bars: Whether to show a progressbar during simulation and\n                sampling.\n        \"\"\"\n\n        kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n        super().__init__(**kwargs)\n\n    def train(\n        self,\n        num_atoms: int = 10,\n        training_batch_size: int = 200,\n        learning_rate: float = 5e-4,\n        validation_fraction: float = 0.1,\n        stop_after_epochs: int = 20,\n        max_num_epochs: int = 2**31 - 1,\n        clip_max_norm: Optional[float] = 5.0,\n        resume_training: bool = False,\n        discard_prior_samples: bool = False,\n        retrain_from_scratch: bool = False,\n        show_train_summary: bool = False,\n        dataloader_kwargs: Optional[Dict] = None,\n    ) -&gt; nn.Module:\n        r\"\"\"Return classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n\n        Args:\n            num_atoms: Number of atoms to use for classification.\n            training_batch_size: Training batch size.\n            learning_rate: Learning rate for Adam optimizer.\n            validation_fraction: The fraction of data to use for validation.\n            stop_after_epochs: The number of epochs to wait for improvement on the\n                validation set before terminating training.\n            max_num_epochs: Maximum number of epochs to run. If reached, we stop\n                training even when the validation loss is still decreasing. Otherwise,\n                we train until validation loss increases (see also `stop_after_epochs`).\n            clip_max_norm: Value at which to clip the total gradient norm in order to\n                prevent exploding gradients. Use None for no clipping.\n            resume_training: Can be used in case training time is limited, e.g. on a\n                cluster. If `True`, the split between train and validation set, the\n                optimizer, the number of epochs, and the best validation log-prob will\n                be restored from the last time `.train()` was called.\n            discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n                from the prior. Training may be sped up by ignoring such less targeted\n                samples.\n            retrain_from_scratch: Whether to retrain the conditional density\n                estimator for the posterior from scratch each round.\n            show_train_summary: Whether to print the number of epochs and validation\n                loss and leakage after the training.\n            dataloader_kwargs: Additional or updated kwargs to be passed to the training\n                and validation dataloaders (like, e.g., a collate_fn)\n\n        Returns:\n            Classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n        \"\"\"\n        kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n        return super().train(**kwargs)\n\n    def _loss(self, theta: Tensor, x: Tensor, num_atoms: int) -&gt; Tensor:\n        r\"\"\"Return cross-entropy (via softmax activation) loss for 1-out-of-`num_atoms`\n        classification.\n\n        The classifier takes as input `num_atoms` $(\\theta,x)$ pairs. Out of these\n        pairs, one pair was sampled from the joint $p(\\theta,x)$ and all others from the\n        marginals $p(\\theta)p(x)$. The classifier is trained to predict which of the\n        pairs was sampled from the joint $p(\\theta,x)$.\n        \"\"\"\n\n        assert theta.shape[0] == x.shape[0], \"Batch sizes for theta and x must match.\"\n        batch_size = theta.shape[0]\n        logits = self._classifier_logits(theta, x, num_atoms)\n\n        # For 1-out-of-`num_atoms` classification each datapoint consists\n        # of `num_atoms` points, with one of them being the correct one.\n        # We have a batch of `batch_size` such datapoints.\n        logits = logits.reshape(batch_size, num_atoms)\n\n        # Index 0 is the theta-x-pair sampled from the joint p(theta,x) and hence the\n        # \"correct\" one for the 1-out-of-N classification.\n        log_prob = logits[:, 0] - torch.logsumexp(logits, dim=-1)\n\n        return -torch.mean(log_prob)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.nre_b.NRE_B.__init__","title":"<code>__init__(prior=None, classifier='resnet', device='cpu', logging_level='warning', summary_writer=None, show_progress_bars=True)</code>","text":"<p>SRE[1], here known as NRE_B.</p> <p>[1] On Contrastive Learning for Likelihood-free Inference, Durkan et al.,     ICML 2020, https://arxiv.org/pdf/2002.03712</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Optional[Distribution]</code> <p>A probability distribution that expresses prior knowledge about the parameters, e.g. which ranges are meaningful for them. If <code>None</code>, the prior must be passed to <code>.build_posterior()</code>.</p> <code>None</code> <code>classifier</code> <code>Union[str, Callable]</code> <p>Classifier trained to approximate likelihood ratios. If it is a string, use a pre-configured network of the provided type (one of linear, mlp, resnet). Alternatively, a function that builds a custom neural network can be provided. The function will be called with the first batch of simulations (theta, x), which can thus be used for shape inference and potentially for z-scoring. It needs to return a PyTorch <code>nn.Module</code> implementing the classifier.</p> <code>'resnet'</code> <code>device</code> <code>str</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:{0, 1, \u2026}\u201d.</p> <code>'cpu'</code> <code>logging_level</code> <code>Union[int, str]</code> <p>Minimum severity of messages to log. One of the strings INFO, WARNING, DEBUG, ERROR and CRITICAL.</p> <code>'warning'</code> <code>summary_writer</code> <code>Optional[TensorboardSummaryWriter]</code> <p>A tensorboard <code>SummaryWriter</code> to control, among others, log file location (default is <code>&lt;current working directory&gt;/logs</code>.)</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during simulation and sampling.</p> <code>True</code> Source code in <code>sbi/inference/trainers/nre/nre_b.py</code> <pre><code>def __init__(\n    self,\n    prior: Optional[Distribution] = None,\n    classifier: Union[str, Callable] = \"resnet\",\n    device: str = \"cpu\",\n    logging_level: Union[int, str] = \"warning\",\n    summary_writer: Optional[TensorboardSummaryWriter] = None,\n    show_progress_bars: bool = True,\n):\n    r\"\"\"SRE[1], here known as NRE_B.\n\n    [1] _On Contrastive Learning for Likelihood-free Inference_, Durkan et al.,\n        ICML 2020, https://arxiv.org/pdf/2002.03712\n\n    Args:\n        prior: A probability distribution that expresses prior knowledge about the\n            parameters, e.g. which ranges are meaningful for them. If `None`, the\n            prior must be passed to `.build_posterior()`.\n        classifier: Classifier trained to approximate likelihood ratios. If it is\n            a string, use a pre-configured network of the provided type (one of\n            linear, mlp, resnet). Alternatively, a function that builds a custom\n            neural network can be provided. The function will be called with the\n            first batch of simulations (theta, x), which can thus be used for shape\n            inference and potentially for z-scoring. It needs to return a PyTorch\n            `nn.Module` implementing the classifier.\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n        logging_level: Minimum severity of messages to log. One of the strings\n            INFO, WARNING, DEBUG, ERROR and CRITICAL.\n        summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n            file location (default is `&lt;current working directory&gt;/logs`.)\n        show_progress_bars: Whether to show a progressbar during simulation and\n            sampling.\n    \"\"\"\n\n    kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.nre_b.NRE_B.train","title":"<code>train(num_atoms=10, training_batch_size=200, learning_rate=0.0005, validation_fraction=0.1, stop_after_epochs=20, max_num_epochs=2 ** 31 - 1, clip_max_norm=5.0, resume_training=False, discard_prior_samples=False, retrain_from_scratch=False, show_train_summary=False, dataloader_kwargs=None)</code>","text":"<p>Return classifier that approximates the ratio \\(p(\\theta,x)/p(\\theta)p(x)\\).</p> <p>Parameters:</p> Name Type Description Default <code>num_atoms</code> <code>int</code> <p>Number of atoms to use for classification.</p> <code>10</code> <code>training_batch_size</code> <code>int</code> <p>Training batch size.</p> <code>200</code> <code>learning_rate</code> <code>float</code> <p>Learning rate for Adam optimizer.</p> <code>0.0005</code> <code>validation_fraction</code> <code>float</code> <p>The fraction of data to use for validation.</p> <code>0.1</code> <code>stop_after_epochs</code> <code>int</code> <p>The number of epochs to wait for improvement on the validation set before terminating training.</p> <code>20</code> <code>max_num_epochs</code> <code>int</code> <p>Maximum number of epochs to run. If reached, we stop training even when the validation loss is still decreasing. Otherwise, we train until validation loss increases (see also <code>stop_after_epochs</code>).</p> <code>2 ** 31 - 1</code> <code>clip_max_norm</code> <code>Optional[float]</code> <p>Value at which to clip the total gradient norm in order to prevent exploding gradients. Use None for no clipping.</p> <code>5.0</code> <code>resume_training</code> <code>bool</code> <p>Can be used in case training time is limited, e.g. on a cluster. If <code>True</code>, the split between train and validation set, the optimizer, the number of epochs, and the best validation log-prob will be restored from the last time <code>.train()</code> was called.</p> <code>False</code> <code>discard_prior_samples</code> <code>bool</code> <p>Whether to discard samples simulated in round 1, i.e. from the prior. Training may be sped up by ignoring such less targeted samples.</p> <code>False</code> <code>retrain_from_scratch</code> <code>bool</code> <p>Whether to retrain the conditional density estimator for the posterior from scratch each round.</p> <code>False</code> <code>show_train_summary</code> <code>bool</code> <p>Whether to print the number of epochs and validation loss and leakage after the training.</p> <code>False</code> <code>dataloader_kwargs</code> <code>Optional[Dict]</code> <p>Additional or updated kwargs to be passed to the training and validation dataloaders (like, e.g., a collate_fn)</p> <code>None</code> <p>Returns:</p> Type Description <code>Module</code> <p>Classifier that approximates the ratio \\(p(\\theta,x)/p(\\theta)p(x)\\).</p> Source code in <code>sbi/inference/trainers/nre/nre_b.py</code> <pre><code>def train(\n    self,\n    num_atoms: int = 10,\n    training_batch_size: int = 200,\n    learning_rate: float = 5e-4,\n    validation_fraction: float = 0.1,\n    stop_after_epochs: int = 20,\n    max_num_epochs: int = 2**31 - 1,\n    clip_max_norm: Optional[float] = 5.0,\n    resume_training: bool = False,\n    discard_prior_samples: bool = False,\n    retrain_from_scratch: bool = False,\n    show_train_summary: bool = False,\n    dataloader_kwargs: Optional[Dict] = None,\n) -&gt; nn.Module:\n    r\"\"\"Return classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n\n    Args:\n        num_atoms: Number of atoms to use for classification.\n        training_batch_size: Training batch size.\n        learning_rate: Learning rate for Adam optimizer.\n        validation_fraction: The fraction of data to use for validation.\n        stop_after_epochs: The number of epochs to wait for improvement on the\n            validation set before terminating training.\n        max_num_epochs: Maximum number of epochs to run. If reached, we stop\n            training even when the validation loss is still decreasing. Otherwise,\n            we train until validation loss increases (see also `stop_after_epochs`).\n        clip_max_norm: Value at which to clip the total gradient norm in order to\n            prevent exploding gradients. Use None for no clipping.\n        resume_training: Can be used in case training time is limited, e.g. on a\n            cluster. If `True`, the split between train and validation set, the\n            optimizer, the number of epochs, and the best validation log-prob will\n            be restored from the last time `.train()` was called.\n        discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n            from the prior. Training may be sped up by ignoring such less targeted\n            samples.\n        retrain_from_scratch: Whether to retrain the conditional density\n            estimator for the posterior from scratch each round.\n        show_train_summary: Whether to print the number of epochs and validation\n            loss and leakage after the training.\n        dataloader_kwargs: Additional or updated kwargs to be passed to the training\n            and validation dataloaders (like, e.g., a collate_fn)\n\n    Returns:\n        Classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n    \"\"\"\n    kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n    return super().train(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.nre_c.NRE_C","title":"<code>NRE_C</code>","text":"<p>               Bases: <code>RatioEstimator</code></p> Source code in <code>sbi/inference/trainers/nre/nre_c.py</code> <pre><code>class NRE_C(RatioEstimator):\n    def __init__(\n        self,\n        prior: Optional[Distribution] = None,\n        classifier: Union[str, Callable] = \"resnet\",\n        device: str = \"cpu\",\n        logging_level: Union[int, str] = \"warning\",\n        summary_writer: Optional[TensorboardSummaryWriter] = None,\n        show_progress_bars: bool = True,\n    ):\n        r\"\"\"NRE-C[1] is a generalization of the non-sequential (amortized) versions of\n        NRE_A and NRE_B. We call the algorithm NRE_C within `sbi`.\n\n        NRE-C:\n        (1) like NRE_B, features a \"multiclass\" loss function where several marginally\n            drawn parameter-data pairs are contrasted against a jointly drawn pair.\n        (2) like AALR/NRE_A, i.e., the non-sequential version of NRE_A, it encourages\n            the approximate ratio $p(\\theta,x)/p(\\theta)p(x)$, accessed through\n            `.potential()` within `sbi`, to be exact at optimum. This addresses the\n            issue that NRE_B estimates this ratio only up to an arbitrary function\n            (normalizing constant) of the data $x$.\n\n        Just like for all ratio estimation algorithms, the sequential version of NRE_C\n        will be estimated only up to a function (normalizing constant) of the data $x$\n        in rounds after the first.\n\n        [1] _Contrastive Neural Ratio Estimation_, Benajmin Kurt Miller, et. al.,\n            NeurIPS 2022, https://arxiv.org/abs/2210.06170\n\n        Args:\n            prior: A probability distribution that expresses prior knowledge about the\n                parameters, e.g. which ranges are meaningful for them. If `None`, the\n                prior must be passed to `.build_posterior()`.\n            classifier: Classifier trained to approximate likelihood ratios. If it is\n                a string, use a pre-configured network of the provided type (one of\n                linear, mlp, resnet). Alternatively, a function that builds a custom\n                neural network can be provided. The function will be called with the\n                first batch of simulations (theta, x), which can thus be used for shape\n                inference and potentially for z-scoring. It needs to return a PyTorch\n                `nn.Module` implementing the classifier.\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n            logging_level: Minimum severity of messages to log. One of the strings\n                INFO, WARNING, DEBUG, ERROR and CRITICAL.\n            summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n                file location (default is `&lt;current working directory&gt;/logs`.)\n            show_progress_bars: Whether to show a progressbar during simulation and\n                sampling.\n        \"\"\"\n\n        kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n        super().__init__(**kwargs)\n\n    def train(\n        self,\n        num_classes: int = 5,\n        gamma: float = 1.0,\n        training_batch_size: int = 200,\n        learning_rate: float = 5e-4,\n        validation_fraction: float = 0.1,\n        stop_after_epochs: int = 20,\n        max_num_epochs: int = 2**31 - 1,\n        clip_max_norm: Optional[float] = 5.0,\n        resume_training: bool = False,\n        discard_prior_samples: bool = False,\n        retrain_from_scratch: bool = False,\n        show_train_summary: bool = False,\n        dataloader_kwargs: Optional[Dict] = None,\n    ) -&gt; nn.Module:\n        r\"\"\"Return classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n\n        Args:\n            num_classes: Number of theta to classify against, corresponds to $K$ in\n                _Contrastive Neural Ratio Estimation_. Minimum value is 1. Similar to\n                `num_atoms` for SNRE_B except SNRE_C has an additional independently\n                drawn sample. The total number of alternative parameters `NRE-C` \"sees\"\n                is $2K-1$ or `2 * num_classes - 1` divided between two loss terms.\n            gamma: Determines the relative weight of the sum of all $K$ dependently\n                drawn classes against the marginally drawn one. Specifically,\n                $p(y=k) :=p_K$, $p(y=0) := p_0$, $p_0 = 1 - K p_K$, and finally\n                $\\gamma := K p_K / p_0$.\n            training_batch_size: Training batch size.\n            learning_rate: Learning rate for Adam optimizer.\n            validation_fraction: The fraction of data to use for validation.\n            stop_after_epochs: The number of epochs to wait for improvement on the\n                validation set before terminating training.\n            max_num_epochs: Maximum number of epochs to run. If reached, we stop\n                training even when the validation loss is still decreasing. Otherwise,\n                we train until validation loss increases (see also `stop_after_epochs`).\n            clip_max_norm: Value at which to clip the total gradient norm in order to\n                prevent exploding gradients. Use None for no clipping.\n            exclude_invalid_x: Whether to exclude simulation outputs `x=NaN` or `x=\u00b1\u221e`\n                during training. Expect errors, silent or explicit, when `False`.\n            resume_training: Can be used in case training time is limited, e.g. on a\n                cluster. If `True`, the split between train and validation set, the\n                optimizer, the number of epochs, and the best validation log-prob will\n                be restored from the last time `.train()` was called.\n            discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n                from the prior. Training may be sped up by ignoring such less targeted\n                samples.\n            retrain_from_scratch: Whether to retrain the conditional density\n                estimator for the posterior from scratch each round.\n            show_train_summary: Whether to print the number of epochs and validation\n                loss and leakage after the training.\n            dataloader_kwargs: Additional or updated kwargs to be passed to the training\n                and validation dataloaders (like, e.g., a collate_fn)\n\n        Returns:\n            Classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n        \"\"\"\n        kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n        kwargs[\"num_atoms\"] = kwargs.pop(\"num_classes\") + 1\n        kwargs[\"loss_kwargs\"] = {\"gamma\": kwargs.pop(\"gamma\")}\n        return super().train(**kwargs)\n\n    def _loss(\n        self, theta: Tensor, x: Tensor, num_atoms: int, gamma: float\n    ) -&gt; torch.Tensor:\n        r\"\"\"Return cross-entropy loss (via ''multi-class sigmoid'' activation) for\n        1-out-of-`K + 1` classification.\n\n        At optimum, this loss function returns the exact likelihood-to-evidence ratio\n        in the first round.\n        Details of loss computation are described in Contrastive Neural Ratio\n        Estimation[1]. The paper does not discuss the sequential case.\n\n        [1] _Contrastive Neural Ratio Estimation_, Benajmin Kurt Miller, et. al.,\n            NeurIPS 2022, https://arxiv.org/abs/2210.06170\n        \"\"\"\n\n        # Reminder: K = num_classes\n        # The algorithm is written with K, so we convert back to K format rather than\n        # reasoning in num_atoms.\n        num_classes = num_atoms - 1\n        assert num_classes &gt;= 1, f\"num_classes = {num_classes} must be greater than 1.\"\n\n        assert theta.shape[0] == x.shape[0], \"Batch sizes for theta and x must match.\"\n        batch_size = theta.shape[0]\n\n        # We append a contrastive theta to the marginal case because we will remove\n        # the jointly drawn\n        # sample in the logits_marginal[:, 0] position. That makes the remaining sample\n        # marginally drawn.\n        # We have a batch of `batch_size` datapoints.\n        logits_marginal = self._classifier_logits(theta, x, num_classes + 1).reshape(\n            batch_size, num_classes + 1\n        )\n        logits_joint = self._classifier_logits(theta, x, num_classes).reshape(\n            batch_size, num_classes\n        )\n\n        dtype = logits_marginal.dtype\n        device = logits_marginal.device\n\n        # Index 0 is the theta-x-pair sampled from the joint p(theta,x) and hence\n        # we remove the jointly drawn sample from the logits_marginal\n        logits_marginal = logits_marginal[:, 1:]\n        # ... and retain it in the logits_joint. Now we have two arrays with K choices.\n\n        # To use logsumexp, we extend the denominator logits with loggamma\n        loggamma = torch.tensor(gamma, dtype=dtype, device=device).log()\n        logK = torch.tensor(num_classes, dtype=dtype, device=device).log()\n        denominator_marginal = torch.concat(\n            [loggamma + logits_marginal, logK.expand((batch_size, 1))],\n            dim=-1,\n        )\n        denominator_joint = torch.concat(\n            [loggamma + logits_joint, logK.expand((batch_size, 1))],\n            dim=-1,\n        )\n\n        # Compute the contributions to the loss from each term in the classification.\n        log_prob_marginal = logK - torch.logsumexp(denominator_marginal, dim=-1)\n        log_prob_joint = (\n            loggamma + logits_joint[:, 0] - torch.logsumexp(denominator_joint, dim=-1)\n        )\n\n        # relative weights. p_marginal := p_0, and p_joint := p_K * K from the notation.\n        p_marginal, p_joint = self._get_prior_probs_marginal_and_joint(gamma)\n        return -torch.mean(p_marginal * log_prob_marginal + p_joint * log_prob_joint)\n\n    @staticmethod\n    def _get_prior_probs_marginal_and_joint(gamma: float) -&gt; Tuple[float, float]:\n        r\"\"\"Return a tuple (p_marginal, p_joint) where `p_marginal := `$p_0$,\n        `p_joint := `$p_K \\cdot K$.\n\n        We let the joint (dependently drawn) class to be equally likely across K\n        options. The marginal class is therefore restricted to get the remaining\n        probability.\n        \"\"\"\n        p_joint = gamma / (1 + gamma)\n        p_marginal = 1 / (1 + gamma)\n        return p_marginal, p_joint\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.nre_c.NRE_C.__init__","title":"<code>__init__(prior=None, classifier='resnet', device='cpu', logging_level='warning', summary_writer=None, show_progress_bars=True)</code>","text":"<p>NRE-C[1] is a generalization of the non-sequential (amortized) versions of NRE_A and NRE_B. We call the algorithm NRE_C within <code>sbi</code>.</p> <p>NRE-C: (1) like NRE_B, features a \u201cmulticlass\u201d loss function where several marginally     drawn parameter-data pairs are contrasted against a jointly drawn pair. (2) like AALR/NRE_A, i.e., the non-sequential version of NRE_A, it encourages     the approximate ratio \\(p(\\theta,x)/p(\\theta)p(x)\\), accessed through     <code>.potential()</code> within <code>sbi</code>, to be exact at optimum. This addresses the     issue that NRE_B estimates this ratio only up to an arbitrary function     (normalizing constant) of the data \\(x\\).</p> <p>Just like for all ratio estimation algorithms, the sequential version of NRE_C will be estimated only up to a function (normalizing constant) of the data \\(x\\) in rounds after the first.</p> <p>[1] Contrastive Neural Ratio Estimation, Benajmin Kurt Miller, et. al.,     NeurIPS 2022, https://arxiv.org/abs/2210.06170</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Optional[Distribution]</code> <p>A probability distribution that expresses prior knowledge about the parameters, e.g. which ranges are meaningful for them. If <code>None</code>, the prior must be passed to <code>.build_posterior()</code>.</p> <code>None</code> <code>classifier</code> <code>Union[str, Callable]</code> <p>Classifier trained to approximate likelihood ratios. If it is a string, use a pre-configured network of the provided type (one of linear, mlp, resnet). Alternatively, a function that builds a custom neural network can be provided. The function will be called with the first batch of simulations (theta, x), which can thus be used for shape inference and potentially for z-scoring. It needs to return a PyTorch <code>nn.Module</code> implementing the classifier.</p> <code>'resnet'</code> <code>device</code> <code>str</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:{0, 1, \u2026}\u201d.</p> <code>'cpu'</code> <code>logging_level</code> <code>Union[int, str]</code> <p>Minimum severity of messages to log. One of the strings INFO, WARNING, DEBUG, ERROR and CRITICAL.</p> <code>'warning'</code> <code>summary_writer</code> <code>Optional[TensorboardSummaryWriter]</code> <p>A tensorboard <code>SummaryWriter</code> to control, among others, log file location (default is <code>&lt;current working directory&gt;/logs</code>.)</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during simulation and sampling.</p> <code>True</code> Source code in <code>sbi/inference/trainers/nre/nre_c.py</code> <pre><code>def __init__(\n    self,\n    prior: Optional[Distribution] = None,\n    classifier: Union[str, Callable] = \"resnet\",\n    device: str = \"cpu\",\n    logging_level: Union[int, str] = \"warning\",\n    summary_writer: Optional[TensorboardSummaryWriter] = None,\n    show_progress_bars: bool = True,\n):\n    r\"\"\"NRE-C[1] is a generalization of the non-sequential (amortized) versions of\n    NRE_A and NRE_B. We call the algorithm NRE_C within `sbi`.\n\n    NRE-C:\n    (1) like NRE_B, features a \"multiclass\" loss function where several marginally\n        drawn parameter-data pairs are contrasted against a jointly drawn pair.\n    (2) like AALR/NRE_A, i.e., the non-sequential version of NRE_A, it encourages\n        the approximate ratio $p(\\theta,x)/p(\\theta)p(x)$, accessed through\n        `.potential()` within `sbi`, to be exact at optimum. This addresses the\n        issue that NRE_B estimates this ratio only up to an arbitrary function\n        (normalizing constant) of the data $x$.\n\n    Just like for all ratio estimation algorithms, the sequential version of NRE_C\n    will be estimated only up to a function (normalizing constant) of the data $x$\n    in rounds after the first.\n\n    [1] _Contrastive Neural Ratio Estimation_, Benajmin Kurt Miller, et. al.,\n        NeurIPS 2022, https://arxiv.org/abs/2210.06170\n\n    Args:\n        prior: A probability distribution that expresses prior knowledge about the\n            parameters, e.g. which ranges are meaningful for them. If `None`, the\n            prior must be passed to `.build_posterior()`.\n        classifier: Classifier trained to approximate likelihood ratios. If it is\n            a string, use a pre-configured network of the provided type (one of\n            linear, mlp, resnet). Alternatively, a function that builds a custom\n            neural network can be provided. The function will be called with the\n            first batch of simulations (theta, x), which can thus be used for shape\n            inference and potentially for z-scoring. It needs to return a PyTorch\n            `nn.Module` implementing the classifier.\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n        logging_level: Minimum severity of messages to log. One of the strings\n            INFO, WARNING, DEBUG, ERROR and CRITICAL.\n        summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n            file location (default is `&lt;current working directory&gt;/logs`.)\n        show_progress_bars: Whether to show a progressbar during simulation and\n            sampling.\n    \"\"\"\n\n    kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.nre_c.NRE_C.train","title":"<code>train(num_classes=5, gamma=1.0, training_batch_size=200, learning_rate=0.0005, validation_fraction=0.1, stop_after_epochs=20, max_num_epochs=2 ** 31 - 1, clip_max_norm=5.0, resume_training=False, discard_prior_samples=False, retrain_from_scratch=False, show_train_summary=False, dataloader_kwargs=None)</code>","text":"<p>Return classifier that approximates the ratio \\(p(\\theta,x)/p(\\theta)p(x)\\).</p> <p>Parameters:</p> Name Type Description Default <code>num_classes</code> <code>int</code> <p>Number of theta to classify against, corresponds to \\(K\\) in Contrastive Neural Ratio Estimation. Minimum value is 1. Similar to <code>num_atoms</code> for SNRE_B except SNRE_C has an additional independently drawn sample. The total number of alternative parameters <code>NRE-C</code> \u201csees\u201d is \\(2K-1\\) or <code>2 * num_classes - 1</code> divided between two loss terms.</p> <code>5</code> <code>gamma</code> <code>float</code> <p>Determines the relative weight of the sum of all \\(K\\) dependently drawn classes against the marginally drawn one. Specifically, \\(p(y=k) :=p_K\\), \\(p(y=0) := p_0\\), \\(p_0 = 1 - K p_K\\), and finally \\(\\gamma := K p_K / p_0\\).</p> <code>1.0</code> <code>training_batch_size</code> <code>int</code> <p>Training batch size.</p> <code>200</code> <code>learning_rate</code> <code>float</code> <p>Learning rate for Adam optimizer.</p> <code>0.0005</code> <code>validation_fraction</code> <code>float</code> <p>The fraction of data to use for validation.</p> <code>0.1</code> <code>stop_after_epochs</code> <code>int</code> <p>The number of epochs to wait for improvement on the validation set before terminating training.</p> <code>20</code> <code>max_num_epochs</code> <code>int</code> <p>Maximum number of epochs to run. If reached, we stop training even when the validation loss is still decreasing. Otherwise, we train until validation loss increases (see also <code>stop_after_epochs</code>).</p> <code>2 ** 31 - 1</code> <code>clip_max_norm</code> <code>Optional[float]</code> <p>Value at which to clip the total gradient norm in order to prevent exploding gradients. Use None for no clipping.</p> <code>5.0</code> <code>exclude_invalid_x</code> <p>Whether to exclude simulation outputs <code>x=NaN</code> or <code>x=\u00b1\u221e</code> during training. Expect errors, silent or explicit, when <code>False</code>.</p> required <code>resume_training</code> <code>bool</code> <p>Can be used in case training time is limited, e.g. on a cluster. If <code>True</code>, the split between train and validation set, the optimizer, the number of epochs, and the best validation log-prob will be restored from the last time <code>.train()</code> was called.</p> <code>False</code> <code>discard_prior_samples</code> <code>bool</code> <p>Whether to discard samples simulated in round 1, i.e. from the prior. Training may be sped up by ignoring such less targeted samples.</p> <code>False</code> <code>retrain_from_scratch</code> <code>bool</code> <p>Whether to retrain the conditional density estimator for the posterior from scratch each round.</p> <code>False</code> <code>show_train_summary</code> <code>bool</code> <p>Whether to print the number of epochs and validation loss and leakage after the training.</p> <code>False</code> <code>dataloader_kwargs</code> <code>Optional[Dict]</code> <p>Additional or updated kwargs to be passed to the training and validation dataloaders (like, e.g., a collate_fn)</p> <code>None</code> <p>Returns:</p> Type Description <code>Module</code> <p>Classifier that approximates the ratio \\(p(\\theta,x)/p(\\theta)p(x)\\).</p> Source code in <code>sbi/inference/trainers/nre/nre_c.py</code> <pre><code>def train(\n    self,\n    num_classes: int = 5,\n    gamma: float = 1.0,\n    training_batch_size: int = 200,\n    learning_rate: float = 5e-4,\n    validation_fraction: float = 0.1,\n    stop_after_epochs: int = 20,\n    max_num_epochs: int = 2**31 - 1,\n    clip_max_norm: Optional[float] = 5.0,\n    resume_training: bool = False,\n    discard_prior_samples: bool = False,\n    retrain_from_scratch: bool = False,\n    show_train_summary: bool = False,\n    dataloader_kwargs: Optional[Dict] = None,\n) -&gt; nn.Module:\n    r\"\"\"Return classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n\n    Args:\n        num_classes: Number of theta to classify against, corresponds to $K$ in\n            _Contrastive Neural Ratio Estimation_. Minimum value is 1. Similar to\n            `num_atoms` for SNRE_B except SNRE_C has an additional independently\n            drawn sample. The total number of alternative parameters `NRE-C` \"sees\"\n            is $2K-1$ or `2 * num_classes - 1` divided between two loss terms.\n        gamma: Determines the relative weight of the sum of all $K$ dependently\n            drawn classes against the marginally drawn one. Specifically,\n            $p(y=k) :=p_K$, $p(y=0) := p_0$, $p_0 = 1 - K p_K$, and finally\n            $\\gamma := K p_K / p_0$.\n        training_batch_size: Training batch size.\n        learning_rate: Learning rate for Adam optimizer.\n        validation_fraction: The fraction of data to use for validation.\n        stop_after_epochs: The number of epochs to wait for improvement on the\n            validation set before terminating training.\n        max_num_epochs: Maximum number of epochs to run. If reached, we stop\n            training even when the validation loss is still decreasing. Otherwise,\n            we train until validation loss increases (see also `stop_after_epochs`).\n        clip_max_norm: Value at which to clip the total gradient norm in order to\n            prevent exploding gradients. Use None for no clipping.\n        exclude_invalid_x: Whether to exclude simulation outputs `x=NaN` or `x=\u00b1\u221e`\n            during training. Expect errors, silent or explicit, when `False`.\n        resume_training: Can be used in case training time is limited, e.g. on a\n            cluster. If `True`, the split between train and validation set, the\n            optimizer, the number of epochs, and the best validation log-prob will\n            be restored from the last time `.train()` was called.\n        discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n            from the prior. Training may be sped up by ignoring such less targeted\n            samples.\n        retrain_from_scratch: Whether to retrain the conditional density\n            estimator for the posterior from scratch each round.\n        show_train_summary: Whether to print the number of epochs and validation\n            loss and leakage after the training.\n        dataloader_kwargs: Additional or updated kwargs to be passed to the training\n            and validation dataloaders (like, e.g., a collate_fn)\n\n    Returns:\n        Classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n    \"\"\"\n    kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n    kwargs[\"num_atoms\"] = kwargs.pop(\"num_classes\") + 1\n    kwargs[\"loss_kwargs\"] = {\"gamma\": kwargs.pop(\"gamma\")}\n    return super().train(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.bnre.BNRE","title":"<code>BNRE</code>","text":"<p>               Bases: <code>NRE_A</code></p> Source code in <code>sbi/inference/trainers/nre/bnre.py</code> <pre><code>class BNRE(NRE_A):\n    def __init__(\n        self,\n        prior: Optional[Distribution] = None,\n        classifier: Union[str, Callable] = \"resnet\",\n        device: str = \"cpu\",\n        logging_level: Union[int, str] = \"warning\",\n        summary_writer: Optional[TensorboardSummaryWriter] = None,\n        show_progress_bars: bool = True,\n    ):\n        r\"\"\"Balanced neural ratio estimation (BNRE)[1].\n\n        BNRE is a variation of NRE aiming to produce more conservative posterior\n        approximations.\n\n        [1] Delaunoy, A., Hermans, J., Rozet, F., Wehenkel, A., &amp; Louppe, G..\n        Towards Reliable Simulation-Based Inference with Balanced Neural Ratio\n        Estimation.\n        NeurIPS 2022. https://arxiv.org/abs/2208.13624\n\n        Args:\n            prior: A probability distribution that expresses prior knowledge about the\n                parameters, e.g. which ranges are meaningful for them. If `None`, the\n                prior must be passed to `.build_posterior()`.\n            classifier: Classifier trained to approximate likelihood ratios. If it is\n                a string, use a pre-configured network of the provided type (one of\n                linear, mlp, resnet). Alternatively, a function that builds a custom\n                neural network can be provided. The function will be called with the\n                first batch of simulations $(\\theta, x)$, which can thus be used for\n                shape inference and potentially for z-scoring. It needs to return a\n                PyTorch `nn.Module` implementing the classifier.\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n            logging_level: Minimum severity of messages to log. One of the strings\n                INFO, WARNING, DEBUG, ERROR and CRITICAL.\n            summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n                file location (default is `&lt;current working directory&gt;/logs`.)\n            show_progress_bars: Whether to show a progressbar during simulation and\n                sampling.\n        \"\"\"\n\n        kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n        super().__init__(**kwargs)\n\n    def train(\n        self,\n        regularization_strength: float = 100.0,\n        training_batch_size: int = 200,\n        learning_rate: float = 5e-4,\n        validation_fraction: float = 0.1,\n        stop_after_epochs: int = 20,\n        max_num_epochs: int = 2**31 - 1,\n        clip_max_norm: Optional[float] = 5.0,\n        resume_training: bool = False,\n        discard_prior_samples: bool = False,\n        retrain_from_scratch: bool = False,\n        show_train_summary: bool = False,\n        dataloader_kwargs: Optional[Dict] = None,\n    ) -&gt; nn.Module:\n        r\"\"\"Return classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n        Args:\n\n            regularization_strength: The multiplicative coefficient applied to the\n                balancing regularizer ($\\lambda$).\n            training_batch_size: Training batch size.\n            learning_rate: Learning rate for Adam optimizer.\n            validation_fraction: The fraction of data to use for validation.\n            stop_after_epochs: The number of epochs to wait for improvement on the\n                validation set before terminating training.\n            max_num_epochs: Maximum number of epochs to run. If reached, we stop\n                training even when the validation loss is still decreasing. Otherwise,\n                we train until validation loss increases (see also `stop_after_epochs`).\n            clip_max_norm: Value at which to clip the total gradient norm in order to\n                prevent exploding gradients. Use None for no clipping.\n            exclude_invalid_x: Whether to exclude simulation outputs `x=NaN` or `x=\u00b1\u221e`\n                during training. Expect errors, silent or explicit, when `False`.\n            resume_training: Can be used in case training time is limited, e.g. on a\n                cluster. If `True`, the split between train and validation set, the\n                optimizer, the number of epochs, and the best validation log-prob will\n                be restored from the last time `.train()` was called.\n            discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n                from the prior. Training may be sped up by ignoring such less targeted\n                samples.\n            retrain_from_scratch: Whether to retrain the conditional density\n                estimator for the posterior from scratch each round.\n            show_train_summary: Whether to print the number of epochs and validation\n                loss and leakage after the training.\n            dataloader_kwargs: Additional or updated kwargs to be passed to the training\n                and validation dataloaders (like, e.g., a collate_fn)\n        Returns:\n            Classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n        \"\"\"\n        kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n        kwargs[\"loss_kwargs\"] = {\n            \"regularization_strength\": kwargs.pop(\"regularization_strength\")\n        }\n        return super().train(**kwargs)\n\n    def _loss(\n        self, theta: Tensor, x: Tensor, num_atoms: int, regularization_strength: float\n    ) -&gt; Tensor:\n        \"\"\"Returns the binary cross-entropy loss for the trained classifier.\n\n        The classifier takes as input a $(\\theta,x)$ pair. It is trained to predict 1\n        if the pair was sampled from the joint $p(\\theta,x)$, and to predict 0 if the\n        pair was sampled from the marginals $p(\\theta)p(x)$.\n        \"\"\"\n\n        assert theta.shape[0] == x.shape[0], \"Batch sizes for theta and x must match.\"\n        batch_size = theta.shape[0]\n\n        logits = self._classifier_logits(theta, x, num_atoms)\n        likelihood = torch.sigmoid(logits).squeeze()\n\n        # Alternating pairs where there is one sampled from the joint and one\n        # sampled from the marginals. The first element is sampled from the\n        # joint p(theta, x) and is labelled 1. The second element is sampled\n        # from the marginals p(theta)p(x) and is labelled 0. And so on.\n        labels = ones(2 * batch_size, device=self._device)  # two atoms\n        labels[1::2] = 0.0\n\n        # Binary cross entropy to learn the likelihood (AALR-specific)\n        bce = nn.BCELoss()(likelihood, labels)\n\n        # Balancing regularizer\n        regularizer = (\n            (torch.sigmoid(logits[0::2]) + torch.sigmoid(logits[1::2]) - 1)\n            .mean()\n            .square()\n        )\n\n        return bce + regularization_strength * regularizer\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.bnre.BNRE.__init__","title":"<code>__init__(prior=None, classifier='resnet', device='cpu', logging_level='warning', summary_writer=None, show_progress_bars=True)</code>","text":"<p>Balanced neural ratio estimation (BNRE)[1].</p> <p>BNRE is a variation of NRE aiming to produce more conservative posterior approximations.</p> <p>[1] Delaunoy, A., Hermans, J., Rozet, F., Wehenkel, A., &amp; Louppe, G.. Towards Reliable Simulation-Based Inference with Balanced Neural Ratio Estimation. NeurIPS 2022. https://arxiv.org/abs/2208.13624</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Optional[Distribution]</code> <p>A probability distribution that expresses prior knowledge about the parameters, e.g. which ranges are meaningful for them. If <code>None</code>, the prior must be passed to <code>.build_posterior()</code>.</p> <code>None</code> <code>classifier</code> <code>Union[str, Callable]</code> <p>Classifier trained to approximate likelihood ratios. If it is a string, use a pre-configured network of the provided type (one of linear, mlp, resnet). Alternatively, a function that builds a custom neural network can be provided. The function will be called with the first batch of simulations \\((\\theta, x)\\), which can thus be used for shape inference and potentially for z-scoring. It needs to return a PyTorch <code>nn.Module</code> implementing the classifier.</p> <code>'resnet'</code> <code>device</code> <code>str</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:{0, 1, \u2026}\u201d.</p> <code>'cpu'</code> <code>logging_level</code> <code>Union[int, str]</code> <p>Minimum severity of messages to log. One of the strings INFO, WARNING, DEBUG, ERROR and CRITICAL.</p> <code>'warning'</code> <code>summary_writer</code> <code>Optional[TensorboardSummaryWriter]</code> <p>A tensorboard <code>SummaryWriter</code> to control, among others, log file location (default is <code>&lt;current working directory&gt;/logs</code>.)</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during simulation and sampling.</p> <code>True</code> Source code in <code>sbi/inference/trainers/nre/bnre.py</code> <pre><code>def __init__(\n    self,\n    prior: Optional[Distribution] = None,\n    classifier: Union[str, Callable] = \"resnet\",\n    device: str = \"cpu\",\n    logging_level: Union[int, str] = \"warning\",\n    summary_writer: Optional[TensorboardSummaryWriter] = None,\n    show_progress_bars: bool = True,\n):\n    r\"\"\"Balanced neural ratio estimation (BNRE)[1].\n\n    BNRE is a variation of NRE aiming to produce more conservative posterior\n    approximations.\n\n    [1] Delaunoy, A., Hermans, J., Rozet, F., Wehenkel, A., &amp; Louppe, G..\n    Towards Reliable Simulation-Based Inference with Balanced Neural Ratio\n    Estimation.\n    NeurIPS 2022. https://arxiv.org/abs/2208.13624\n\n    Args:\n        prior: A probability distribution that expresses prior knowledge about the\n            parameters, e.g. which ranges are meaningful for them. If `None`, the\n            prior must be passed to `.build_posterior()`.\n        classifier: Classifier trained to approximate likelihood ratios. If it is\n            a string, use a pre-configured network of the provided type (one of\n            linear, mlp, resnet). Alternatively, a function that builds a custom\n            neural network can be provided. The function will be called with the\n            first batch of simulations $(\\theta, x)$, which can thus be used for\n            shape inference and potentially for z-scoring. It needs to return a\n            PyTorch `nn.Module` implementing the classifier.\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:{0, 1, ...}\".\n        logging_level: Minimum severity of messages to log. One of the strings\n            INFO, WARNING, DEBUG, ERROR and CRITICAL.\n        summary_writer: A tensorboard `SummaryWriter` to control, among others, log\n            file location (default is `&lt;current working directory&gt;/logs`.)\n        show_progress_bars: Whether to show a progressbar during simulation and\n            sampling.\n    \"\"\"\n\n    kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.trainers.nre.bnre.BNRE.train","title":"<code>train(regularization_strength=100.0, training_batch_size=200, learning_rate=0.0005, validation_fraction=0.1, stop_after_epochs=20, max_num_epochs=2 ** 31 - 1, clip_max_norm=5.0, resume_training=False, discard_prior_samples=False, retrain_from_scratch=False, show_train_summary=False, dataloader_kwargs=None)</code>","text":"<p>Return classifier that approximates the ratio \\(p(\\theta,x)/p(\\theta)p(x)\\). Args:</p> <pre><code>regularization_strength: The multiplicative coefficient applied to the\n    balancing regularizer ($\\lambda$).\ntraining_batch_size: Training batch size.\nlearning_rate: Learning rate for Adam optimizer.\nvalidation_fraction: The fraction of data to use for validation.\nstop_after_epochs: The number of epochs to wait for improvement on the\n    validation set before terminating training.\nmax_num_epochs: Maximum number of epochs to run. If reached, we stop\n    training even when the validation loss is still decreasing. Otherwise,\n    we train until validation loss increases (see also `stop_after_epochs`).\nclip_max_norm: Value at which to clip the total gradient norm in order to\n    prevent exploding gradients. Use None for no clipping.\nexclude_invalid_x: Whether to exclude simulation outputs `x=NaN` or `x=\u00b1\u221e`\n    during training. Expect errors, silent or explicit, when `False`.\nresume_training: Can be used in case training time is limited, e.g. on a\n    cluster. If `True`, the split between train and validation set, the\n    optimizer, the number of epochs, and the best validation log-prob will\n    be restored from the last time `.train()` was called.\ndiscard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n    from the prior. Training may be sped up by ignoring such less targeted\n    samples.\nretrain_from_scratch: Whether to retrain the conditional density\n    estimator for the posterior from scratch each round.\nshow_train_summary: Whether to print the number of epochs and validation\n    loss and leakage after the training.\ndataloader_kwargs: Additional or updated kwargs to be passed to the training\n    and validation dataloaders (like, e.g., a collate_fn)\n</code></pre> <p>Returns:     Classifier that approximates the ratio \\(p(\\theta,x)/p(\\theta)p(x)\\).</p> Source code in <code>sbi/inference/trainers/nre/bnre.py</code> <pre><code>def train(\n    self,\n    regularization_strength: float = 100.0,\n    training_batch_size: int = 200,\n    learning_rate: float = 5e-4,\n    validation_fraction: float = 0.1,\n    stop_after_epochs: int = 20,\n    max_num_epochs: int = 2**31 - 1,\n    clip_max_norm: Optional[float] = 5.0,\n    resume_training: bool = False,\n    discard_prior_samples: bool = False,\n    retrain_from_scratch: bool = False,\n    show_train_summary: bool = False,\n    dataloader_kwargs: Optional[Dict] = None,\n) -&gt; nn.Module:\n    r\"\"\"Return classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n    Args:\n\n        regularization_strength: The multiplicative coefficient applied to the\n            balancing regularizer ($\\lambda$).\n        training_batch_size: Training batch size.\n        learning_rate: Learning rate for Adam optimizer.\n        validation_fraction: The fraction of data to use for validation.\n        stop_after_epochs: The number of epochs to wait for improvement on the\n            validation set before terminating training.\n        max_num_epochs: Maximum number of epochs to run. If reached, we stop\n            training even when the validation loss is still decreasing. Otherwise,\n            we train until validation loss increases (see also `stop_after_epochs`).\n        clip_max_norm: Value at which to clip the total gradient norm in order to\n            prevent exploding gradients. Use None for no clipping.\n        exclude_invalid_x: Whether to exclude simulation outputs `x=NaN` or `x=\u00b1\u221e`\n            during training. Expect errors, silent or explicit, when `False`.\n        resume_training: Can be used in case training time is limited, e.g. on a\n            cluster. If `True`, the split between train and validation set, the\n            optimizer, the number of epochs, and the best validation log-prob will\n            be restored from the last time `.train()` was called.\n        discard_prior_samples: Whether to discard samples simulated in round 1, i.e.\n            from the prior. Training may be sped up by ignoring such less targeted\n            samples.\n        retrain_from_scratch: Whether to retrain the conditional density\n            estimator for the posterior from scratch each round.\n        show_train_summary: Whether to print the number of epochs and validation\n            loss and leakage after the training.\n        dataloader_kwargs: Additional or updated kwargs to be passed to the training\n            and validation dataloaders (like, e.g., a collate_fn)\n    Returns:\n        Classifier that approximates the ratio $p(\\theta,x)/p(\\theta)p(x)$.\n    \"\"\"\n    kwargs = del_entries(locals(), entries=(\"self\", \"__class__\"))\n    kwargs[\"loss_kwargs\"] = {\n        \"regularization_strength\": kwargs.pop(\"regularization_strength\")\n    }\n    return super().train(**kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.mcabc.MCABC","title":"<code>MCABC</code>","text":"<p>               Bases: <code>ABCBASE</code></p> <p>Monte-Carlo Approximate Bayesian Computation (Rejection ABC).</p> Source code in <code>sbi/inference/abc/mcabc.py</code> <pre><code>class MCABC(ABCBASE):\n    \"\"\"Monte-Carlo Approximate Bayesian Computation (Rejection ABC).\"\"\"\n\n    def __init__(\n        self,\n        simulator: Callable,\n        prior,\n        distance: Union[str, Callable] = \"l2\",\n        requires_iid_data: Optional[None] = None,\n        distance_kwargs: Optional[Dict] = None,\n        num_workers: int = 1,\n        simulation_batch_size: int = 1,\n        distance_batch_size: int = -1,\n        show_progress_bars: bool = True,\n    ):\n        r\"\"\"Monte-Carlo Approximate Bayesian Computation (Rejection ABC) [1].\n\n        [1] Pritchard, J. K., Seielstad, M. T., Perez-Lezaun, A., &amp; Feldman, M. W.\n        (1999). Population growth of human Y chromosomes: a study of Y chromosome\n        microsatellites. Molecular biology and evolution, 16(12), 1791-1798.\n\n        Args:\n            simulator: A function that takes parameters $\\theta$ and maps them to\n                simulations, or observations, `x`, $\\mathrm{sim}(\\theta)\\to x$. Any\n                regular Python callable (i.e. function or class with `__call__` method)\n                can be used.\n            prior: A probability distribution that expresses prior knowledge about the\n                parameters, e.g. which ranges are meaningful for them. Any\n                object with `.log_prob()`and `.sample()` (for example, a PyTorch\n                distribution) can be used.\n            distance: Distance function to compare observed and simulated data. Can be\n                a custom callable function or one of `l1`, `l2`, `mse`,\n                `mmd`, `wasserstein`.\n            requires_iid_data: Whether to allow conditioning on iid sampled data or not.\n                Typically, this information is inferred by the choice of the distance,\n                but in case a custom distance is used, this information is pivotal.\n            distance_kwargs: Configurations parameters for the distances. In particular\n                useful for the MMD and Wasserstein distance.\n            num_workers: Number of parallel workers to use for simulations.\n            simulation_batch_size: Number of parameter sets that the simulator\n                maps to data x at once. If None, we simulate all parameter sets at the\n                same time. If &gt;= 1, the simulator has to process data of shape\n                (simulation_batch_size, parameter_dimension).\n            distance_batch_size: Number of simulations that the distance function\n                evaluates against the reference observations at once. If -1, we evaluate\n                all simulations at the same time.\n        \"\"\"\n\n        super().__init__(\n            simulator=simulator,\n            prior=prior,\n            distance=distance,\n            requires_iid_data=requires_iid_data,\n            distance_kwargs=distance_kwargs,\n            num_workers=num_workers,\n            simulation_batch_size=simulation_batch_size,\n            distance_batch_size=distance_batch_size,\n            show_progress_bars=show_progress_bars,\n        )\n\n    def __call__(\n        self,\n        x_o: Union[Tensor, ndarray],\n        num_simulations: int,\n        eps: Optional[float] = None,\n        quantile: Optional[float] = None,\n        lra: bool = False,\n        sass: bool = False,\n        sass_fraction: float = 0.25,\n        sass_expansion_degree: int = 1,\n        kde: bool = False,\n        kde_kwargs: Optional[Dict[str, Any]] = None,\n        return_summary: bool = False,\n        num_iid_samples: int = 1,\n    ) -&gt; Union[Tuple[Tensor, dict], Tuple[KDEWrapper, dict], Tensor, KDEWrapper]:\n        r\"\"\"Run MCABC and return accepted parameters or KDE object fitted on them.\n\n        Args:\n            x_o: Observed data.\n            num_simulations: Number of simulations to run.\n            eps: Acceptance threshold $\\epsilon$ for distance between observed and\n                simulated data.\n            quantile: Upper quantile of smallest distances for which the corresponding\n                parameters are returned, e.g, q=0.01 will return the top 1%. Exactly\n                one of quantile or `eps` have to be passed.\n            lra: Whether to run linear regression adjustment as in Beaumont et al. 2002\n            sass: Whether to determine semi-automatic summary statistics as in\n                Fearnhead &amp; Prangle 2012.\n            sass_fraction: Fraction of simulation budget used for the initial sass run.\n            sass_expansion_degree: Degree of the polynomial feature expansion for the\n                sass regression, default 1 - no expansion.\n            kde: Whether to run KDE on the accepted parameters to return a KDE\n                object from which one can sample.\n            kde_kwargs: kwargs for performing KDE:\n                'bandwidth='; either a float, or a string naming a bandwidth\n                heuristics, e.g., 'cv' (cross validation), 'silvermann' or 'scott',\n                default 'cv'.\n                'transform': transform applied to the parameters before doing KDE.\n                'sample_weights': weights associated with samples. See 'get_kde' for\n                more details\n            return_summary: Whether to return the distances and data corresponding to\n                the accepted parameters.\n            num_iid_samples: Number of simulations per parameter. Choose\n                `num_iid_samples&gt;1`, if you have chosen a statistical distance that\n                evaluates sets of simulations against a set of reference observations\n                instead of a single data-point comparison.\n\n        Returns:\n            theta (if kde False): accepted parameters\n            kde (if kde True): KDE object based on accepted parameters from which one\n                can .sample() and .log_prob().\n            summary (if summary True): dictionary containing the accepted paramters (if\n                kde True), distances and simulated data x.\n        \"\"\"\n\n        # Exactly one of eps or quantile need to be passed.\n        assert (eps is not None) ^ (\n            quantile is not None\n        ), \"Eps or quantile must be passed, but not both.\"\n        if kde_kwargs is None:\n            kde_kwargs = {}\n\n        # Run SASS and change the simulator and x_o accordingly.\n        if sass:\n            num_pilot_simulations = int(sass_fraction * num_simulations)\n            self.logger.info(\n                \"Running SASS with %s pilot samples.\", num_pilot_simulations\n            )\n            num_simulations -= num_pilot_simulations\n\n            pilot_theta = self.prior.sample((num_pilot_simulations,))\n            pilot_x = self._batched_simulator(pilot_theta)\n\n            sass_transform = self.get_sass_transform(\n                pilot_theta, pilot_x, sass_expansion_degree\n            )\n\n            # Add sass transform to simulator and x_o.\n            def simulator(theta):\n                return sass_transform(self._batched_simulator(theta))\n\n            x_o = sass_transform(x_o)\n        else:\n            simulator = self._batched_simulator\n\n        # Simulate and calculate distances.\n        theta = self.prior.sample((num_simulations,))\n        theta_repeat = theta.repeat_interleave(num_iid_samples, dim=0)\n        x = simulator(theta_repeat)\n        x = x.reshape((\n            num_simulations,\n            num_iid_samples,\n            -1,\n        ))  # Dim(num_initial_pop, num_iid_samples, -1)\n\n        # Infer x shape to test and set x_o.\n        if not self.distance.requires_iid_data:\n            x = x.squeeze(1)\n            self.x_shape = x[0].shape\n            self.x_o = process_x(x_o, self.x_shape)\n        else:\n            self.x_shape = x[0, 0].shape\n            self.x_o = process_x(x_o, self.x_shape)\n\n        distances = self.distance(self.x_o, x)\n\n        # Select based on acceptance threshold epsilon.\n        if eps is not None:\n            is_accepted = distances &lt; eps\n            num_accepted = is_accepted.sum().item()\n            assert num_accepted &gt; 0, f\"No parameters accepted, eps={eps} too small\"\n\n            theta_accepted = theta[is_accepted]\n            distances_accepted = distances[is_accepted]\n            x_accepted = x[is_accepted]\n\n        # Select based on quantile on sorted distances.\n        elif quantile is not None:\n            num_top_samples = int(num_simulations * quantile)\n            sort_idx = torch.argsort(distances)\n            theta_accepted = theta[sort_idx][:num_top_samples]\n            distances_accepted = distances[sort_idx][:num_top_samples]\n            x_accepted = x[sort_idx][:num_top_samples]\n\n        else:\n            raise ValueError(\"One of epsilon or quantile has to be passed.\")\n\n        # Maybe adjust theta with LRA.\n        if lra:\n            self.logger.info(\"Running Linear regression adjustment.\")\n            final_theta = self.run_lra(theta_accepted, x_accepted, observation=self.x_o)\n        else:\n            final_theta = theta_accepted\n\n        if kde:\n            self.logger.info(\n                \"\"\"KDE on %s samples with bandwidth option\n                {kde_kwargs[\"bandwidth\"] if \"bandwidth\" in kde_kwargs else \"cv\"}.\n                Beware that KDE can give unreliable results when used with too few\n                samples and in high dimensions.\"\"\",\n                final_theta.shape[0],\n            )\n\n            kde_dist = get_kde(final_theta, **kde_kwargs)\n\n            if return_summary:\n                return (\n                    kde_dist,\n                    dict(theta=final_theta, distances=distances_accepted, x=x_accepted),\n                )\n            else:\n                return kde_dist\n        elif return_summary:\n            return final_theta, dict(distances=distances_accepted, x=x_accepted)\n        else:\n            return final_theta\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.mcabc.MCABC.__call__","title":"<code>__call__(x_o, num_simulations, eps=None, quantile=None, lra=False, sass=False, sass_fraction=0.25, sass_expansion_degree=1, kde=False, kde_kwargs=None, return_summary=False, num_iid_samples=1)</code>","text":"<p>Run MCABC and return accepted parameters or KDE object fitted on them.</p> <p>Parameters:</p> Name Type Description Default <code>x_o</code> <code>Union[Tensor, ndarray]</code> <p>Observed data.</p> required <code>num_simulations</code> <code>int</code> <p>Number of simulations to run.</p> required <code>eps</code> <code>Optional[float]</code> <p>Acceptance threshold \\(\\epsilon\\) for distance between observed and simulated data.</p> <code>None</code> <code>quantile</code> <code>Optional[float]</code> <p>Upper quantile of smallest distances for which the corresponding parameters are returned, e.g, q=0.01 will return the top 1%. Exactly one of quantile or <code>eps</code> have to be passed.</p> <code>None</code> <code>lra</code> <code>bool</code> <p>Whether to run linear regression adjustment as in Beaumont et al. 2002</p> <code>False</code> <code>sass</code> <code>bool</code> <p>Whether to determine semi-automatic summary statistics as in Fearnhead &amp; Prangle 2012.</p> <code>False</code> <code>sass_fraction</code> <code>float</code> <p>Fraction of simulation budget used for the initial sass run.</p> <code>0.25</code> <code>sass_expansion_degree</code> <code>int</code> <p>Degree of the polynomial feature expansion for the sass regression, default 1 - no expansion.</p> <code>1</code> <code>kde</code> <code>bool</code> <p>Whether to run KDE on the accepted parameters to return a KDE object from which one can sample.</p> <code>False</code> <code>kde_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>kwargs for performing KDE: \u2018bandwidth=\u2019; either a float, or a string naming a bandwidth heuristics, e.g., \u2018cv\u2019 (cross validation), \u2018silvermann\u2019 or \u2018scott\u2019, default \u2018cv\u2019. \u2018transform\u2019: transform applied to the parameters before doing KDE. \u2018sample_weights\u2019: weights associated with samples. See \u2018get_kde\u2019 for more details</p> <code>None</code> <code>return_summary</code> <code>bool</code> <p>Whether to return the distances and data corresponding to the accepted parameters.</p> <code>False</code> <code>num_iid_samples</code> <code>int</code> <p>Number of simulations per parameter. Choose <code>num_iid_samples&gt;1</code>, if you have chosen a statistical distance that evaluates sets of simulations against a set of reference observations instead of a single data-point comparison.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>theta</code> <code>if kde False</code> <p>accepted parameters</p> <code>kde</code> <code>if kde True</code> <p>KDE object based on accepted parameters from which one can .sample() and .log_prob().</p> <code>summary</code> <code>if summary True</code> <p>dictionary containing the accepted paramters (if kde True), distances and simulated data x.</p> Source code in <code>sbi/inference/abc/mcabc.py</code> <pre><code>def __call__(\n    self,\n    x_o: Union[Tensor, ndarray],\n    num_simulations: int,\n    eps: Optional[float] = None,\n    quantile: Optional[float] = None,\n    lra: bool = False,\n    sass: bool = False,\n    sass_fraction: float = 0.25,\n    sass_expansion_degree: int = 1,\n    kde: bool = False,\n    kde_kwargs: Optional[Dict[str, Any]] = None,\n    return_summary: bool = False,\n    num_iid_samples: int = 1,\n) -&gt; Union[Tuple[Tensor, dict], Tuple[KDEWrapper, dict], Tensor, KDEWrapper]:\n    r\"\"\"Run MCABC and return accepted parameters or KDE object fitted on them.\n\n    Args:\n        x_o: Observed data.\n        num_simulations: Number of simulations to run.\n        eps: Acceptance threshold $\\epsilon$ for distance between observed and\n            simulated data.\n        quantile: Upper quantile of smallest distances for which the corresponding\n            parameters are returned, e.g, q=0.01 will return the top 1%. Exactly\n            one of quantile or `eps` have to be passed.\n        lra: Whether to run linear regression adjustment as in Beaumont et al. 2002\n        sass: Whether to determine semi-automatic summary statistics as in\n            Fearnhead &amp; Prangle 2012.\n        sass_fraction: Fraction of simulation budget used for the initial sass run.\n        sass_expansion_degree: Degree of the polynomial feature expansion for the\n            sass regression, default 1 - no expansion.\n        kde: Whether to run KDE on the accepted parameters to return a KDE\n            object from which one can sample.\n        kde_kwargs: kwargs for performing KDE:\n            'bandwidth='; either a float, or a string naming a bandwidth\n            heuristics, e.g., 'cv' (cross validation), 'silvermann' or 'scott',\n            default 'cv'.\n            'transform': transform applied to the parameters before doing KDE.\n            'sample_weights': weights associated with samples. See 'get_kde' for\n            more details\n        return_summary: Whether to return the distances and data corresponding to\n            the accepted parameters.\n        num_iid_samples: Number of simulations per parameter. Choose\n            `num_iid_samples&gt;1`, if you have chosen a statistical distance that\n            evaluates sets of simulations against a set of reference observations\n            instead of a single data-point comparison.\n\n    Returns:\n        theta (if kde False): accepted parameters\n        kde (if kde True): KDE object based on accepted parameters from which one\n            can .sample() and .log_prob().\n        summary (if summary True): dictionary containing the accepted paramters (if\n            kde True), distances and simulated data x.\n    \"\"\"\n\n    # Exactly one of eps or quantile need to be passed.\n    assert (eps is not None) ^ (\n        quantile is not None\n    ), \"Eps or quantile must be passed, but not both.\"\n    if kde_kwargs is None:\n        kde_kwargs = {}\n\n    # Run SASS and change the simulator and x_o accordingly.\n    if sass:\n        num_pilot_simulations = int(sass_fraction * num_simulations)\n        self.logger.info(\n            \"Running SASS with %s pilot samples.\", num_pilot_simulations\n        )\n        num_simulations -= num_pilot_simulations\n\n        pilot_theta = self.prior.sample((num_pilot_simulations,))\n        pilot_x = self._batched_simulator(pilot_theta)\n\n        sass_transform = self.get_sass_transform(\n            pilot_theta, pilot_x, sass_expansion_degree\n        )\n\n        # Add sass transform to simulator and x_o.\n        def simulator(theta):\n            return sass_transform(self._batched_simulator(theta))\n\n        x_o = sass_transform(x_o)\n    else:\n        simulator = self._batched_simulator\n\n    # Simulate and calculate distances.\n    theta = self.prior.sample((num_simulations,))\n    theta_repeat = theta.repeat_interleave(num_iid_samples, dim=0)\n    x = simulator(theta_repeat)\n    x = x.reshape((\n        num_simulations,\n        num_iid_samples,\n        -1,\n    ))  # Dim(num_initial_pop, num_iid_samples, -1)\n\n    # Infer x shape to test and set x_o.\n    if not self.distance.requires_iid_data:\n        x = x.squeeze(1)\n        self.x_shape = x[0].shape\n        self.x_o = process_x(x_o, self.x_shape)\n    else:\n        self.x_shape = x[0, 0].shape\n        self.x_o = process_x(x_o, self.x_shape)\n\n    distances = self.distance(self.x_o, x)\n\n    # Select based on acceptance threshold epsilon.\n    if eps is not None:\n        is_accepted = distances &lt; eps\n        num_accepted = is_accepted.sum().item()\n        assert num_accepted &gt; 0, f\"No parameters accepted, eps={eps} too small\"\n\n        theta_accepted = theta[is_accepted]\n        distances_accepted = distances[is_accepted]\n        x_accepted = x[is_accepted]\n\n    # Select based on quantile on sorted distances.\n    elif quantile is not None:\n        num_top_samples = int(num_simulations * quantile)\n        sort_idx = torch.argsort(distances)\n        theta_accepted = theta[sort_idx][:num_top_samples]\n        distances_accepted = distances[sort_idx][:num_top_samples]\n        x_accepted = x[sort_idx][:num_top_samples]\n\n    else:\n        raise ValueError(\"One of epsilon or quantile has to be passed.\")\n\n    # Maybe adjust theta with LRA.\n    if lra:\n        self.logger.info(\"Running Linear regression adjustment.\")\n        final_theta = self.run_lra(theta_accepted, x_accepted, observation=self.x_o)\n    else:\n        final_theta = theta_accepted\n\n    if kde:\n        self.logger.info(\n            \"\"\"KDE on %s samples with bandwidth option\n            {kde_kwargs[\"bandwidth\"] if \"bandwidth\" in kde_kwargs else \"cv\"}.\n            Beware that KDE can give unreliable results when used with too few\n            samples and in high dimensions.\"\"\",\n            final_theta.shape[0],\n        )\n\n        kde_dist = get_kde(final_theta, **kde_kwargs)\n\n        if return_summary:\n            return (\n                kde_dist,\n                dict(theta=final_theta, distances=distances_accepted, x=x_accepted),\n            )\n        else:\n            return kde_dist\n    elif return_summary:\n        return final_theta, dict(distances=distances_accepted, x=x_accepted)\n    else:\n        return final_theta\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.mcabc.MCABC.__init__","title":"<code>__init__(simulator, prior, distance='l2', requires_iid_data=None, distance_kwargs=None, num_workers=1, simulation_batch_size=1, distance_batch_size=-1, show_progress_bars=True)</code>","text":"<p>Monte-Carlo Approximate Bayesian Computation (Rejection ABC) [1].</p> <p>[1] Pritchard, J. K., Seielstad, M. T., Perez-Lezaun, A., &amp; Feldman, M. W. (1999). Population growth of human Y chromosomes: a study of Y chromosome microsatellites. Molecular biology and evolution, 16(12), 1791-1798.</p> <p>Parameters:</p> Name Type Description Default <code>simulator</code> <code>Callable</code> <p>A function that takes parameters \\(\\theta\\) and maps them to simulations, or observations, <code>x</code>, \\(\\mathrm{sim}(\\theta)\\to x\\). Any regular Python callable (i.e. function or class with <code>__call__</code> method) can be used.</p> required <code>prior</code> <p>A probability distribution that expresses prior knowledge about the parameters, e.g. which ranges are meaningful for them. Any object with <code>.log_prob()</code>and <code>.sample()</code> (for example, a PyTorch distribution) can be used.</p> required <code>distance</code> <code>Union[str, Callable]</code> <p>Distance function to compare observed and simulated data. Can be a custom callable function or one of <code>l1</code>, <code>l2</code>, <code>mse</code>, <code>mmd</code>, <code>wasserstein</code>.</p> <code>'l2'</code> <code>requires_iid_data</code> <code>Optional[None]</code> <p>Whether to allow conditioning on iid sampled data or not. Typically, this information is inferred by the choice of the distance, but in case a custom distance is used, this information is pivotal.</p> <code>None</code> <code>distance_kwargs</code> <code>Optional[Dict]</code> <p>Configurations parameters for the distances. In particular useful for the MMD and Wasserstein distance.</p> <code>None</code> <code>num_workers</code> <code>int</code> <p>Number of parallel workers to use for simulations.</p> <code>1</code> <code>simulation_batch_size</code> <code>int</code> <p>Number of parameter sets that the simulator maps to data x at once. If None, we simulate all parameter sets at the same time. If &gt;= 1, the simulator has to process data of shape (simulation_batch_size, parameter_dimension).</p> <code>1</code> <code>distance_batch_size</code> <code>int</code> <p>Number of simulations that the distance function evaluates against the reference observations at once. If -1, we evaluate all simulations at the same time.</p> <code>-1</code> Source code in <code>sbi/inference/abc/mcabc.py</code> <pre><code>def __init__(\n    self,\n    simulator: Callable,\n    prior,\n    distance: Union[str, Callable] = \"l2\",\n    requires_iid_data: Optional[None] = None,\n    distance_kwargs: Optional[Dict] = None,\n    num_workers: int = 1,\n    simulation_batch_size: int = 1,\n    distance_batch_size: int = -1,\n    show_progress_bars: bool = True,\n):\n    r\"\"\"Monte-Carlo Approximate Bayesian Computation (Rejection ABC) [1].\n\n    [1] Pritchard, J. K., Seielstad, M. T., Perez-Lezaun, A., &amp; Feldman, M. W.\n    (1999). Population growth of human Y chromosomes: a study of Y chromosome\n    microsatellites. Molecular biology and evolution, 16(12), 1791-1798.\n\n    Args:\n        simulator: A function that takes parameters $\\theta$ and maps them to\n            simulations, or observations, `x`, $\\mathrm{sim}(\\theta)\\to x$. Any\n            regular Python callable (i.e. function or class with `__call__` method)\n            can be used.\n        prior: A probability distribution that expresses prior knowledge about the\n            parameters, e.g. which ranges are meaningful for them. Any\n            object with `.log_prob()`and `.sample()` (for example, a PyTorch\n            distribution) can be used.\n        distance: Distance function to compare observed and simulated data. Can be\n            a custom callable function or one of `l1`, `l2`, `mse`,\n            `mmd`, `wasserstein`.\n        requires_iid_data: Whether to allow conditioning on iid sampled data or not.\n            Typically, this information is inferred by the choice of the distance,\n            but in case a custom distance is used, this information is pivotal.\n        distance_kwargs: Configurations parameters for the distances. In particular\n            useful for the MMD and Wasserstein distance.\n        num_workers: Number of parallel workers to use for simulations.\n        simulation_batch_size: Number of parameter sets that the simulator\n            maps to data x at once. If None, we simulate all parameter sets at the\n            same time. If &gt;= 1, the simulator has to process data of shape\n            (simulation_batch_size, parameter_dimension).\n        distance_batch_size: Number of simulations that the distance function\n            evaluates against the reference observations at once. If -1, we evaluate\n            all simulations at the same time.\n    \"\"\"\n\n    super().__init__(\n        simulator=simulator,\n        prior=prior,\n        distance=distance,\n        requires_iid_data=requires_iid_data,\n        distance_kwargs=distance_kwargs,\n        num_workers=num_workers,\n        simulation_batch_size=simulation_batch_size,\n        distance_batch_size=distance_batch_size,\n        show_progress_bars=show_progress_bars,\n    )\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.smcabc.SMCABC","title":"<code>SMCABC</code>","text":"<p>               Bases: <code>ABCBASE</code></p> <p>Sequential Monte Carlo Approximate Bayesian Computation.</p> Source code in <code>sbi/inference/abc/smcabc.py</code> <pre><code>class SMCABC(ABCBASE):\n    \"\"\"Sequential Monte Carlo Approximate Bayesian Computation.\"\"\"\n\n    def __init__(\n        self,\n        simulator: Callable,\n        prior: Distribution,\n        distance: Union[str, Callable] = \"l2\",\n        requires_iid_data: Optional[None] = None,\n        distance_kwargs: Optional[Dict] = None,\n        num_workers: int = 1,\n        simulation_batch_size: int = 1,\n        distance_batch_size: int = -1,\n        show_progress_bars: bool = True,\n        kernel: Optional[str] = \"gaussian\",\n        algorithm_variant: str = \"C\",\n    ):\n        r\"\"\"Sequential Monte Carlo Approximate Bayesian Computation.\n\n        We distinguish between three different SMC methods here:\n            - A: Toni et al. 2010 (Phd Thesis)\n            - B: Sisson et al. 2007 (with correction from 2009)\n            - C: Beaumont et al. 2009\n\n        In Toni et al. 2010 we find an overview of the differences on page 34:\n            - B: same as A except for resampling of weights if the effective sampling\n                size is too small.\n            - C: same as A except for calculation of the covariance of the perturbation\n                kernel: the kernel covariance is a scaled version of the covariance of\n                the previous population.\n\n        Args:\n            simulator: A function that takes parameters $\\theta$ and maps them to\n                simulations, or observations, `x`, $\\mathrm{sim}(\\theta)\\to x$. Any\n                regular Python callable (i.e. function or class with `__call__` method)\n                can be used.\n            prior: A probability distribution that expresses prior knowledge about the\n                parameters, e.g. which ranges are meaningful for them. Any\n                object with `.log_prob()`and `.sample()` (for example, a PyTorch\n                distribution) can be used.\n            distance: Distance function to compare observed and simulated data. Can be\n                a custom callable function or one of `l1`, `l2`, `mse`,\n                `mmd`, `wasserstein`.\n            requires_iid_data: Whether to allow conditioning on iid sampled data or not.\n                Typically, this information is inferred by the choice of the distance,\n                but in case a custom distance is used, this information is pivotal.\n            distance_kwargs: Configurations parameters for the distances. In particular\n                useful for the MMD and Wasserstein distance.\n            num_workers: Number of parallel workers to use for simulations.\n            simulation_batch_size: Number of parameter sets that the simulator\n                maps to data x at once. If None, we simulate all parameter sets at the\n                same time. If &gt;= 1, the simulator has to process data of shape\n                (simulation_batch_size, parameter_dimension).\n            distance_batch_size: Number of simulations that the distance function\n                evaluates against the reference observations at once. If -1, we evaluate\n                all simulations at the same time.\n            show_progress_bars: Whether to show a progressbar during simulation and\n                sampling.\n            kernel: Perturbation kernel.\n            algorithm_variant: Indicating the choice of algorithm variant, A, B, or C.\n        \"\"\"\n\n        super().__init__(\n            simulator=simulator,\n            prior=prior,\n            distance=distance,\n            requires_iid_data=requires_iid_data,\n            distance_kwargs=distance_kwargs,\n            num_workers=num_workers,\n            simulation_batch_size=simulation_batch_size,\n            distance_batch_size=distance_batch_size,\n            show_progress_bars=show_progress_bars,\n        )\n\n        kernels = (\"gaussian\", \"uniform\")\n        assert (\n            kernel in kernels\n        ), f\"Kernel '{kernel}' not supported. Choose one from {kernels}.\"\n        self.kernel = kernel\n\n        algorithm_variants = (\"A\", \"B\", \"C\")\n        assert algorithm_variant in algorithm_variants, (\n            f\"SMCABC variant '{algorithm_variant}' not supported, choose one from\"\n            \" {algorithm_variants}.\"\n        )\n        self.algorithm_variant = algorithm_variant\n        self.distance_to_x0 = None\n        self.simulation_counter = 0\n        self.num_simulations = 0\n        self.kernel_variance = None\n\n        # Define simulator that keeps track of budget.\n        def simulate_with_budget(theta):\n            self.simulation_counter += theta.shape[0]\n            return self._batched_simulator(theta)\n\n        self._simulate_with_budget = simulate_with_budget\n\n    def __call__(\n        self,\n        x_o: Union[Tensor, ndarray],\n        num_particles: int,\n        num_initial_pop: int,\n        num_simulations: int,\n        epsilon_decay: float,\n        distance_based_decay: bool = False,\n        ess_min: Optional[float] = None,\n        kernel_variance_scale: float = 1.0,\n        use_last_pop_samples: bool = True,\n        return_summary: bool = False,\n        kde: bool = False,\n        kde_kwargs: Optional[Dict[str, Any]] = None,\n        kde_sample_weights: bool = False,\n        lra: bool = False,\n        lra_with_weights: bool = False,\n        sass: bool = False,\n        sass_fraction: float = 0.25,\n        sass_expansion_degree: int = 1,\n        num_iid_samples: int = 1,\n    ) -&gt; Union[Tensor, KDEWrapper, Tuple[Tensor, dict], Tuple[KDEWrapper, dict]]:\n        r\"\"\"Run SMCABC and return accepted parameters or KDE object fitted on them.\n\n        Args:\n            x_o: Observed data.\n            num_particles: Number of particles in each population.\n            num_initial_pop: Number of simulations used for initial population.\n            num_simulations: Total number of possible simulations.\n            epsilon_decay: Factor with which the acceptance threshold $\\epsilon$ decays.\n            distance_based_decay: Whether the $\\epsilon$ decay is constant over\n                populations or calculated from the previous populations distribution of\n                distances.\n            ess_min: Threshold of effective sampling size for resampling weights. Not\n                used when None (default).\n            kernel_variance_scale: Factor for scaling the perturbation kernel variance.\n            use_last_pop_samples: Whether to fill up the current population with\n                samples from the previous population when the budget is used up. If\n                False, the current population is discarded and the previous population\n                is returned.\n            lra: Whether to run linear regression adjustment as in Beaumont et al. 2002\n            lra_with_weights: Whether to run lra as weighted linear regression with SMC\n                weights\n            sass: Whether to determine semi-automatic summary statistics (sass) as in\n                Fearnhead &amp; Prangle 2012.\n            sass_fraction: Fraction of simulation budget used for the initial sass run.\n            sass_expansion_degree: Degree of the polynomial feature expansion for the\n                sass regression, default 1 - no expansion.\n            kde: Whether to run KDE on the accepted parameters to return a KDE\n                object from which one can sample.\n            kde_kwargs: kwargs for performing KDE:\n                'bandwidth='; either a float, or a string naming a bandwidth\n                heuristics, e.g., 'cv' (cross validation), 'silvermann' or 'scott',\n                default 'cv'.\n                'transform': transform applied to the parameters before doing KDE.\n                'sample_weights': weights associated with samples. See 'get_kde' for\n                more details\n            kde_sample_weights: Whether perform weighted KDE with SMC weights or on raw\n                particles.\n            return_summary: Whether to return a dictionary with all accepted particles,\n                weights, etc. at the end.\n            num_iid_samples: Number of simulations per parameter. Choose\n                `num_iid_samples&gt;1`, if you have chosen a statistical distance that\n                evaluates sets of simulations against a set of reference observations\n                instead of a single data-point comparison.\n\n        Returns:\n            theta (if kde False): accepted parameters of the last population.\n            kde (if kde True): KDE object fitted on accepted parameters, from which one\n                can .sample() and .log_prob().\n            summary (if return_summary True): dictionary containing the accepted\n                paramters (if kde True), distances and simulated data x of all\n                populations.\n        \"\"\"\n\n        pop_idx = 0\n        self.num_simulations = num_simulations * num_iid_samples\n        if kde_kwargs is None:\n            kde_kwargs = {}\n        assert isinstance(epsilon_decay, float) and epsilon_decay &gt; 0.0\n        assert not (\n            self.distance.requires_iid_data and lra\n        ), \"Currently there is no support to run inference \"\n        \"on multiple observations together with lra.\"\n        assert not (\n            self.distance.requires_iid_data and sass\n        ), \"Currently there is no support to run inference \"\n        \"on multiple observations together with sass.\"\n\n        # Pilot run for SASS.\n        if sass:\n            num_pilot_simulations = int(sass_fraction * num_simulations)\n            self.logger.info(\n                \"Running SASS with %s pilot samples.\", num_pilot_simulations\n            )\n            sass_transform = self.run_sass_set_xo(\n                num_particles,\n                num_pilot_simulations,\n                x_o,\n                num_iid_samples,\n                lra,\n                sass_expansion_degree,\n            )\n            # Udpate simulator and xo\n            x_o = sass_transform(self.x_o)\n\n            def sass_simulator(theta):\n                self.simulation_counter += theta.shape[0]\n                return sass_transform(self._batched_simulator(theta))\n\n            self._simulate_with_budget = sass_simulator\n\n        # run initial population\n        particles, epsilon, distances, x = self._set_xo_and_sample_initial_population(\n            x_o, num_particles, num_initial_pop, num_iid_samples\n        )\n        log_weights = torch.log(1 / num_particles * torch.ones(num_particles))\n\n        self.logger.info((\n            \"population=%s, eps=%s, ess=%s, num_sims=%s\",\n            pop_idx,\n            epsilon,\n            1.0,\n            num_initial_pop,\n        ))\n\n        all_particles = [particles]\n        all_log_weights = [log_weights]\n        all_distances = [distances]\n        all_epsilons = [epsilon]\n        all_x = [x]\n\n        while self.simulation_counter &lt; self.num_simulations:\n            pop_idx += 1\n            # Decay based on quantile of distances from previous pop.\n            if distance_based_decay:\n                epsilon = self._get_next_epsilon(\n                    all_distances[pop_idx - 1], epsilon_decay\n                )\n            # Constant decay.\n            else:\n                epsilon *= epsilon_decay\n\n            # Get kernel variance from previous pop.\n            self.kernel_variance = self.get_kernel_variance(\n                all_particles[pop_idx - 1],\n                torch.exp(all_log_weights[pop_idx - 1]),\n                samples_per_dim=500,\n                kernel_variance_scale=kernel_variance_scale,\n            )\n            particles, log_weights, distances, x = self._sample_next_population(\n                particles=all_particles[pop_idx - 1],\n                log_weights=all_log_weights[pop_idx - 1],\n                distances=all_distances[pop_idx - 1],\n                epsilon=epsilon,\n                x=all_x[pop_idx - 1],\n                num_iid_samples=num_iid_samples,\n                use_last_pop_samples=use_last_pop_samples,\n            )\n\n            # Resample population if effective sampling size is too small.\n            if ess_min is not None:\n                particles, log_weights = self.resample_if_ess_too_small(\n                    particles, log_weights, ess_min, pop_idx\n                )\n\n            self.logger.info((\n                \"population=%s done: eps={epsilon:.6f}, num_sims=%s.\",\n                pop_idx,\n                epsilon,\n                self.simulation_counter,\n            ))\n\n            # collect results\n            all_particles.append(particles)\n            all_log_weights.append(log_weights)\n            all_distances.append(distances)\n            all_epsilons.append(epsilon)\n            all_x.append(x)\n\n        # Maybe run LRA and adjust weights.\n        if lra:\n            self.logger.info(\"Running Linear regression adjustment.\")\n            adjusted_particles, _ = self.run_lra_update_weights(\n                particles=all_particles[-1],\n                xs=all_x[-1],\n                observation=process_x(x_o),\n                log_weights=all_log_weights[-1],\n                lra_with_weights=lra_with_weights,\n            )\n            final_particles = adjusted_particles\n        else:\n            final_particles = all_particles[-1]\n\n        if kde:\n            self.logger.info(\n                \"\"\"KDE on %s samples with bandwidth option %s. Beware that KDE can give\n                unreliable results when used with too few samples and in high\n                dimensions.\"\"\",\n                final_particles.shape[0],\n                kde_kwargs.get(\"bandwidth\", \"cv\"),\n            )\n            # Maybe get particles weights from last population for weighted KDE.\n            if kde_sample_weights:\n                kde_kwargs[\"sample_weights\"] = all_log_weights[-1].exp()\n\n            kde_dist = get_kde(final_particles, **kde_kwargs)\n\n            if return_summary:\n                return (\n                    kde_dist,\n                    dict(\n                        particles=all_particles,\n                        weights=all_log_weights,\n                        epsilons=all_epsilons,\n                        distances=all_distances,\n                        xs=all_x,\n                    ),\n                )\n            else:\n                return kde_dist\n\n        if return_summary:\n            return (\n                final_particles,\n                dict(\n                    particles=all_particles,\n                    weights=all_log_weights,\n                    epsilons=all_epsilons,\n                    distances=all_distances,\n                    xs=all_x,\n                ),\n            )\n        else:\n            return final_particles\n\n    def _set_xo_and_sample_initial_population(\n        self,\n        x_o: Array,\n        num_particles: int,\n        num_initial_pop: int,\n        num_iid_samples: int,\n    ) -&gt; Tuple[Tensor, float, Tensor, Tensor]:\n        \"\"\"Return particles, epsilon and distances of initial population.\"\"\"\n\n        assert (\n            num_particles &lt;= num_initial_pop\n        ), \"number of initial round simulations must be greater than population size\"\n\n        assert (x_o.shape[0] == 1) or self.distance.requires_iid_data, (\n            \"Your data contain iid data-points, but the choice of \"\n            \"your distance does not allow multiple conditioning \"\n            \"observations.\"\n        )\n\n        theta = self.prior.sample((num_initial_pop,))\n\n        theta_repeat = theta.repeat_interleave(num_iid_samples, dim=0)\n        x = self._simulate_with_budget(theta_repeat)\n        x = x.reshape((\n            num_initial_pop,\n            num_iid_samples,\n            -1,\n        ))  # Dim(num_initial_pop, num_iid_samples, -1)\n\n        # Infer x shape to test and set x_o.\n        if not self.distance.requires_iid_data:\n            x = x.squeeze(1)\n            self.x_shape = x[0].shape\n        else:\n            self.x_shape = x[0, 0].shape\n        self.x_o = process_x(x_o, self.x_shape)\n\n        distances = self.distance(self.x_o, x)\n        sortidx = torch.argsort(distances)\n        particles = theta[sortidx][:num_particles]\n        # Take last accepted distance as epsilon.\n        initial_epsilon = distances[sortidx][num_particles - 1].item()\n\n        if not math.isfinite(initial_epsilon):\n            initial_epsilon = 1e8\n\n        return (\n            particles,\n            initial_epsilon,\n            distances[sortidx][:num_particles],\n            x[sortidx][:num_particles],\n        )\n\n    def _sample_next_population(\n        self,\n        particles: Tensor,\n        log_weights: Tensor,\n        distances: Tensor,\n        epsilon: float,\n        x: Tensor,\n        num_iid_samples: int,\n        use_last_pop_samples: bool = True,\n    ) -&gt; Tuple[Tensor, Tensor, Tensor, Tensor]:\n        \"\"\"Return particles, weights and distances of new population.\"\"\"\n\n        new_particles = []\n        new_log_weights = []\n        new_distances = []\n        new_x = []\n\n        num_accepted_particles = 0\n        num_particles = particles.shape[0]\n\n        while num_accepted_particles &lt; num_particles:\n            # Upperbound for batch size to not exceed simulation budget.\n            num_batch = min(\n                num_particles - num_accepted_particles,\n                self.num_simulations - self.simulation_counter,\n            )\n\n            # Sample from previous population and perturb.\n            particle_candidates = self._sample_and_perturb(\n                particles, torch.exp(log_weights), num_samples=num_batch\n            )\n            # Simulate and select based on distance.\n            candidates_repeated = particle_candidates.repeat_interleave(\n                num_iid_samples, dim=0\n            )\n            x_candidates = self._simulate_with_budget(candidates_repeated)\n            x_candidates = x_candidates.reshape((\n                num_batch,\n                num_iid_samples,\n                -1,\n            ))  # Dim(num_initial_pop, num_iid_samples, -1)\n            if not self.distance.requires_iid_data:\n                x_candidates = x_candidates.squeeze(1)\n\n            dists = self.distance(self.x_o, x_candidates)\n            is_accepted = dists &lt;= epsilon\n            num_accepted_batch = int(is_accepted.sum().item())\n\n            if num_accepted_batch &gt; 0:\n                new_particles.append(particle_candidates[is_accepted])\n                new_log_weights.append(\n                    self._calculate_new_log_weights(\n                        particle_candidates[is_accepted],\n                        particles,\n                        log_weights,\n                    )\n                )\n                new_distances.append(dists[is_accepted])\n                new_x.append(x_candidates[is_accepted])\n                num_accepted_particles += num_accepted_batch\n\n            # If simulation budget was exceeded and we still need particles, take\n            # previous population or fill up with previous population.\n            if (\n                self.simulation_counter &gt;= self.num_simulations\n                and num_accepted_particles &lt; num_particles\n            ):\n                if use_last_pop_samples:\n                    num_remaining = num_particles - num_accepted_particles\n                    self.logger.info(\n                        \"\"\"Simulation Budget exceeded, filling up with %s\n                        samples from last population.\"\"\",\n                        num_remaining,\n                    )\n                    # Some new particles have been accepted already, therefore\n                    # fill up the remaining once with old particles and weights.\n                    new_particles.append(particles[:num_remaining, :])\n                    # Recalculate weights with new particles.\n                    new_log_weights = [\n                        self._calculate_new_log_weights(\n                            torch.cat(new_particles),\n                            particles,\n                            log_weights,\n                        )\n                    ]\n                    new_distances.append(distances[:num_remaining])\n                    new_x.append(x[:num_remaining])\n                else:\n                    self.logger.info(\n                        \"Simulation Budget exceeded, returning previous population.\"\n                    )\n                    new_particles = [particles]\n                    new_log_weights = [log_weights]\n                    new_distances = [distances]\n                    new_x = [x]\n\n                break\n\n        # collect lists of tensors into tensors\n        new_particles = torch.cat(new_particles)\n        new_log_weights = torch.cat(new_log_weights)\n        new_distances = torch.cat(new_distances)\n        new_x = torch.cat(new_x)\n\n        # normalize the new weights\n        new_log_weights -= torch.logsumexp(new_log_weights, dim=0)\n\n        # Return sorted wrt distances.\n        sort_idx = torch.argsort(new_distances)\n\n        return (\n            new_particles[sort_idx],\n            new_log_weights[sort_idx],\n            new_distances[sort_idx],\n            new_x[sort_idx],\n        )\n\n    def _get_next_epsilon(self, distances: Tensor, quantile: float) -&gt; float:\n        \"\"\"Return epsilon for next round based on quantile of this round's distances.\n\n        Note: distances are made unique to avoid repeated distances from simulations\n        that result in the same observation.\n\n        Args:\n            distances: The distances accepted in this round.\n            quantile: Quantile in the distance distribution to determine new epsilon.\n\n        Returns:\n            epsilon: Epsilon for the next population.\n        \"\"\"\n        # Take unique distances to skip same distances simulations (return is sorted).\n        distances = torch.unique(distances)\n        # Cumsum as cdf proxy.\n        distances_cdf = torch.cumsum(distances, dim=0) / distances.sum()\n        # Take the q quantile of distances.\n        try:\n            qidx = torch.where(distances_cdf &gt;= quantile)[0][0]\n        except IndexError:\n            self.logger.warning((\n                \"\"\"Accepted unique distances=%s don't match quantile=%s. Selecting\n                    last distance.\"\"\",\n                distances,\n                quantile,\n            ))\n            qidx = -1\n\n        # The new epsilon is given by that distance.\n        return distances[qidx].item()\n\n    def _calculate_new_log_weights(\n        self,\n        new_particles: Tensor,\n        old_particles: Tensor,\n        old_log_weights: Tensor,\n    ) -&gt; Tensor:\n        \"\"\"Return new log weights following formulas in publications A,B anc C.\"\"\"\n\n        # Prior can be batched across new particles.\n        prior_log_probs = self.prior.log_prob(new_particles)\n\n        # Contstruct function to get kernel log prob for given old particle.\n        # The kernel is centered on each old particle as in all three variants (A,B,C).\n        def kernel_log_prob(new_particle):\n            return self.get_new_kernel(old_particles).log_prob(new_particle)\n\n        # We still have to loop over particles here because\n        # the kernel log probs are already batched across old particles.\n        log_weighted_sum = torch.tensor(\n            [\n                torch.logsumexp(old_log_weights + kernel_log_prob(new_particle), dim=0)\n                for new_particle in new_particles\n            ],\n            dtype=torch.float32,\n        )\n        # new weights are prior probs over weighted sum:\n        return prior_log_probs - log_weighted_sum\n\n    @staticmethod\n    def sample_from_population_with_weights(\n        particles: Tensor, weights: Tensor, num_samples: int = 1\n    ) -&gt; Tensor:\n        \"\"\"Return samples from particles sampled with weights.\"\"\"\n\n        # define multinomial with weights as probs\n        multi = Multinomial(probs=weights)\n        # sample num samples, with replacement\n        samples = multi.sample(sample_shape=torch.Size((num_samples,)))\n        # get indices of success trials\n        indices = torch.where(samples)[1]\n        # return those indices from trace\n        return particles[indices]\n\n    def _sample_and_perturb(\n        self, particles: Tensor, weights: Tensor, num_samples: int = 1\n    ) -&gt; Tensor:\n        \"\"\"Sample and perturb batch of new parameters from trace.\n\n        Reject sampled and perturbed parameters outside of prior.\n        \"\"\"\n\n        num_accepted = 0\n        parameters = []\n        while num_accepted &lt; num_samples:\n            parms = self.sample_from_population_with_weights(\n                particles, weights, num_samples=num_samples - num_accepted\n            )\n\n            # Create kernel on params and perturb.\n            parms_perturbed = self.get_new_kernel(parms).sample()\n\n            is_within_prior = within_support(self.prior, parms_perturbed)\n            num_accepted += int(is_within_prior.sum().item())\n\n            if num_accepted &gt; 0:\n                parameters.append(parms_perturbed[is_within_prior])\n\n        return torch.cat(parameters)\n\n    def get_kernel_variance(\n        self,\n        particles: Tensor,\n        weights: Tensor,\n        samples_per_dim: int = 100,\n        kernel_variance_scale: float = 1.0,\n    ) -&gt; Tensor:\n        \"\"\"Return kernel variance for a given population of particles and weights.\"\"\"\n        if self.kernel == \"gaussian\":\n            # For variant C, Beaumont et al. 2009, the kernel variance comes from the\n            # previous population.\n            if self.algorithm_variant == \"C\":\n                # Calculate weighted covariance of particles.\n                population_cov = torch.tensor(\n                    np.atleast_2d(np.cov(particles, rowvar=False, aweights=weights)),\n                    dtype=torch.float32,\n                )\n                # Make sure variance is nonsingular.\n                try:\n                    torch.linalg.cholesky(kernel_variance_scale * population_cov)\n                except RuntimeError:\n                    self.logger.warning(\n                        \"\"\"\"Singular particle covariance, using unit covariance.\"\"\"\n                    )\n                    population_cov = torch.eye(particles.shape[1])\n                return kernel_variance_scale * population_cov\n            # While for Toni et al. and Sisson et al. it comes from the parameter\n            # ranges.\n            elif self.algorithm_variant in (\"A\", \"B\"):\n                particle_ranges = self.get_particle_ranges(\n                    particles, weights, samples_per_dim=samples_per_dim\n                )\n                return kernel_variance_scale * torch.diag(particle_ranges)\n            else:\n                raise ValueError(f\"Variant, '{self.algorithm_variant}' not supported.\")\n        elif self.kernel == \"uniform\":\n            # Variance spans the range of parameters for every dimension.\n            return kernel_variance_scale * self.get_particle_ranges(\n                particles, weights, samples_per_dim=samples_per_dim\n            )\n        else:\n            raise ValueError(f\"Kernel, '{self.kernel}' not supported.\")\n\n    def get_new_kernel(self, thetas: Tensor) -&gt; Distribution:\n        \"\"\"Return new kernel distribution for a given set of paramters.\"\"\"\n\n        if self.kernel == \"gaussian\":\n            assert self.kernel_variance is not None, \"get kernel variance first.\"\n            assert self.kernel_variance.ndim == 2\n            return MultivariateNormal(\n                loc=thetas, covariance_matrix=self.kernel_variance\n            )\n\n        elif self.kernel == \"uniform\":\n            low = thetas - self.kernel_variance\n            high = thetas + self.kernel_variance\n            # Move batch shape to event shape to get Uniform that is multivariate in\n            # parameter dimension.\n            return BoxUniform(low=low, high=high)\n        else:\n            raise ValueError(f\"Kernel, '{self.kernel}' not supported.\")\n\n    def resample_if_ess_too_small(\n        self,\n        particles: Tensor,\n        log_weights: Tensor,\n        ess_min: float,\n        pop_idx: int,\n    ) -&gt; Tuple[Tensor, Tensor]:\n        \"\"\"Return resampled particles and uniform weights if effectice sampling size is\n        too small.\n        \"\"\"\n\n        num_particles = particles.shape[0]\n        ess = (1 / torch.sum(torch.exp(2.0 * log_weights), dim=0)) / num_particles\n        # Resampling of weights for low ESS only for Sisson et al. 2007.\n        if ess &lt; ess_min:\n            self.logger.info(\"ESS=%s too low, resampling pop %s...\", ess, pop_idx)\n            # First resample, then set to uniform weights as in Sisson et al. 2007.\n            particles = self.sample_from_population_with_weights(\n                particles, torch.exp(log_weights), num_samples=num_particles\n            )\n            log_weights = torch.log(1 / num_particles * torch.ones(num_particles))\n\n        return particles, log_weights\n\n    def run_lra_update_weights(\n        self,\n        particles: Tensor,\n        xs: Tensor,\n        observation: Tensor,\n        log_weights: Tensor,\n        lra_with_weights: bool,\n    ) -&gt; Tuple[Tensor, Tensor]:\n        \"\"\"Return particles and weights adjusted with LRA.\n\n        Runs (weighted) linear regression from xs onto particles to adjust the\n        particles.\n\n        Updates the SMC weights according to the new particles.\n        \"\"\"\n\n        adjusted_particels = self.run_lra(\n            theta=particles,\n            x=xs,\n            observation=observation,\n            sample_weight=log_weights.exp() if lra_with_weights else None,\n        )\n\n        # Update SMC weights with LRA adjusted weights\n        adjusted_log_weights = self._calculate_new_log_weights(\n            new_particles=adjusted_particels,\n            old_particles=particles,\n            old_log_weights=log_weights,\n        )\n\n        return adjusted_particels, adjusted_log_weights\n\n    def run_sass_set_xo(\n        self,\n        num_particles: int,\n        num_pilot_simulations: int,\n        x_o,\n        num_iid_samples: int,\n        lra: bool = False,\n        sass_expansion_degree: int = 1,\n    ) -&gt; Callable:\n        \"\"\"Return transform for semi-automatic summary statistics.\n\n        Runs an single round of rejection abc with fixed budget and accepts\n        num_particles simulations to run the regression for sass.\n\n        Sets self.x_o once the x_shape can be derived from simulations.\n        \"\"\"\n        (\n            pilot_particles,\n            _,\n            _,\n            pilot_xs,\n        ) = self._set_xo_and_sample_initial_population(\n            x_o, num_particles, num_pilot_simulations, num_iid_samples\n        )\n        assert self.x_o is not None, \"x_o not set yet.\"\n\n        # Adjust with LRA.\n        if lra:\n            pilot_particles = self.run_lra(pilot_particles, pilot_xs, self.x_o)\n        sass_transform = self.get_sass_transform(\n            pilot_particles,\n            pilot_xs,\n            expansion_degree=sass_expansion_degree,\n            sample_weight=None,\n        )\n        return sass_transform\n\n    def get_particle_ranges(\n        self, particles: Tensor, weights: Tensor, samples_per_dim: int = 100\n    ) -&gt; Tensor:\n        \"\"\"Return range of particles in each parameter dimension.\"\"\"\n\n        # get weighted samples\n        samples = self.sample_from_population_with_weights(\n            particles,\n            weights,\n            num_samples=samples_per_dim * particles.shape[1],\n        )\n\n        # Variance spans the range of particles for every dimension.\n        particle_ranges = samples.max(0).values - samples.min(0).values\n        assert particle_ranges.ndim &lt; 2\n        return particle_ranges\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.smcabc.SMCABC.__call__","title":"<code>__call__(x_o, num_particles, num_initial_pop, num_simulations, epsilon_decay, distance_based_decay=False, ess_min=None, kernel_variance_scale=1.0, use_last_pop_samples=True, return_summary=False, kde=False, kde_kwargs=None, kde_sample_weights=False, lra=False, lra_with_weights=False, sass=False, sass_fraction=0.25, sass_expansion_degree=1, num_iid_samples=1)</code>","text":"<p>Run SMCABC and return accepted parameters or KDE object fitted on them.</p> <p>Parameters:</p> Name Type Description Default <code>x_o</code> <code>Union[Tensor, ndarray]</code> <p>Observed data.</p> required <code>num_particles</code> <code>int</code> <p>Number of particles in each population.</p> required <code>num_initial_pop</code> <code>int</code> <p>Number of simulations used for initial population.</p> required <code>num_simulations</code> <code>int</code> <p>Total number of possible simulations.</p> required <code>epsilon_decay</code> <code>float</code> <p>Factor with which the acceptance threshold \\(\\epsilon\\) decays.</p> required <code>distance_based_decay</code> <code>bool</code> <p>Whether the \\(\\epsilon\\) decay is constant over populations or calculated from the previous populations distribution of distances.</p> <code>False</code> <code>ess_min</code> <code>Optional[float]</code> <p>Threshold of effective sampling size for resampling weights. Not used when None (default).</p> <code>None</code> <code>kernel_variance_scale</code> <code>float</code> <p>Factor for scaling the perturbation kernel variance.</p> <code>1.0</code> <code>use_last_pop_samples</code> <code>bool</code> <p>Whether to fill up the current population with samples from the previous population when the budget is used up. If False, the current population is discarded and the previous population is returned.</p> <code>True</code> <code>lra</code> <code>bool</code> <p>Whether to run linear regression adjustment as in Beaumont et al. 2002</p> <code>False</code> <code>lra_with_weights</code> <code>bool</code> <p>Whether to run lra as weighted linear regression with SMC weights</p> <code>False</code> <code>sass</code> <code>bool</code> <p>Whether to determine semi-automatic summary statistics (sass) as in Fearnhead &amp; Prangle 2012.</p> <code>False</code> <code>sass_fraction</code> <code>float</code> <p>Fraction of simulation budget used for the initial sass run.</p> <code>0.25</code> <code>sass_expansion_degree</code> <code>int</code> <p>Degree of the polynomial feature expansion for the sass regression, default 1 - no expansion.</p> <code>1</code> <code>kde</code> <code>bool</code> <p>Whether to run KDE on the accepted parameters to return a KDE object from which one can sample.</p> <code>False</code> <code>kde_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>kwargs for performing KDE: \u2018bandwidth=\u2019; either a float, or a string naming a bandwidth heuristics, e.g., \u2018cv\u2019 (cross validation), \u2018silvermann\u2019 or \u2018scott\u2019, default \u2018cv\u2019. \u2018transform\u2019: transform applied to the parameters before doing KDE. \u2018sample_weights\u2019: weights associated with samples. See \u2018get_kde\u2019 for more details</p> <code>None</code> <code>kde_sample_weights</code> <code>bool</code> <p>Whether perform weighted KDE with SMC weights or on raw particles.</p> <code>False</code> <code>return_summary</code> <code>bool</code> <p>Whether to return a dictionary with all accepted particles, weights, etc. at the end.</p> <code>False</code> <code>num_iid_samples</code> <code>int</code> <p>Number of simulations per parameter. Choose <code>num_iid_samples&gt;1</code>, if you have chosen a statistical distance that evaluates sets of simulations against a set of reference observations instead of a single data-point comparison.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>theta</code> <code>if kde False</code> <p>accepted parameters of the last population.</p> <code>kde</code> <code>if kde True</code> <p>KDE object fitted on accepted parameters, from which one can .sample() and .log_prob().</p> <code>summary</code> <code>if return_summary True</code> <p>dictionary containing the accepted paramters (if kde True), distances and simulated data x of all populations.</p> Source code in <code>sbi/inference/abc/smcabc.py</code> <pre><code>def __call__(\n    self,\n    x_o: Union[Tensor, ndarray],\n    num_particles: int,\n    num_initial_pop: int,\n    num_simulations: int,\n    epsilon_decay: float,\n    distance_based_decay: bool = False,\n    ess_min: Optional[float] = None,\n    kernel_variance_scale: float = 1.0,\n    use_last_pop_samples: bool = True,\n    return_summary: bool = False,\n    kde: bool = False,\n    kde_kwargs: Optional[Dict[str, Any]] = None,\n    kde_sample_weights: bool = False,\n    lra: bool = False,\n    lra_with_weights: bool = False,\n    sass: bool = False,\n    sass_fraction: float = 0.25,\n    sass_expansion_degree: int = 1,\n    num_iid_samples: int = 1,\n) -&gt; Union[Tensor, KDEWrapper, Tuple[Tensor, dict], Tuple[KDEWrapper, dict]]:\n    r\"\"\"Run SMCABC and return accepted parameters or KDE object fitted on them.\n\n    Args:\n        x_o: Observed data.\n        num_particles: Number of particles in each population.\n        num_initial_pop: Number of simulations used for initial population.\n        num_simulations: Total number of possible simulations.\n        epsilon_decay: Factor with which the acceptance threshold $\\epsilon$ decays.\n        distance_based_decay: Whether the $\\epsilon$ decay is constant over\n            populations or calculated from the previous populations distribution of\n            distances.\n        ess_min: Threshold of effective sampling size for resampling weights. Not\n            used when None (default).\n        kernel_variance_scale: Factor for scaling the perturbation kernel variance.\n        use_last_pop_samples: Whether to fill up the current population with\n            samples from the previous population when the budget is used up. If\n            False, the current population is discarded and the previous population\n            is returned.\n        lra: Whether to run linear regression adjustment as in Beaumont et al. 2002\n        lra_with_weights: Whether to run lra as weighted linear regression with SMC\n            weights\n        sass: Whether to determine semi-automatic summary statistics (sass) as in\n            Fearnhead &amp; Prangle 2012.\n        sass_fraction: Fraction of simulation budget used for the initial sass run.\n        sass_expansion_degree: Degree of the polynomial feature expansion for the\n            sass regression, default 1 - no expansion.\n        kde: Whether to run KDE on the accepted parameters to return a KDE\n            object from which one can sample.\n        kde_kwargs: kwargs for performing KDE:\n            'bandwidth='; either a float, or a string naming a bandwidth\n            heuristics, e.g., 'cv' (cross validation), 'silvermann' or 'scott',\n            default 'cv'.\n            'transform': transform applied to the parameters before doing KDE.\n            'sample_weights': weights associated with samples. See 'get_kde' for\n            more details\n        kde_sample_weights: Whether perform weighted KDE with SMC weights or on raw\n            particles.\n        return_summary: Whether to return a dictionary with all accepted particles,\n            weights, etc. at the end.\n        num_iid_samples: Number of simulations per parameter. Choose\n            `num_iid_samples&gt;1`, if you have chosen a statistical distance that\n            evaluates sets of simulations against a set of reference observations\n            instead of a single data-point comparison.\n\n    Returns:\n        theta (if kde False): accepted parameters of the last population.\n        kde (if kde True): KDE object fitted on accepted parameters, from which one\n            can .sample() and .log_prob().\n        summary (if return_summary True): dictionary containing the accepted\n            paramters (if kde True), distances and simulated data x of all\n            populations.\n    \"\"\"\n\n    pop_idx = 0\n    self.num_simulations = num_simulations * num_iid_samples\n    if kde_kwargs is None:\n        kde_kwargs = {}\n    assert isinstance(epsilon_decay, float) and epsilon_decay &gt; 0.0\n    assert not (\n        self.distance.requires_iid_data and lra\n    ), \"Currently there is no support to run inference \"\n    \"on multiple observations together with lra.\"\n    assert not (\n        self.distance.requires_iid_data and sass\n    ), \"Currently there is no support to run inference \"\n    \"on multiple observations together with sass.\"\n\n    # Pilot run for SASS.\n    if sass:\n        num_pilot_simulations = int(sass_fraction * num_simulations)\n        self.logger.info(\n            \"Running SASS with %s pilot samples.\", num_pilot_simulations\n        )\n        sass_transform = self.run_sass_set_xo(\n            num_particles,\n            num_pilot_simulations,\n            x_o,\n            num_iid_samples,\n            lra,\n            sass_expansion_degree,\n        )\n        # Udpate simulator and xo\n        x_o = sass_transform(self.x_o)\n\n        def sass_simulator(theta):\n            self.simulation_counter += theta.shape[0]\n            return sass_transform(self._batched_simulator(theta))\n\n        self._simulate_with_budget = sass_simulator\n\n    # run initial population\n    particles, epsilon, distances, x = self._set_xo_and_sample_initial_population(\n        x_o, num_particles, num_initial_pop, num_iid_samples\n    )\n    log_weights = torch.log(1 / num_particles * torch.ones(num_particles))\n\n    self.logger.info((\n        \"population=%s, eps=%s, ess=%s, num_sims=%s\",\n        pop_idx,\n        epsilon,\n        1.0,\n        num_initial_pop,\n    ))\n\n    all_particles = [particles]\n    all_log_weights = [log_weights]\n    all_distances = [distances]\n    all_epsilons = [epsilon]\n    all_x = [x]\n\n    while self.simulation_counter &lt; self.num_simulations:\n        pop_idx += 1\n        # Decay based on quantile of distances from previous pop.\n        if distance_based_decay:\n            epsilon = self._get_next_epsilon(\n                all_distances[pop_idx - 1], epsilon_decay\n            )\n        # Constant decay.\n        else:\n            epsilon *= epsilon_decay\n\n        # Get kernel variance from previous pop.\n        self.kernel_variance = self.get_kernel_variance(\n            all_particles[pop_idx - 1],\n            torch.exp(all_log_weights[pop_idx - 1]),\n            samples_per_dim=500,\n            kernel_variance_scale=kernel_variance_scale,\n        )\n        particles, log_weights, distances, x = self._sample_next_population(\n            particles=all_particles[pop_idx - 1],\n            log_weights=all_log_weights[pop_idx - 1],\n            distances=all_distances[pop_idx - 1],\n            epsilon=epsilon,\n            x=all_x[pop_idx - 1],\n            num_iid_samples=num_iid_samples,\n            use_last_pop_samples=use_last_pop_samples,\n        )\n\n        # Resample population if effective sampling size is too small.\n        if ess_min is not None:\n            particles, log_weights = self.resample_if_ess_too_small(\n                particles, log_weights, ess_min, pop_idx\n            )\n\n        self.logger.info((\n            \"population=%s done: eps={epsilon:.6f}, num_sims=%s.\",\n            pop_idx,\n            epsilon,\n            self.simulation_counter,\n        ))\n\n        # collect results\n        all_particles.append(particles)\n        all_log_weights.append(log_weights)\n        all_distances.append(distances)\n        all_epsilons.append(epsilon)\n        all_x.append(x)\n\n    # Maybe run LRA and adjust weights.\n    if lra:\n        self.logger.info(\"Running Linear regression adjustment.\")\n        adjusted_particles, _ = self.run_lra_update_weights(\n            particles=all_particles[-1],\n            xs=all_x[-1],\n            observation=process_x(x_o),\n            log_weights=all_log_weights[-1],\n            lra_with_weights=lra_with_weights,\n        )\n        final_particles = adjusted_particles\n    else:\n        final_particles = all_particles[-1]\n\n    if kde:\n        self.logger.info(\n            \"\"\"KDE on %s samples with bandwidth option %s. Beware that KDE can give\n            unreliable results when used with too few samples and in high\n            dimensions.\"\"\",\n            final_particles.shape[0],\n            kde_kwargs.get(\"bandwidth\", \"cv\"),\n        )\n        # Maybe get particles weights from last population for weighted KDE.\n        if kde_sample_weights:\n            kde_kwargs[\"sample_weights\"] = all_log_weights[-1].exp()\n\n        kde_dist = get_kde(final_particles, **kde_kwargs)\n\n        if return_summary:\n            return (\n                kde_dist,\n                dict(\n                    particles=all_particles,\n                    weights=all_log_weights,\n                    epsilons=all_epsilons,\n                    distances=all_distances,\n                    xs=all_x,\n                ),\n            )\n        else:\n            return kde_dist\n\n    if return_summary:\n        return (\n            final_particles,\n            dict(\n                particles=all_particles,\n                weights=all_log_weights,\n                epsilons=all_epsilons,\n                distances=all_distances,\n                xs=all_x,\n            ),\n        )\n    else:\n        return final_particles\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.smcabc.SMCABC.__init__","title":"<code>__init__(simulator, prior, distance='l2', requires_iid_data=None, distance_kwargs=None, num_workers=1, simulation_batch_size=1, distance_batch_size=-1, show_progress_bars=True, kernel='gaussian', algorithm_variant='C')</code>","text":"<p>Sequential Monte Carlo Approximate Bayesian Computation.</p> We distinguish between three different SMC methods here <ul> <li>A: Toni et al. 2010 (Phd Thesis)</li> <li>B: Sisson et al. 2007 (with correction from 2009)</li> <li>C: Beaumont et al. 2009</li> </ul> <p>In Toni et al. 2010 we find an overview of the differences on page 34:     - B: same as A except for resampling of weights if the effective sampling         size is too small.     - C: same as A except for calculation of the covariance of the perturbation         kernel: the kernel covariance is a scaled version of the covariance of         the previous population.</p> <p>Parameters:</p> Name Type Description Default <code>simulator</code> <code>Callable</code> <p>A function that takes parameters \\(\\theta\\) and maps them to simulations, or observations, <code>x</code>, \\(\\mathrm{sim}(\\theta)\\to x\\). Any regular Python callable (i.e. function or class with <code>__call__</code> method) can be used.</p> required <code>prior</code> <code>Distribution</code> <p>A probability distribution that expresses prior knowledge about the parameters, e.g. which ranges are meaningful for them. Any object with <code>.log_prob()</code>and <code>.sample()</code> (for example, a PyTorch distribution) can be used.</p> required <code>distance</code> <code>Union[str, Callable]</code> <p>Distance function to compare observed and simulated data. Can be a custom callable function or one of <code>l1</code>, <code>l2</code>, <code>mse</code>, <code>mmd</code>, <code>wasserstein</code>.</p> <code>'l2'</code> <code>requires_iid_data</code> <code>Optional[None]</code> <p>Whether to allow conditioning on iid sampled data or not. Typically, this information is inferred by the choice of the distance, but in case a custom distance is used, this information is pivotal.</p> <code>None</code> <code>distance_kwargs</code> <code>Optional[Dict]</code> <p>Configurations parameters for the distances. In particular useful for the MMD and Wasserstein distance.</p> <code>None</code> <code>num_workers</code> <code>int</code> <p>Number of parallel workers to use for simulations.</p> <code>1</code> <code>simulation_batch_size</code> <code>int</code> <p>Number of parameter sets that the simulator maps to data x at once. If None, we simulate all parameter sets at the same time. If &gt;= 1, the simulator has to process data of shape (simulation_batch_size, parameter_dimension).</p> <code>1</code> <code>distance_batch_size</code> <code>int</code> <p>Number of simulations that the distance function evaluates against the reference observations at once. If -1, we evaluate all simulations at the same time.</p> <code>-1</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during simulation and sampling.</p> <code>True</code> <code>kernel</code> <code>Optional[str]</code> <p>Perturbation kernel.</p> <code>'gaussian'</code> <code>algorithm_variant</code> <code>str</code> <p>Indicating the choice of algorithm variant, A, B, or C.</p> <code>'C'</code> Source code in <code>sbi/inference/abc/smcabc.py</code> <pre><code>def __init__(\n    self,\n    simulator: Callable,\n    prior: Distribution,\n    distance: Union[str, Callable] = \"l2\",\n    requires_iid_data: Optional[None] = None,\n    distance_kwargs: Optional[Dict] = None,\n    num_workers: int = 1,\n    simulation_batch_size: int = 1,\n    distance_batch_size: int = -1,\n    show_progress_bars: bool = True,\n    kernel: Optional[str] = \"gaussian\",\n    algorithm_variant: str = \"C\",\n):\n    r\"\"\"Sequential Monte Carlo Approximate Bayesian Computation.\n\n    We distinguish between three different SMC methods here:\n        - A: Toni et al. 2010 (Phd Thesis)\n        - B: Sisson et al. 2007 (with correction from 2009)\n        - C: Beaumont et al. 2009\n\n    In Toni et al. 2010 we find an overview of the differences on page 34:\n        - B: same as A except for resampling of weights if the effective sampling\n            size is too small.\n        - C: same as A except for calculation of the covariance of the perturbation\n            kernel: the kernel covariance is a scaled version of the covariance of\n            the previous population.\n\n    Args:\n        simulator: A function that takes parameters $\\theta$ and maps them to\n            simulations, or observations, `x`, $\\mathrm{sim}(\\theta)\\to x$. Any\n            regular Python callable (i.e. function or class with `__call__` method)\n            can be used.\n        prior: A probability distribution that expresses prior knowledge about the\n            parameters, e.g. which ranges are meaningful for them. Any\n            object with `.log_prob()`and `.sample()` (for example, a PyTorch\n            distribution) can be used.\n        distance: Distance function to compare observed and simulated data. Can be\n            a custom callable function or one of `l1`, `l2`, `mse`,\n            `mmd`, `wasserstein`.\n        requires_iid_data: Whether to allow conditioning on iid sampled data or not.\n            Typically, this information is inferred by the choice of the distance,\n            but in case a custom distance is used, this information is pivotal.\n        distance_kwargs: Configurations parameters for the distances. In particular\n            useful for the MMD and Wasserstein distance.\n        num_workers: Number of parallel workers to use for simulations.\n        simulation_batch_size: Number of parameter sets that the simulator\n            maps to data x at once. If None, we simulate all parameter sets at the\n            same time. If &gt;= 1, the simulator has to process data of shape\n            (simulation_batch_size, parameter_dimension).\n        distance_batch_size: Number of simulations that the distance function\n            evaluates against the reference observations at once. If -1, we evaluate\n            all simulations at the same time.\n        show_progress_bars: Whether to show a progressbar during simulation and\n            sampling.\n        kernel: Perturbation kernel.\n        algorithm_variant: Indicating the choice of algorithm variant, A, B, or C.\n    \"\"\"\n\n    super().__init__(\n        simulator=simulator,\n        prior=prior,\n        distance=distance,\n        requires_iid_data=requires_iid_data,\n        distance_kwargs=distance_kwargs,\n        num_workers=num_workers,\n        simulation_batch_size=simulation_batch_size,\n        distance_batch_size=distance_batch_size,\n        show_progress_bars=show_progress_bars,\n    )\n\n    kernels = (\"gaussian\", \"uniform\")\n    assert (\n        kernel in kernels\n    ), f\"Kernel '{kernel}' not supported. Choose one from {kernels}.\"\n    self.kernel = kernel\n\n    algorithm_variants = (\"A\", \"B\", \"C\")\n    assert algorithm_variant in algorithm_variants, (\n        f\"SMCABC variant '{algorithm_variant}' not supported, choose one from\"\n        \" {algorithm_variants}.\"\n    )\n    self.algorithm_variant = algorithm_variant\n    self.distance_to_x0 = None\n    self.simulation_counter = 0\n    self.num_simulations = 0\n    self.kernel_variance = None\n\n    # Define simulator that keeps track of budget.\n    def simulate_with_budget(theta):\n        self.simulation_counter += theta.shape[0]\n        return self._batched_simulator(theta)\n\n    self._simulate_with_budget = simulate_with_budget\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.smcabc.SMCABC.get_kernel_variance","title":"<code>get_kernel_variance(particles, weights, samples_per_dim=100, kernel_variance_scale=1.0)</code>","text":"<p>Return kernel variance for a given population of particles and weights.</p> Source code in <code>sbi/inference/abc/smcabc.py</code> <pre><code>def get_kernel_variance(\n    self,\n    particles: Tensor,\n    weights: Tensor,\n    samples_per_dim: int = 100,\n    kernel_variance_scale: float = 1.0,\n) -&gt; Tensor:\n    \"\"\"Return kernel variance for a given population of particles and weights.\"\"\"\n    if self.kernel == \"gaussian\":\n        # For variant C, Beaumont et al. 2009, the kernel variance comes from the\n        # previous population.\n        if self.algorithm_variant == \"C\":\n            # Calculate weighted covariance of particles.\n            population_cov = torch.tensor(\n                np.atleast_2d(np.cov(particles, rowvar=False, aweights=weights)),\n                dtype=torch.float32,\n            )\n            # Make sure variance is nonsingular.\n            try:\n                torch.linalg.cholesky(kernel_variance_scale * population_cov)\n            except RuntimeError:\n                self.logger.warning(\n                    \"\"\"\"Singular particle covariance, using unit covariance.\"\"\"\n                )\n                population_cov = torch.eye(particles.shape[1])\n            return kernel_variance_scale * population_cov\n        # While for Toni et al. and Sisson et al. it comes from the parameter\n        # ranges.\n        elif self.algorithm_variant in (\"A\", \"B\"):\n            particle_ranges = self.get_particle_ranges(\n                particles, weights, samples_per_dim=samples_per_dim\n            )\n            return kernel_variance_scale * torch.diag(particle_ranges)\n        else:\n            raise ValueError(f\"Variant, '{self.algorithm_variant}' not supported.\")\n    elif self.kernel == \"uniform\":\n        # Variance spans the range of parameters for every dimension.\n        return kernel_variance_scale * self.get_particle_ranges(\n            particles, weights, samples_per_dim=samples_per_dim\n        )\n    else:\n        raise ValueError(f\"Kernel, '{self.kernel}' not supported.\")\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.smcabc.SMCABC.get_new_kernel","title":"<code>get_new_kernel(thetas)</code>","text":"<p>Return new kernel distribution for a given set of paramters.</p> Source code in <code>sbi/inference/abc/smcabc.py</code> <pre><code>def get_new_kernel(self, thetas: Tensor) -&gt; Distribution:\n    \"\"\"Return new kernel distribution for a given set of paramters.\"\"\"\n\n    if self.kernel == \"gaussian\":\n        assert self.kernel_variance is not None, \"get kernel variance first.\"\n        assert self.kernel_variance.ndim == 2\n        return MultivariateNormal(\n            loc=thetas, covariance_matrix=self.kernel_variance\n        )\n\n    elif self.kernel == \"uniform\":\n        low = thetas - self.kernel_variance\n        high = thetas + self.kernel_variance\n        # Move batch shape to event shape to get Uniform that is multivariate in\n        # parameter dimension.\n        return BoxUniform(low=low, high=high)\n    else:\n        raise ValueError(f\"Kernel, '{self.kernel}' not supported.\")\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.smcabc.SMCABC.get_particle_ranges","title":"<code>get_particle_ranges(particles, weights, samples_per_dim=100)</code>","text":"<p>Return range of particles in each parameter dimension.</p> Source code in <code>sbi/inference/abc/smcabc.py</code> <pre><code>def get_particle_ranges(\n    self, particles: Tensor, weights: Tensor, samples_per_dim: int = 100\n) -&gt; Tensor:\n    \"\"\"Return range of particles in each parameter dimension.\"\"\"\n\n    # get weighted samples\n    samples = self.sample_from_population_with_weights(\n        particles,\n        weights,\n        num_samples=samples_per_dim * particles.shape[1],\n    )\n\n    # Variance spans the range of particles for every dimension.\n    particle_ranges = samples.max(0).values - samples.min(0).values\n    assert particle_ranges.ndim &lt; 2\n    return particle_ranges\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.smcabc.SMCABC.resample_if_ess_too_small","title":"<code>resample_if_ess_too_small(particles, log_weights, ess_min, pop_idx)</code>","text":"<p>Return resampled particles and uniform weights if effectice sampling size is too small.</p> Source code in <code>sbi/inference/abc/smcabc.py</code> <pre><code>def resample_if_ess_too_small(\n    self,\n    particles: Tensor,\n    log_weights: Tensor,\n    ess_min: float,\n    pop_idx: int,\n) -&gt; Tuple[Tensor, Tensor]:\n    \"\"\"Return resampled particles and uniform weights if effectice sampling size is\n    too small.\n    \"\"\"\n\n    num_particles = particles.shape[0]\n    ess = (1 / torch.sum(torch.exp(2.0 * log_weights), dim=0)) / num_particles\n    # Resampling of weights for low ESS only for Sisson et al. 2007.\n    if ess &lt; ess_min:\n        self.logger.info(\"ESS=%s too low, resampling pop %s...\", ess, pop_idx)\n        # First resample, then set to uniform weights as in Sisson et al. 2007.\n        particles = self.sample_from_population_with_weights(\n            particles, torch.exp(log_weights), num_samples=num_particles\n        )\n        log_weights = torch.log(1 / num_particles * torch.ones(num_particles))\n\n    return particles, log_weights\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.smcabc.SMCABC.run_lra_update_weights","title":"<code>run_lra_update_weights(particles, xs, observation, log_weights, lra_with_weights)</code>","text":"<p>Return particles and weights adjusted with LRA.</p> <p>Runs (weighted) linear regression from xs onto particles to adjust the particles.</p> <p>Updates the SMC weights according to the new particles.</p> Source code in <code>sbi/inference/abc/smcabc.py</code> <pre><code>def run_lra_update_weights(\n    self,\n    particles: Tensor,\n    xs: Tensor,\n    observation: Tensor,\n    log_weights: Tensor,\n    lra_with_weights: bool,\n) -&gt; Tuple[Tensor, Tensor]:\n    \"\"\"Return particles and weights adjusted with LRA.\n\n    Runs (weighted) linear regression from xs onto particles to adjust the\n    particles.\n\n    Updates the SMC weights according to the new particles.\n    \"\"\"\n\n    adjusted_particels = self.run_lra(\n        theta=particles,\n        x=xs,\n        observation=observation,\n        sample_weight=log_weights.exp() if lra_with_weights else None,\n    )\n\n    # Update SMC weights with LRA adjusted weights\n    adjusted_log_weights = self._calculate_new_log_weights(\n        new_particles=adjusted_particels,\n        old_particles=particles,\n        old_log_weights=log_weights,\n    )\n\n    return adjusted_particels, adjusted_log_weights\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.smcabc.SMCABC.run_sass_set_xo","title":"<code>run_sass_set_xo(num_particles, num_pilot_simulations, x_o, num_iid_samples, lra=False, sass_expansion_degree=1)</code>","text":"<p>Return transform for semi-automatic summary statistics.</p> <p>Runs an single round of rejection abc with fixed budget and accepts num_particles simulations to run the regression for sass.</p> <p>Sets self.x_o once the x_shape can be derived from simulations.</p> Source code in <code>sbi/inference/abc/smcabc.py</code> <pre><code>def run_sass_set_xo(\n    self,\n    num_particles: int,\n    num_pilot_simulations: int,\n    x_o,\n    num_iid_samples: int,\n    lra: bool = False,\n    sass_expansion_degree: int = 1,\n) -&gt; Callable:\n    \"\"\"Return transform for semi-automatic summary statistics.\n\n    Runs an single round of rejection abc with fixed budget and accepts\n    num_particles simulations to run the regression for sass.\n\n    Sets self.x_o once the x_shape can be derived from simulations.\n    \"\"\"\n    (\n        pilot_particles,\n        _,\n        _,\n        pilot_xs,\n    ) = self._set_xo_and_sample_initial_population(\n        x_o, num_particles, num_pilot_simulations, num_iid_samples\n    )\n    assert self.x_o is not None, \"x_o not set yet.\"\n\n    # Adjust with LRA.\n    if lra:\n        pilot_particles = self.run_lra(pilot_particles, pilot_xs, self.x_o)\n    sass_transform = self.get_sass_transform(\n        pilot_particles,\n        pilot_xs,\n        expansion_degree=sass_expansion_degree,\n        sample_weight=None,\n    )\n    return sass_transform\n</code></pre>"},{"location":"reference/inference/#sbi.inference.abc.smcabc.SMCABC.sample_from_population_with_weights","title":"<code>sample_from_population_with_weights(particles, weights, num_samples=1)</code>  <code>staticmethod</code>","text":"<p>Return samples from particles sampled with weights.</p> Source code in <code>sbi/inference/abc/smcabc.py</code> <pre><code>@staticmethod\ndef sample_from_population_with_weights(\n    particles: Tensor, weights: Tensor, num_samples: int = 1\n) -&gt; Tensor:\n    \"\"\"Return samples from particles sampled with weights.\"\"\"\n\n    # define multinomial with weights as probs\n    multi = Multinomial(probs=weights)\n    # sample num samples, with replacement\n    samples = multi.sample(sample_shape=torch.Size((num_samples,)))\n    # get indices of success trials\n    indices = torch.where(samples)[1]\n    # return those indices from trace\n    return particles[indices]\n</code></pre>"},{"location":"reference/inference/#helpers","title":"Helpers","text":""},{"location":"reference/inference/#sbi.inference.trainers.base.simulate_for_sbi","title":"<code>simulate_for_sbi(simulator, proposal, num_simulations, num_workers=1, simulation_batch_size=1, seed=None, show_progress_bar=True)</code>","text":"<p>Returns (\\(\\theta, x\\)) pairs obtained from sampling the proposal and simulating.</p> <p>This function performs two steps:</p> <ul> <li>Sample parameters \\(\\theta\\) from the <code>proposal</code>.</li> <li>Simulate these parameters to obtain \\(x\\).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>simulator</code> <code>Callable</code> <p>A function that takes parameters \\(\\theta\\) and maps them to simulations, or observations, <code>x</code>, \\(\\text{sim}(\\theta)\\to x\\). Any regular Python callable (i.e. function or class with <code>__call__</code> method) can be used. Note that the simulator should be able to handle numpy arrays for efficient parallelization. You can use <code>process_simulator</code> to ensure this.</p> required <code>proposal</code> <code>Any</code> <p>Probability distribution that the parameters \\(\\theta\\) are sampled from.</p> required <code>num_simulations</code> <code>int</code> <p>Number of simulations that are run.</p> required <code>num_workers</code> <code>int</code> <p>Number of parallel workers to use for simulations.</p> <code>1</code> <code>simulation_batch_size</code> <code>Union[int, None]</code> <p>Number of parameter sets of shape (simulation_batch_size, parameter_dimension) that the simulator receives per call. If None, we set simulation_batch_size=num_simulations and simulate all parameter sets with one call. Otherwise, we construct batches of parameter sets and distribute them among num_workers.</p> <code>1</code> <code>seed</code> <code>Optional[int]</code> <p>Seed for reproducibility.</p> <code>None</code> <code>show_progress_bar</code> <code>bool</code> <p>Whether to show a progress bar for simulating. This will not affect whether there will be a progressbar while drawing samples from the proposal.</p> <code>True</code> <p>Returns: Sampled parameters \\(\\theta\\) and simulation-outputs \\(x\\).</p> Source code in <code>sbi/utils/simulation_utils.py</code> <pre><code>def simulate_for_sbi(\n    simulator: Callable,\n    proposal: Any,\n    num_simulations: int,\n    num_workers: int = 1,\n    simulation_batch_size: Union[int, None] = 1,\n    seed: Optional[int] = None,\n    show_progress_bar: bool = True,\n) -&gt; Tuple[Tensor, Tensor]:\n    r\"\"\"Returns ($\\theta, x$) pairs obtained from sampling the proposal and simulating.\n\n    This function performs two steps:\n\n    - Sample parameters $\\theta$ from the `proposal`.\n    - Simulate these parameters to obtain $x$.\n\n    Args:\n        simulator: A function that takes parameters $\\theta$ and maps them to\n            simulations, or observations, `x`, $\\text{sim}(\\theta)\\to x$. Any\n            regular Python callable (i.e. function or class with `__call__` method)\n            can be used. Note that the simulator should be able to handle numpy\n            arrays for efficient parallelization. You can use\n            `process_simulator` to ensure this.\n        proposal: Probability distribution that the parameters $\\theta$ are sampled\n            from.\n        num_simulations: Number of simulations that are run.\n        num_workers: Number of parallel workers to use for simulations.\n        simulation_batch_size: Number of parameter sets of shape\n            (simulation_batch_size, parameter_dimension) that the simulator\n            receives per call. If None, we set\n            simulation_batch_size=num_simulations and simulate all parameter\n            sets with one call. Otherwise, we construct batches of parameter\n            sets and distribute them among num_workers.\n        seed: Seed for reproducibility.\n        show_progress_bar: Whether to show a progress bar for simulating. This will not\n            affect whether there will be a progressbar while drawing samples from the\n            proposal.\n\n    Returns: Sampled parameters $\\theta$ and simulation-outputs $x$.\n    \"\"\"\n\n    if num_simulations == 0:\n        theta = torch.tensor([], dtype=float32)\n        x = torch.tensor([], dtype=float32)\n\n    else:\n        # Cast theta to numpy for better joblib performance (seee #1175)\n        seed_all_backends(seed)\n        theta = proposal.sample((num_simulations,))\n\n        # Parse the simulation_batch_size logic\n        if simulation_batch_size is None:\n            simulation_batch_size = num_simulations\n        else:\n            simulation_batch_size = min(simulation_batch_size, num_simulations)\n\n        if num_workers != 1:\n            # For multiprocessing, we want to switch to numpy arrays.\n            # The batch size will be an approximation, since np.array_split does\n            # not take as argument the size of the batch but their total.\n            num_batches = num_simulations // simulation_batch_size\n            batches = np.array_split(theta.numpy(), num_batches, axis=0)\n            batch_seeds = np.random.randint(low=0, high=1_000_000, size=(len(batches),))\n\n            # define seeded simulator.\n            def simulator_seeded(theta: ndarray, seed: int) -&gt; Tensor:\n                seed_all_backends(seed)\n                return simulator(theta)\n\n            try:  # catch TypeError to give more informative error message\n                simulation_outputs: list[Tensor] = [  # pyright: ignore\n                    xx\n                    for xx in tqdm(\n                        Parallel(return_as=\"generator\", n_jobs=num_workers)(\n                            delayed(simulator_seeded)(batch, seed)\n                            for batch, seed in zip(batches, batch_seeds)\n                        ),\n                        total=num_simulations,\n                        disable=not show_progress_bar,\n                    )\n                ]\n            except TypeError as err:\n                raise TypeError(\n                    \"For multiprocessing, we switch to numpy arrays. Make sure to \"\n                    \"preprocess your simulator with `process_simulator` to handle numpy\"\n                    \" arrays.\"\n                ) from err\n\n        else:\n            simulation_outputs: list[Tensor] = []\n            batches = torch.split(theta, simulation_batch_size)\n            for batch in tqdm(batches, disable=not show_progress_bar):\n                simulation_outputs.append(simulator(batch))\n\n        # Correctly format the output\n        x = torch.cat(simulation_outputs, dim=0)\n        theta = torch.as_tensor(theta, dtype=float32)\n\n    return theta, x\n</code></pre>"},{"location":"reference/inference/#sbi.utils.user_input_checks.process_prior","title":"<code>process_prior(prior, custom_prior_wrapper_kwargs=None)</code>","text":"<p>Return PyTorch distribution-like prior from user-provided prior.</p> <p>NOTE: If the prior argument is a sequence of PyTorch distributions, they will be interpreted as independent prior dimensions wrapped in a <code>MultipleIndependent</code> pytorch Distribution. In case the elements are not PyTorch distributions, make sure to use process_prior on each element in the list beforehand. See FAQ 7 for details.</p> <p>NOTE: returns a tuple (processed_prior, num_params, whether_prior_returns_numpy). The last two entries in the tuple can be passed on to <code>process_simulator</code> to prepare the simulator as well. For example, it will take care of casting parameters to numpy or adding a batch dimension to the simulator output, if needed.</p> <p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Union[Sequence[Distribution], Distribution, rv_frozen, multi_rv_frozen]</code> <p>Prior object with <code>.sample()</code> and <code>.log_prob()</code> as provided by the user, or a sequence of such objects.</p> required <code>custom_prior_wrapper_kwargs</code> <code>Optional[Dict]</code> <p>kwargs to be passed to the class that wraps a custom prior into a pytorch Distribution, e.g., for passing bounds for a prior with bounded support (lower_bound, upper_bound), or argument constraints. (arg_constraints), see pytorch.distributions.Distribution for more info.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If prior objects lacks <code>.sample()</code> or <code>.log_prob()</code>.</p> <p>Returns:</p> Name Type Description <code>prior</code> <code>Distribution</code> <p>Prior that emits samples and evaluates log prob as PyTorch Tensors.</p> <code>theta_numel</code> <code>int</code> <p>Number of parameters - elements in a single sample from the prior.</p> <code>prior_returns_numpy</code> <code>bool</code> <p>Whether the return type of the prior was a Numpy array.</p> Source code in <code>sbi/utils/user_input_checks.py</code> <pre><code>def process_prior(\n    prior: Union[Sequence[Distribution], Distribution, rv_frozen, multi_rv_frozen],\n    custom_prior_wrapper_kwargs: Optional[Dict] = None,\n) -&gt; Tuple[Distribution, int, bool]:\n    \"\"\"Return PyTorch distribution-like prior from user-provided prior.\n\n    NOTE: If the prior argument is a sequence of PyTorch distributions, they will be\n    interpreted as independent prior dimensions wrapped in a `MultipleIndependent`\n    pytorch Distribution. In case the elements are not PyTorch distributions, make sure\n    to use process_prior on each element in the list beforehand. See FAQ 7 for details.\n\n    NOTE: returns a tuple (processed_prior, num_params, whether_prior_returns_numpy).\n    The last two entries in the tuple can be passed on to `process_simulator` to prepare\n    the simulator as well. For example, it will take care of casting parameters to numpy\n    or adding a batch dimension to the simulator output, if needed.\n\n    Args:\n        prior: Prior object with `.sample()` and `.log_prob()` as provided by the user,\n            or a sequence of such objects.\n        custom_prior_wrapper_kwargs: kwargs to be passed to the class that wraps a\n            custom prior into a pytorch Distribution, e.g., for passing bounds for a\n            prior with bounded support (lower_bound, upper_bound), or argument\n            constraints.\n            (arg_constraints), see pytorch.distributions.Distribution for more info.\n\n    Raises:\n        AttributeError: If prior objects lacks `.sample()` or `.log_prob()`.\n\n    Returns:\n        prior: Prior that emits samples and evaluates log prob as PyTorch Tensors.\n        theta_numel: Number of parameters - elements in a single sample from the prior.\n        prior_returns_numpy: Whether the return type of the prior was a Numpy array.\n    \"\"\"\n\n    # If prior is a sequence, assume independent components and check as PyTorch prior.\n    if isinstance(prior, Sequence):\n        warnings.warn(\n            f\"Prior was provided as a sequence of {len(prior)} priors. They will be \"\n            \"interpreted as independent of each other and matched in order to the \"\n            \"components of the parameter.\",\n            stacklevel=2,\n        )\n        # process individual priors\n        prior = [process_prior(p, custom_prior_wrapper_kwargs)[0] for p in prior]\n        return process_pytorch_prior(MultipleIndependent(prior))\n\n    if isinstance(prior, Distribution):\n        return process_pytorch_prior(prior)\n\n    # If prior is given as `scipy.stats` object, wrap as PyTorch.\n    elif isinstance(prior, (rv_frozen, multi_rv_frozen)):\n        raise NotImplementedError(\n            \"Passing a prior as scipy.stats object is deprecated. \"\n            \"Please pass it as a PyTorch Distribution.\"\n        )\n\n    # Otherwise it is a custom prior - check for `.sample()` and `.log_prob()`.\n    else:\n        return process_custom_prior(prior, custom_prior_wrapper_kwargs)\n</code></pre>"},{"location":"reference/inference/#sbi.utils.user_input_checks.process_simulator","title":"<code>process_simulator(user_simulator, prior, is_numpy_simulator)</code>","text":"<p>Returns a simulator that meets the requirements for usage in sbi.</p> <p>Parameters:</p> Name Type Description Default <code>user_simulator</code> <code>Callable</code> <p>simulator provided by the user, possibly written in numpy.</p> required <code>prior</code> <code>Distribution</code> <p>prior as pytorch distribution or processed with <code>process_prior</code>.</p> required <code>is_numpy_simulator</code> <code>bool</code> <p>whether the simulator needs theta in numpy types, returned from <code>process_prior</code>.</p> required <p>Returns:</p> Name Type Description <code>simulator</code> <code>Callable</code> <p>processed simulator that returns <code>torch.Tensor</code> can handle batches of parameters.</p> Source code in <code>sbi/utils/user_input_checks.py</code> <pre><code>def process_simulator(\n    user_simulator: Callable,\n    prior: Distribution,\n    is_numpy_simulator: bool,\n) -&gt; Callable:\n    \"\"\"Returns a simulator that meets the requirements for usage in sbi.\n\n    Args:\n        user_simulator: simulator provided by the user, possibly written in numpy.\n        prior: prior as pytorch distribution or processed with `process_prior`.\n        is_numpy_simulator: whether the simulator needs theta in numpy types, returned\n            from `process_prior`.\n\n    Returns:\n        simulator: processed simulator that returns `torch.Tensor` can handle batches\n            of parameters.\n    \"\"\"\n\n    assert isinstance(user_simulator, Callable), \"Simulator must be a function.\"\n\n    joblib_simulator = wrap_as_joblib_efficient_simulator(\n        user_simulator, prior, is_numpy_simulator\n    )\n\n    batch_simulator = ensure_batched_simulator(joblib_simulator, prior)\n\n    return batch_simulator\n</code></pre>"},{"location":"reference/models/","title":"Neural networks","text":""},{"location":"reference/models/#sbi.neural_nets.factory.posterior_nn","title":"<code>posterior_nn(model, z_score_theta='independent', z_score_x='independent', hidden_features=50, num_transforms=5, num_bins=10, embedding_net=nn.Identity(), num_components=10, **kwargs)</code>","text":"<p>Returns a function that builds a density estimator for learning the posterior.</p> <p>This function will usually be used for SNPE. The returned function is to be passed to the inference class when using the flexible interface.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The type of density estimator that will be created. One of [<code>mdn</code>, <code>made</code>, <code>maf</code>, <code>maf_rqs</code>, <code>nsf</code>].</p> required <code>z_score_theta</code> <code>Optional[str]</code> <p>Whether to z-score parameters \\(\\theta\\) before passing them into the network, can take one of the following: - <code>none</code>, or None: do not z-score. - <code>independent</code>: z-score each dimension independently. - <code>structured</code>: treat dimensions as related, therefore compute mean and std over the entire batch, instead of per-dimension. Should be used when each sample is, for example, a time series or an image.</p> <code>'independent'</code> <code>z_score_x</code> <code>Optional[str]</code> <p>Whether to z-score simulation outputs \\(x\\) before passing them into the network, same options as z_score_theta.</p> <code>'independent'</code> <code>hidden_features</code> <code>int</code> <p>Number of hidden features.</p> <code>50</code> <code>num_transforms</code> <code>int</code> <p>Number of transforms when a flow is used. Only relevant if density estimator is a normalizing flow (i.e. currently either a <code>maf</code> or a <code>nsf</code>). Ignored if density estimator is a <code>mdn</code> or <code>made</code>.</p> <code>5</code> <code>num_bins</code> <code>int</code> <p>Number of bins used for the splines in <code>nsf</code>. Ignored if density estimator not <code>nsf</code>.</p> <code>10</code> <code>embedding_net</code> <code>Module</code> <p>Optional embedding network for simulation outputs \\(x\\). This embedding net allows to learn features from potentially high-dimensional simulation outputs.</p> <code>Identity()</code> <code>num_components</code> <code>int</code> <p>Number of mixture components for a mixture of Gaussians. Ignored if density estimator is not an mdn.</p> <code>10</code> <code>kwargs</code> <code>Any</code> <p>additional custom arguments passed to downstream build functions.</p> <code>{}</code> Source code in <code>sbi/neural_nets/factory.py</code> <pre><code>def posterior_nn(\n    model: str,\n    z_score_theta: Optional[str] = \"independent\",\n    z_score_x: Optional[str] = \"independent\",\n    hidden_features: int = 50,\n    num_transforms: int = 5,\n    num_bins: int = 10,\n    embedding_net: nn.Module = nn.Identity(),\n    num_components: int = 10,\n    **kwargs: Any,\n) -&gt; Callable:\n    r\"\"\"\n    Returns a function that builds a density estimator for learning the posterior.\n\n    This function will usually be used for SNPE. The returned function is to be passed\n    to the inference class when using the flexible interface.\n\n    Args:\n        model: The type of density estimator that will be created. One of [`mdn`,\n            `made`, `maf`, `maf_rqs`, `nsf`].\n        z_score_theta: Whether to z-score parameters $\\theta$ before passing them into\n            the network, can take one of the following:\n            - `none`, or None: do not z-score.\n            - `independent`: z-score each dimension independently.\n            - `structured`: treat dimensions as related, therefore compute mean and std\n            over the entire batch, instead of per-dimension. Should be used when each\n            sample is, for example, a time series or an image.\n        z_score_x: Whether to z-score simulation outputs $x$ before passing them into\n            the network, same options as z_score_theta.\n        hidden_features: Number of hidden features.\n        num_transforms: Number of transforms when a flow is used. Only relevant if\n            density estimator is a normalizing flow (i.e. currently either a `maf` or a\n            `nsf`). Ignored if density estimator is a `mdn` or `made`.\n        num_bins: Number of bins used for the splines in `nsf`. Ignored if density\n            estimator not `nsf`.\n        embedding_net: Optional embedding network for simulation outputs $x$. This\n            embedding net allows to learn features from potentially high-dimensional\n            simulation outputs.\n        num_components: Number of mixture components for a mixture of Gaussians.\n            Ignored if density estimator is not an mdn.\n        kwargs: additional custom arguments passed to downstream build functions.\n    \"\"\"\n\n    kwargs = dict(\n        zip(\n            (\n                \"z_score_x\",\n                \"z_score_y\",\n                \"hidden_features\",\n                \"num_transforms\",\n                \"num_bins\",\n                \"embedding_net\",\n                \"num_components\",\n            ),\n            (\n                z_score_theta,\n                z_score_x,\n                hidden_features,\n                num_transforms,\n                num_bins,\n                check_net_device(embedding_net, \"cpu\", embedding_net_warn_msg),\n                num_components,\n            ),\n        ),\n        **kwargs,\n    )\n\n    def build_fn_snpe_a(batch_theta, batch_x, num_components):\n        \"\"\"Build function for SNPE-A\n\n        Extract the number of components from the kwargs, such that they are exposed as\n        a kwargs, offering the possibility to later override this kwarg with\n        `functools.partial`. This is necessary in order to make sure that the MDN in\n        SNPE-A only has one component when running the Algorithm 1 part.\n        \"\"\"\n        return build_mdn(\n            batch_x=batch_theta,\n            batch_y=batch_x,\n            num_components=num_components,\n            **kwargs,\n        )\n\n    def build_fn(batch_theta, batch_x):\n        if model not in model_builders:\n            raise NotImplementedError(f\"Model {model} in not implemented\")\n\n        # The naming might be a bit confusing.\n        # batch_x are the latent variables, batch_y the conditioned variables.\n        # batch_theta are the parameters and batch_x the observable variables.\n        return model_builders[model](batch_x=batch_theta, batch_y=batch_x, **kwargs)\n\n    if model == \"mdn_snpe_a\":\n        if num_components != 10:\n            raise ValueError(\n                \"You set `num_components`. For SNPE-A, this has to be done at \"\n                \"instantiation of the inference object, i.e. \"\n                \"`inference = SNPE_A(..., num_components=20)`\"\n            )\n        kwargs.pop(\"num_components\")\n\n    return build_fn_snpe_a if model == \"mdn_snpe_a\" else build_fn\n</code></pre>"},{"location":"reference/models/#sbi.neural_nets.factory.likelihood_nn","title":"<code>likelihood_nn(model, z_score_theta='independent', z_score_x='independent', hidden_features=50, num_transforms=5, num_bins=10, embedding_net=nn.Identity(), num_components=10, **kwargs)</code>","text":"<p>Returns a function that builds a density estimator for learning the likelihood.</p> <p>This function will usually be used for SNLE. The returned function is to be passed to the inference class when using the flexible interface.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The type of density estimator that will be created. One of [<code>mdn</code>, <code>made</code>, <code>maf</code>, <code>maf_rqs</code>, <code>nsf</code>].</p> required <code>z_score_theta</code> <code>Optional[str]</code> <p>Whether to z-score parameters \\(\\theta\\) before passing them into the network, can take one of the following: - <code>none</code>, or None: do not z-score. - <code>independent</code>: z-score each dimension independently. - <code>structured</code>: treat dimensions as related, therefore compute mean and std over the entire batch, instead of per-dimension. Should be used when each sample is, for example, a time series or an image.</p> <code>'independent'</code> <code>z_score_x</code> <code>Optional[str]</code> <p>Whether to z-score simulation outputs \\(x\\) before passing them into the network, same options as z_score_theta.</p> <code>'independent'</code> <code>hidden_features</code> <code>int</code> <p>Number of hidden features.</p> <code>50</code> <code>num_transforms</code> <code>int</code> <p>Number of transforms when a flow is used. Only relevant if density estimator is a normalizing flow (i.e. currently either a <code>maf</code> or a <code>nsf</code>). Ignored if density estimator is a <code>mdn</code> or <code>made</code>.</p> <code>5</code> <code>num_bins</code> <code>int</code> <p>Number of bins used for the splines in <code>nsf</code>. Ignored if density estimator not <code>nsf</code>.</p> <code>10</code> <code>embedding_net</code> <code>Module</code> <p>Optional embedding network for parameters \\(\\theta\\).</p> <code>Identity()</code> <code>num_components</code> <code>int</code> <p>Number of mixture components for a mixture of Gaussians. Ignored if density estimator is not an mdn.</p> <code>10</code> <code>kwargs</code> <code>Any</code> <p>additional custom arguments passed to downstream build functions.</p> <code>{}</code> Source code in <code>sbi/neural_nets/factory.py</code> <pre><code>def likelihood_nn(\n    model: str,\n    z_score_theta: Optional[str] = \"independent\",\n    z_score_x: Optional[str] = \"independent\",\n    hidden_features: int = 50,\n    num_transforms: int = 5,\n    num_bins: int = 10,\n    embedding_net: nn.Module = nn.Identity(),\n    num_components: int = 10,\n    **kwargs: Any,\n) -&gt; Callable:\n    r\"\"\"\n    Returns a function that builds a density estimator for learning the likelihood.\n\n    This function will usually be used for SNLE. The returned function is to be passed\n    to the inference class when using the flexible interface.\n\n    Args:\n        model: The type of density estimator that will be created. One of [`mdn`,\n            `made`, `maf`, `maf_rqs`, `nsf`].\n        z_score_theta: Whether to z-score parameters $\\theta$ before passing them into\n            the network, can take one of the following:\n            - `none`, or None: do not z-score.\n            - `independent`: z-score each dimension independently.\n            - `structured`: treat dimensions as related, therefore compute mean and std\n            over the entire batch, instead of per-dimension. Should be used when each\n            sample is, for example, a time series or an image.\n        z_score_x: Whether to z-score simulation outputs $x$ before passing them into\n            the network, same options as z_score_theta.\n        hidden_features: Number of hidden features.\n        num_transforms: Number of transforms when a flow is used. Only relevant if\n            density estimator is a normalizing flow (i.e. currently either a `maf` or a\n            `nsf`). Ignored if density estimator is a `mdn` or `made`.\n        num_bins: Number of bins used for the splines in `nsf`. Ignored if density\n            estimator not `nsf`.\n        embedding_net: Optional embedding network for parameters $\\theta$.\n        num_components: Number of mixture components for a mixture of Gaussians.\n            Ignored if density estimator is not an mdn.\n        kwargs: additional custom arguments passed to downstream build functions.\n    \"\"\"\n\n    kwargs = dict(\n        zip(\n            (\n                \"z_score_x\",\n                \"z_score_y\",\n                \"hidden_features\",\n                \"num_transforms\",\n                \"num_bins\",\n                \"embedding_net\",\n                \"num_components\",\n            ),\n            (\n                z_score_x,\n                z_score_theta,\n                hidden_features,\n                num_transforms,\n                num_bins,\n                check_net_device(embedding_net, \"cpu\", embedding_net_warn_msg),\n                num_components,\n            ),\n        ),\n        **kwargs,\n    )\n\n    def build_fn(batch_theta, batch_x):\n        if model not in model_builders:\n            raise NotImplementedError(f\"Model {model} in not implemented\")\n\n        return model_builders[model](batch_x=batch_x, batch_y=batch_theta, **kwargs)\n\n    return build_fn\n</code></pre>"},{"location":"reference/models/#sbi.neural_nets.factory.classifier_nn","title":"<code>classifier_nn(model, z_score_theta='independent', z_score_x='independent', hidden_features=50, embedding_net_theta=nn.Identity(), embedding_net_x=nn.Identity(), **kwargs)</code>","text":"<p>Returns a function that builds a classifier for learning density ratios.</p> <p>This function will usually be used for SNRE. The returned function is to be passed to the inference class when using the flexible interface.</p> <p>Note that in the view of the SNRE classifier we build below, x=theta and y=x.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The type of classifier that will be created. One of [<code>linear</code>, <code>mlp</code>, <code>resnet</code>].</p> required <code>z_score_theta</code> <code>Optional[str]</code> <p>Whether to z-score parameters \\(\\theta\\) before passing them into the network, can take one of the following: - <code>none</code>, or None: do not z-score. - <code>independent</code>: z-score each dimension independently. - <code>structured</code>: treat dimensions as related, therefore compute mean and std over the entire batch, instead of per-dimension. Should be used when each sample is, for example, a time series or an image.</p> <code>'independent'</code> <code>z_score_x</code> <code>Optional[str]</code> <p>Whether to z-score simulation outputs \\(x\\) before passing them into the network, same options as z_score_theta.</p> <code>'independent'</code> <code>hidden_features</code> <code>int</code> <p>Number of hidden features.</p> <code>50</code> <code>embedding_net_theta</code> <code>Module</code> <p>Optional embedding network for parameters \\(\\theta\\).</p> <code>Identity()</code> <code>embedding_net_x</code> <code>Module</code> <p>Optional embedding network for simulation outputs \\(x\\). This embedding net allows to learn features from potentially high-dimensional simulation outputs.</p> <code>Identity()</code> <code>kwargs</code> <code>Any</code> <p>additional custom arguments passed to downstream build functions.</p> <code>{}</code> Source code in <code>sbi/neural_nets/factory.py</code> <pre><code>def classifier_nn(\n    model: str,\n    z_score_theta: Optional[str] = \"independent\",\n    z_score_x: Optional[str] = \"independent\",\n    hidden_features: int = 50,\n    embedding_net_theta: nn.Module = nn.Identity(),\n    embedding_net_x: nn.Module = nn.Identity(),\n    **kwargs: Any,\n) -&gt; Callable:\n    r\"\"\"\n    Returns a function that builds a classifier for learning density ratios.\n\n    This function will usually be used for SNRE. The returned function is to be passed\n    to the inference class when using the flexible interface.\n\n    Note that in the view of the SNRE classifier we build below, x=theta and y=x.\n\n    Args:\n        model: The type of classifier that will be created. One of [`linear`, `mlp`,\n            `resnet`].\n        z_score_theta: Whether to z-score parameters $\\theta$ before passing them into\n            the network, can take one of the following:\n            - `none`, or None: do not z-score.\n            - `independent`: z-score each dimension independently.\n            - `structured`: treat dimensions as related, therefore compute mean and std\n            over the entire batch, instead of per-dimension. Should be used when each\n            sample is, for example, a time series or an image.\n        z_score_x: Whether to z-score simulation outputs $x$ before passing them into\n            the network, same options as z_score_theta.\n        hidden_features: Number of hidden features.\n        embedding_net_theta:  Optional embedding network for parameters $\\theta$.\n        embedding_net_x:  Optional embedding network for simulation outputs $x$. This\n            embedding net allows to learn features from potentially high-dimensional\n            simulation outputs.\n        kwargs: additional custom arguments passed to downstream build functions.\n    \"\"\"\n\n    kwargs = dict(\n        zip(\n            (\n                \"z_score_x\",\n                \"z_score_y\",\n                \"hidden_features\",\n                \"embedding_net_x\",\n                \"embedding_net_y\",\n            ),\n            (\n                z_score_theta,\n                z_score_x,\n                hidden_features,\n                check_net_device(embedding_net_theta, \"cpu\", embedding_net_warn_msg),\n                check_net_device(embedding_net_x, \"cpu\", embedding_net_warn_msg),\n            ),\n        ),\n        **kwargs,\n    )\n\n    def build_fn(batch_theta, batch_x):\n        if model == \"linear\":\n            return build_linear_classifier(\n                batch_x=batch_theta, batch_y=batch_x, **kwargs\n            )\n        if model == \"mlp\":\n            return build_mlp_classifier(batch_x=batch_theta, batch_y=batch_x, **kwargs)\n        if model == \"resnet\":\n            return build_resnet_classifier(\n                batch_x=batch_theta, batch_y=batch_x, **kwargs\n            )\n        else:\n            raise NotImplementedError\n\n    return build_fn\n</code></pre>"},{"location":"reference/models/#sbi.neural_nets.factory.flowmatching_nn","title":"<code>flowmatching_nn(model, z_score_theta='independent', z_score_x='independent', hidden_features=64, num_layers=5, num_blocks=5, num_frequencies=3, embedding_net=nn.Identity(), **kwargs)</code>","text":"<p>Returns a function that builds a neural net that can act as a vector field estimator for Flow Matching. This function will usually be used for Flow Matching. The returned function is to be passed to the</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>the type of regression network to learn the vector field. One of [\u2018mlp\u2019, \u2018resnet\u2019].</p> required <code>z_score_theta</code> <code>Optional[str]</code> <p>Whether to z-score parameters \\(\\theta\\) before passing them into the network, can take one of the following: - <code>none</code>, or None: do not z-score. - <code>independent</code>: z-score each dimension independently. - <code>structured</code>: treat dimensions as related, therefore compute mean and std over the entire batch, instead of per-dimension. Should be used when each sample is, for example, a time series or an image.</p> <code>'independent'</code> <code>z_score_x</code> <code>Optional[str]</code> <p>Whether to z-score simulation outputs \\(x\\) before passing them into the network, same options as z_score_theta.</p> <code>'independent'</code> <code>hidden_features</code> <code>int</code> <p>Number of hidden features.</p> <code>64</code> <code>num_layers</code> <code>int</code> <p>Number of transforms when a flow is used. Only relevant if density estimator is a normalizing flow (i.e. currently either a <code>maf</code> or a <code>nsf</code>). Ignored if density estimator is a <code>mdn</code> or <code>made</code>.</p> <code>5</code> <code>num_blocks</code> <code>int</code> <p>Number of blocks if a ResNet is used.</p> <code>5</code> <code>num_frequencies</code> <code>int</code> <p>Number of frequencies for the time embedding.</p> <code>3</code> <code>embedding_net</code> <code>Module</code> <p>Optional embedding network for the condition.</p> <code>Identity()</code> <code>kwargs</code> <code>Any</code> <p>additional custom arguments passed to downstream build functions.</p> <code>{}</code> Source code in <code>sbi/neural_nets/factory.py</code> <pre><code>def flowmatching_nn(\n    model: str,\n    z_score_theta: Optional[str] = \"independent\",\n    z_score_x: Optional[str] = \"independent\",\n    hidden_features: int = 64,\n    num_layers: int = 5,\n    num_blocks: int = 5,\n    num_frequencies: int = 3,\n    embedding_net: nn.Module = nn.Identity(),\n    **kwargs: Any,\n) -&gt; Callable:\n    r\"\"\"Returns a function that builds a neural net that can act as\n    a vector field estimator for Flow Matching. This function will usually\n    be used for Flow Matching. The returned function is to be passed to the\n\n    Args:\n        model: the type of regression network to learn the vector field. One of ['mlp',\n            'resnet'].\n        z_score_theta: Whether to z-score parameters $\\theta$ before passing them into\n            the network, can take one of the following:\n            - `none`, or None: do not z-score.\n            - `independent`: z-score each dimension independently.\n            - `structured`: treat dimensions as related, therefore compute mean and std\n            over the entire batch, instead of per-dimension. Should be used when each\n            sample is, for example, a time series or an image.\n        z_score_x: Whether to z-score simulation outputs $x$ before passing them into\n            the network, same options as z_score_theta.\n        hidden_features: Number of hidden features.\n        num_layers: Number of transforms when a flow is used. Only relevant if\n            density estimator is a normalizing flow (i.e. currently either a `maf` or a\n            `nsf`). Ignored if density estimator is a `mdn` or `made`.\n        num_blocks: Number of blocks if a ResNet is used.\n        num_frequencies: Number of frequencies for the time embedding.\n        embedding_net: Optional embedding network for the condition.\n        kwargs: additional custom arguments passed to downstream build functions.\n    \"\"\"\n    implemented_models = [\"mlp\", \"resnet\"]\n\n    if model not in implemented_models:\n        raise NotImplementedError(f\"Model {model} in not implemented for FMPE\")\n\n    model_str = model + \"_flowmatcher\"\n\n    def build_fn(batch_theta, batch_x):\n        return model_builders[model_str](\n            batch_x=batch_theta,\n            batch_y=batch_x,\n            z_score_x=z_score_theta,\n            z_score_y=z_score_x,\n            hidden_features=hidden_features,\n            num_layers=num_layers,\n            num_blocks=num_blocks,\n            num_freqs=num_frequencies,\n            embedding_net=check_net_device(\n                embedding_net, \"cpu\", embedding_net_warn_msg\n            ),\n            **kwargs,\n        )\n\n    return build_fn\n</code></pre>"},{"location":"reference/models/#sbi.neural_nets.factory.posterior_score_nn","title":"<code>posterior_score_nn(sde_type, score_net_type='mlp', z_score_theta='independent', z_score_x='independent', t_embedding_dim=16, hidden_features=50, embedding_net=nn.Identity(), **kwargs)</code>","text":"<p>Build util function that builds a ScoreEstimator object for score-based posteriors.</p> <p>Parameters:</p> Name Type Description Default <code>sde_type</code> <code>str</code> <p>SDE type used, which defines the mean and std functions. One of: - \u2018vp\u2019: Variance preserving. - \u2018subvp\u2019: Sub-variance preserving. - \u2018ve\u2019: Variance exploding. Defaults to \u2018vp\u2019.</p> required <code>score_net</code> <p>Type of regression network. One of: - \u2018mlp\u2019: Fully connected feed-forward network. - \u2018resnet\u2019: Residual network (NOT IMPLEMENTED). -  nn.Module: Custom network Defaults to \u2018mlp\u2019.</p> required <code>z_score_theta</code> <code>Optional[str]</code> <p>Whether to z-score thetas passing into the network, can be one of: - <code>none</code>, or None: do not z-score. - <code>independent</code>: z-score each dimension independently. - <code>structured</code>: treat dimensions as related, therefore compute mean and std over the entire batch, instead of per-dimension. Should be used when each sample is, for example, a time series or an image.</p> <code>'independent'</code> <code>z_score_x</code> <code>Optional[str]</code> <p>Whether to z-score xs passing into the network, same options as z_score_theta.</p> <code>'independent'</code> <code>t_embedding_dim</code> <code>int</code> <p>Embedding dimension of diffusion time. Defaults to 16.</p> <code>16</code> <code>hidden_features</code> <code>int</code> <p>Number of hidden units per layer. Defaults to 50.</p> <code>50</code> <code>embedding_net</code> <code>Module</code> <p>Embedding network for x (conditioning variable). Defaults to nn.Identity().</p> <code>Identity()</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Constructor function for NPSE.</p> Source code in <code>sbi/neural_nets/factory.py</code> <pre><code>def posterior_score_nn(\n    sde_type: str,\n    score_net_type: Union[str, nn.Module] = \"mlp\",\n    z_score_theta: Optional[str] = \"independent\",\n    z_score_x: Optional[str] = \"independent\",\n    t_embedding_dim: int = 16,\n    hidden_features: int = 50,\n    embedding_net: nn.Module = nn.Identity(),\n    **kwargs: Any,\n) -&gt; Callable:\n    \"\"\"Build util function that builds a ScoreEstimator object for score-based\n    posteriors.\n\n    Args:\n        sde_type: SDE type used, which defines the mean and std functions. One of:\n            - 'vp': Variance preserving.\n            - 'subvp': Sub-variance preserving.\n            - 've': Variance exploding.\n            Defaults to 'vp'.\n        score_net: Type of regression network. One of:\n            - 'mlp': Fully connected feed-forward network.\n            - 'resnet': Residual network (NOT IMPLEMENTED).\n            -  nn.Module: Custom network\n            Defaults to 'mlp'.\n        z_score_theta: Whether to z-score thetas passing into the network, can be one\n            of:\n            - `none`, or None: do not z-score.\n            - `independent`: z-score each dimension independently.\n            - `structured`: treat dimensions as related, therefore compute mean and std\n            over the entire batch, instead of per-dimension. Should be used when each\n            sample is, for example, a time series or an image.\n        z_score_x: Whether to z-score xs passing into the network, same options as\n            z_score_theta.\n        t_embedding_dim: Embedding dimension of diffusion time. Defaults to 16.\n        hidden_features: Number of hidden units per layer. Defaults to 50.\n        embedding_net: Embedding network for x (conditioning variable). Defaults to\n            nn.Identity().\n\n    Returns:\n        Constructor function for NPSE.\n    \"\"\"\n\n    kwargs = dict(\n        zip(\n            (\n                \"z_score_x\",\n                \"z_score_y\",\n                \"sde_type\",\n                \"score_net\",\n                \"t_embedding_dim\",\n                \"hidden_features\",\n                \"embedding_net_y\",\n            ),\n            (\n                z_score_theta,\n                z_score_x,\n                sde_type,\n                score_net_type,\n                t_embedding_dim,\n                hidden_features,\n                embedding_net,\n            ),\n        ),\n        **kwargs,\n    )\n\n    def build_fn(batch_theta, batch_x):\n        \"\"\"Build function wrapper for the build_score_estimator function that\n        is required for the score posterior class.\n\n        Args:\n            batch_theta: a batch of theta.\n            batch_x: a batch of x.\n\n        Returns:\n            Callable: a ScoreEstimator object.\n        \"\"\"\n        return build_score_estimator(batch_x=batch_theta, batch_y=batch_x, **kwargs)\n\n    return build_fn\n</code></pre>"},{"location":"reference/models/#sbi.neural_nets.estimators.ConditionalDensityEstimator","title":"<code>ConditionalDensityEstimator</code>","text":"<p>               Bases: <code>ConditionalEstimator</code></p> <p>Base class for density estimators.</p> <p>The density estimator class is a wrapper around neural networks that allows to evaluate the <code>log_prob</code>, <code>sample</code>, and provide the <code>loss</code> of \\(\\theta,x\\) pairs. Here \\(\\theta\\) would be the <code>input</code> and \\(x\\) would be the <code>condition</code>.</p> Note <p>We assume that the input to the density estimator is a tensor of shape (batch_size, input_size), where input_size is the dimensionality of the input. The condition is a tensor of shape (batch_size, *condition_shape), where condition_shape is the shape of the condition tensor.</p> Source code in <code>sbi/neural_nets/estimators/base.py</code> <pre><code>class ConditionalDensityEstimator(ConditionalEstimator):\n    r\"\"\"Base class for density estimators.\n\n    The density estimator class is a wrapper around neural networks that\n    allows to evaluate the `log_prob`, `sample`, and provide the `loss` of $\\theta,x$\n    pairs. Here $\\theta$ would be the `input` and $x$ would be the `condition`.\n\n    Note:\n        We assume that the input to the density estimator is a tensor of shape\n        (batch_size, input_size), where input_size is the dimensionality of the input.\n        The condition is a tensor of shape (batch_size, *condition_shape), where\n        condition_shape is the shape of the condition tensor.\n\n    \"\"\"\n\n    def __init__(\n        self, net: nn.Module, input_shape: torch.Size, condition_shape: torch.Size\n    ) -&gt; None:\n        r\"\"\"Base class for density estimators.\n\n        Args:\n            net: Neural network or any parameterized model that is used to estimate the\n                probability density of the input given a condition.\n            input_shape: Event shape of the input at which the density is being\n                evaluated (and which is also the event_shape of samples).\n            condition_shape: Shape of the condition.\n        \"\"\"\n        super().__init__(input_shape, condition_shape)\n        self.net = net\n\n    @property\n    def embedding_net(self) -&gt; Optional[nn.Module]:\n        r\"\"\"Return the embedding network if it exists.\"\"\"\n        return None\n\n    @abstractmethod\n    def log_prob(self, input: Tensor, condition: Tensor, **kwargs) -&gt; Tensor:\n        r\"\"\"Return the log probabilities of the inputs given a condition or multiple\n        i.e. batched conditions.\n\n        Args:\n            input: Inputs to evaluate the log probability on of shape\n                    `(sample_dim_input, batch_dim_input, *event_shape_input)`.\n            condition: Conditions of shape\n                `(batch_dim_condition, *event_shape_condition)`.\n\n        Raises:\n            RuntimeError: If batch_dim_input and batch_dim_condition do not match.\n\n        Returns:\n            Sample-wise log probabilities.\n        \"\"\"\n\n        pass\n\n    @abstractmethod\n    def loss(self, input: Tensor, condition: Tensor, **kwargs) -&gt; Tensor:\n        r\"\"\"Return the loss for training the density estimator.\n\n        Args:\n            input: Inputs to evaluate the loss on of shape\n                `(batch_dim, *input_event_shape)`.\n            condition: Conditions of shape `(batch_dim, *event_shape_condition)`.\n\n        Returns:\n            Loss of shape (batch_dim,)\n        \"\"\"\n\n        pass\n\n    @abstractmethod\n    def sample(self, sample_shape: torch.Size, condition: Tensor, **kwargs) -&gt; Tensor:\n        r\"\"\"Return samples from the density estimator.\n\n        Args:\n            sample_shape: Shape of the samples to return.\n            condition: Conditions of shape `(batch_dim, *event_shape_condition)`.\n\n        Returns:\n            Samples of shape (*sample_shape, batch_dim, *event_shape_input).\n        \"\"\"\n\n        pass\n\n    def sample_and_log_prob(\n        self, sample_shape: torch.Size, condition: Tensor, **kwargs\n    ) -&gt; Tuple[Tensor, Tensor]:\n        r\"\"\"Return samples and their density from the density estimator.\n\n        Args:\n            sample_shape: Shape of the samples to return.\n            condition: Conditions of shape `(batch_dim, *event_shape_condition)`.\n\n        Returns:\n            Samples and associated log probabilities.\n\n        Note:\n            For some density estimators, computing log_probs for samples is\n            more efficient than computing them separately. This method should\n            then be overwritten to provide a more efficient implementation.\n        \"\"\"\n\n        samples = self.sample(sample_shape, condition, **kwargs)\n        log_probs = self.log_prob(samples, condition, **kwargs)\n        return samples, log_probs\n</code></pre>"},{"location":"reference/models/#sbi.neural_nets.estimators.ConditionalDensityEstimator.embedding_net","title":"<code>embedding_net: Optional[nn.Module]</code>  <code>property</code>","text":"<p>Return the embedding network if it exists.</p>"},{"location":"reference/models/#sbi.neural_nets.estimators.ConditionalDensityEstimator.__init__","title":"<code>__init__(net, input_shape, condition_shape)</code>","text":"<p>Base class for density estimators.</p> <p>Parameters:</p> Name Type Description Default <code>net</code> <code>Module</code> <p>Neural network or any parameterized model that is used to estimate the probability density of the input given a condition.</p> required <code>input_shape</code> <code>Size</code> <p>Event shape of the input at which the density is being evaluated (and which is also the event_shape of samples).</p> required <code>condition_shape</code> <code>Size</code> <p>Shape of the condition.</p> required Source code in <code>sbi/neural_nets/estimators/base.py</code> <pre><code>def __init__(\n    self, net: nn.Module, input_shape: torch.Size, condition_shape: torch.Size\n) -&gt; None:\n    r\"\"\"Base class for density estimators.\n\n    Args:\n        net: Neural network or any parameterized model that is used to estimate the\n            probability density of the input given a condition.\n        input_shape: Event shape of the input at which the density is being\n            evaluated (and which is also the event_shape of samples).\n        condition_shape: Shape of the condition.\n    \"\"\"\n    super().__init__(input_shape, condition_shape)\n    self.net = net\n</code></pre>"},{"location":"reference/models/#sbi.neural_nets.estimators.ConditionalDensityEstimator.log_prob","title":"<code>log_prob(input, condition, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Return the log probabilities of the inputs given a condition or multiple i.e. batched conditions.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Tensor</code> <p>Inputs to evaluate the log probability on of shape     <code>(sample_dim_input, batch_dim_input, *event_shape_input)</code>.</p> required <code>condition</code> <code>Tensor</code> <p>Conditions of shape <code>(batch_dim_condition, *event_shape_condition)</code>.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If batch_dim_input and batch_dim_condition do not match.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>Sample-wise log probabilities.</p> Source code in <code>sbi/neural_nets/estimators/base.py</code> <pre><code>@abstractmethod\ndef log_prob(self, input: Tensor, condition: Tensor, **kwargs) -&gt; Tensor:\n    r\"\"\"Return the log probabilities of the inputs given a condition or multiple\n    i.e. batched conditions.\n\n    Args:\n        input: Inputs to evaluate the log probability on of shape\n                `(sample_dim_input, batch_dim_input, *event_shape_input)`.\n        condition: Conditions of shape\n            `(batch_dim_condition, *event_shape_condition)`.\n\n    Raises:\n        RuntimeError: If batch_dim_input and batch_dim_condition do not match.\n\n    Returns:\n        Sample-wise log probabilities.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/models/#sbi.neural_nets.estimators.ConditionalDensityEstimator.loss","title":"<code>loss(input, condition, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Return the loss for training the density estimator.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Tensor</code> <p>Inputs to evaluate the loss on of shape <code>(batch_dim, *input_event_shape)</code>.</p> required <code>condition</code> <code>Tensor</code> <p>Conditions of shape <code>(batch_dim, *event_shape_condition)</code>.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Loss of shape (batch_dim,)</p> Source code in <code>sbi/neural_nets/estimators/base.py</code> <pre><code>@abstractmethod\ndef loss(self, input: Tensor, condition: Tensor, **kwargs) -&gt; Tensor:\n    r\"\"\"Return the loss for training the density estimator.\n\n    Args:\n        input: Inputs to evaluate the loss on of shape\n            `(batch_dim, *input_event_shape)`.\n        condition: Conditions of shape `(batch_dim, *event_shape_condition)`.\n\n    Returns:\n        Loss of shape (batch_dim,)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/models/#sbi.neural_nets.estimators.ConditionalDensityEstimator.sample","title":"<code>sample(sample_shape, condition, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Return samples from the density estimator.</p> <p>Parameters:</p> Name Type Description Default <code>sample_shape</code> <code>Size</code> <p>Shape of the samples to return.</p> required <code>condition</code> <code>Tensor</code> <p>Conditions of shape <code>(batch_dim, *event_shape_condition)</code>.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>Samples of shape (*sample_shape, batch_dim, *event_shape_input).</p> Source code in <code>sbi/neural_nets/estimators/base.py</code> <pre><code>@abstractmethod\ndef sample(self, sample_shape: torch.Size, condition: Tensor, **kwargs) -&gt; Tensor:\n    r\"\"\"Return samples from the density estimator.\n\n    Args:\n        sample_shape: Shape of the samples to return.\n        condition: Conditions of shape `(batch_dim, *event_shape_condition)`.\n\n    Returns:\n        Samples of shape (*sample_shape, batch_dim, *event_shape_input).\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/models/#sbi.neural_nets.estimators.ConditionalDensityEstimator.sample_and_log_prob","title":"<code>sample_and_log_prob(sample_shape, condition, **kwargs)</code>","text":"<p>Return samples and their density from the density estimator.</p> <p>Parameters:</p> Name Type Description Default <code>sample_shape</code> <code>Size</code> <p>Shape of the samples to return.</p> required <code>condition</code> <code>Tensor</code> <p>Conditions of shape <code>(batch_dim, *event_shape_condition)</code>.</p> required <p>Returns:</p> Type Description <code>Tuple[Tensor, Tensor]</code> <p>Samples and associated log probabilities.</p> Note <p>For some density estimators, computing log_probs for samples is more efficient than computing them separately. This method should then be overwritten to provide a more efficient implementation.</p> Source code in <code>sbi/neural_nets/estimators/base.py</code> <pre><code>def sample_and_log_prob(\n    self, sample_shape: torch.Size, condition: Tensor, **kwargs\n) -&gt; Tuple[Tensor, Tensor]:\n    r\"\"\"Return samples and their density from the density estimator.\n\n    Args:\n        sample_shape: Shape of the samples to return.\n        condition: Conditions of shape `(batch_dim, *event_shape_condition)`.\n\n    Returns:\n        Samples and associated log probabilities.\n\n    Note:\n        For some density estimators, computing log_probs for samples is\n        more efficient than computing them separately. This method should\n        then be overwritten to provide a more efficient implementation.\n    \"\"\"\n\n    samples = self.sample(sample_shape, condition, **kwargs)\n    log_probs = self.log_prob(samples, condition, **kwargs)\n    return samples, log_probs\n</code></pre>"},{"location":"reference/posteriors/","title":"Posteriors","text":""},{"location":"reference/posteriors/#sbi.inference.posteriors.direct_posterior.DirectPosterior","title":"<code>DirectPosterior</code>","text":"<p>               Bases: <code>NeuralPosterior</code></p> <p>Posterior \\(p(\\theta|x_o)\\) with <code>log_prob()</code> and <code>sample()</code> methods, only applicable to SNPE. SNPE trains a neural network to directly approximate the posterior distribution. However, for bounded priors, the neural network can have leakage: it puts non-zero mass in regions where the prior is zero. The <code>DirectPosterior</code> class wraps the trained network to deal with these cases. Specifically, this class offers the following functionality: - correct the calculation of the log probability such that it compensates for the   leakage. - reject samples that lie outside of the prior bounds. This class can not be used in combination with SNLE or SNRE.</p> Source code in <code>sbi/inference/posteriors/direct_posterior.py</code> <pre><code>class DirectPosterior(NeuralPosterior):\n    r\"\"\"Posterior $p(\\theta|x_o)$ with `log_prob()` and `sample()` methods, only\n    applicable to SNPE.&lt;br/&gt;&lt;br/&gt;\n    SNPE trains a neural network to directly approximate the posterior distribution.\n    However, for bounded priors, the neural network can have leakage: it puts non-zero\n    mass in regions where the prior is zero. The `DirectPosterior` class wraps the\n    trained network to deal with these cases.&lt;br/&gt;&lt;br/&gt;\n    Specifically, this class offers the following functionality:&lt;br/&gt;\n    - correct the calculation of the log probability such that it compensates for the\n      leakage.&lt;br/&gt;\n    - reject samples that lie outside of the prior bounds.&lt;br/&gt;&lt;br/&gt;\n    This class can not be used in combination with SNLE or SNRE.\n    \"\"\"\n\n    def __init__(\n        self,\n        posterior_estimator: ConditionalDensityEstimator,\n        prior: Distribution,\n        max_sampling_batch_size: int = 10_000,\n        device: Optional[str] = None,\n        x_shape: Optional[torch.Size] = None,\n        enable_transform: bool = True,\n    ):\n        \"\"\"\n        Args:\n            prior: Prior distribution with `.log_prob()` and `.sample()`.\n            posterior_estimator: The trained neural posterior.\n            max_sampling_batch_size: Batchsize of samples being drawn from\n                the proposal at every iteration.\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:0\". If None,\n                `potential_fn.device` is used.\n            x_shape: Deprecated, should not be passed.\n            enable_transform: Whether to transform parameters to unconstrained space\n                during MAP optimization. When False, an identity transform will be\n                returned for `theta_transform`.\n        \"\"\"\n        # Because `DirectPosterior` does not take the `potential_fn` as input, it\n        # builds it itself. The `potential_fn` and `theta_transform` are used only for\n        # obtaining the MAP.\n        check_prior(prior)\n        potential_fn, theta_transform = posterior_estimator_based_potential(\n            posterior_estimator,\n            prior,\n            x_o=None,\n            enable_transform=enable_transform,\n        )\n\n        super().__init__(\n            potential_fn=potential_fn,\n            theta_transform=theta_transform,\n            device=device,\n            x_shape=x_shape,\n        )\n\n        self.prior = prior\n        self.posterior_estimator = posterior_estimator\n\n        self.max_sampling_batch_size = max_sampling_batch_size\n        self._leakage_density_correction_factor = None\n\n        self._purpose = \"\"\"It samples the posterior network and rejects samples that\n            lie outside of the prior bounds.\"\"\"\n\n    def sample(\n        self,\n        sample_shape: Shape = torch.Size(),\n        x: Optional[Tensor] = None,\n        max_sampling_batch_size: int = 10_000,\n        sample_with: Optional[str] = None,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        r\"\"\"Return samples from posterior distribution $p(\\theta|x)$.\n\n        Args:\n            sample_shape: Desired shape of samples that are drawn from posterior. If\n                sample_shape is multidimensional we simply draw `sample_shape.numel()`\n                samples and then reshape into the desired shape.\n            sample_with: This argument only exists to keep backward-compatibility with\n                `sbi` v0.17.2 or older. If it is set, we instantly raise an error.\n            show_progress_bars: Whether to show sampling progress monitor.\n        \"\"\"\n        num_samples = torch.Size(sample_shape).numel()\n        x = self._x_else_default_x(x)\n        x = reshape_to_batch_event(\n            x, event_shape=self.posterior_estimator.condition_shape\n        )\n        if x.shape[0] &gt; 1:\n            raise ValueError(\n                \".sample() supports only `batchsize == 1`. If you intend \"\n                \"to sample multiple observations, use `.sample_batched()`. \"\n                \"If you intend to sample i.i.d. observations, set up the \"\n                \"posterior density estimator with an appropriate permutation \"\n                \"invariant embedding net.\"\n            )\n\n        max_sampling_batch_size = (\n            self.max_sampling_batch_size\n            if max_sampling_batch_size is None\n            else max_sampling_batch_size\n        )\n\n        if sample_with is not None:\n            raise ValueError(\n                f\"You set `sample_with={sample_with}`. As of sbi v0.18.0, setting \"\n                f\"`sample_with` is no longer supported. You have to rerun \"\n                f\"`.build_posterior(sample_with={sample_with}).`\"\n            )\n\n        samples = rejection.accept_reject_sample(\n            proposal=self.posterior_estimator,\n            accept_reject_fn=lambda theta: within_support(self.prior, theta),\n            num_samples=num_samples,\n            show_progress_bars=show_progress_bars,\n            max_sampling_batch_size=max_sampling_batch_size,\n            proposal_sampling_kwargs={\"condition\": x},\n            alternative_method=\"build_posterior(..., sample_with='mcmc')\",\n        )[0]  # [0] to return only samples, not acceptance probabilities.\n\n        return samples[:, 0]  # Remove batch dimension.\n\n    def sample_batched(\n        self,\n        sample_shape: Shape,\n        x: Tensor,\n        max_sampling_batch_size: int = 10_000,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        r\"\"\"Given a batch of observations [x_1, ..., x_B] this function samples from\n        posteriors $p(\\theta|x_1)$, ... ,$p(\\theta|x_B)$, in a batched (i.e. vectorized)\n        manner.\n\n        Args:\n            sample_shape: Desired shape of samples that are drawn from the posterior\n                given every observation.\n            x: A batch of observations, of shape `(batch_dim, event_shape_x)`.\n                `batch_dim` corresponds to the number of observations to be drawn.\n            max_sampling_batch_size: Maximum batch size for rejection sampling.\n            show_progress_bars: Whether to show sampling progress monitor.\n\n        Returns:\n            Samples from the posteriors of shape (*sample_shape, B, *input_shape)\n        \"\"\"\n        num_samples = torch.Size(sample_shape).numel()\n        condition_shape = self.posterior_estimator.condition_shape\n        x = reshape_to_batch_event(x, event_shape=condition_shape)\n\n        max_sampling_batch_size = (\n            self.max_sampling_batch_size\n            if max_sampling_batch_size is None\n            else max_sampling_batch_size\n        )\n\n        samples = rejection.accept_reject_sample(\n            proposal=self.posterior_estimator,\n            accept_reject_fn=lambda theta: within_support(self.prior, theta),\n            num_samples=num_samples,\n            show_progress_bars=show_progress_bars,\n            max_sampling_batch_size=max_sampling_batch_size,\n            proposal_sampling_kwargs={\"condition\": x},\n            alternative_method=\"build_posterior(..., sample_with='mcmc')\",\n        )[0]\n\n        return samples\n\n    def log_prob(\n        self,\n        theta: Tensor,\n        x: Optional[Tensor] = None,\n        norm_posterior: bool = True,\n        track_gradients: bool = False,\n        leakage_correction_params: Optional[dict] = None,\n    ) -&gt; Tensor:\n        r\"\"\"Returns the log-probability of the posterior $p(\\theta|x)$.\n\n        Args:\n            theta: Parameters $\\theta$.\n            norm_posterior: Whether to enforce a normalized posterior density.\n                Renormalization of the posterior is useful when some\n                probability falls out or leaks out of the prescribed prior support.\n                The normalizing factor is calculated via rejection sampling, so if you\n                need speedier but unnormalized log posterior estimates set here\n                `norm_posterior=False`. The returned log posterior is set to\n                -\u221e outside of the prior support regardless of this setting.\n            track_gradients: Whether the returned tensor supports tracking gradients.\n                This can be helpful for e.g. sensitivity analysis, but increases memory\n                consumption.\n            leakage_correction_params: A `dict` of keyword arguments to override the\n                default values of `leakage_correction()`. Possible options are:\n                `num_rejection_samples`, `force_update`, `show_progress_bars`, and\n                `rejection_sampling_batch_size`.\n                These parameters only have an effect if `norm_posterior=True`.\n\n        Returns:\n            `(len(\u03b8),)`-shaped log posterior probability $\\log p(\\theta|x)$ for \u03b8 in the\n            support of the prior, -\u221e (corresponding to 0 probability) outside.\n        \"\"\"\n        x = self._x_else_default_x(x)\n\n        theta = ensure_theta_batched(torch.as_tensor(theta))\n        theta_density_estimator = reshape_to_sample_batch_event(\n            theta, theta.shape[1:], leading_is_sample=True\n        )\n        x_density_estimator = reshape_to_batch_event(\n            x, event_shape=self.posterior_estimator.condition_shape\n        )\n        if x_density_estimator.shape[0] &gt; 1:\n            raise ValueError(\n                \".log_prob() supports only `batchsize == 1`. If you intend \"\n                \"to evaluate given multiple observations, use `.log_prob_batched()`. \"\n                \"If you intend to evaluate given i.i.d. observations, set up the \"\n                \"posterior density estimator with an appropriate permutation \"\n                \"invariant embedding net.\"\n            )\n\n        self.posterior_estimator.eval()\n\n        with torch.set_grad_enabled(track_gradients):\n            # Evaluate on device, move back to cpu for comparison with prior.\n            unnorm_log_prob = self.posterior_estimator.log_prob(\n                theta_density_estimator, condition=x_density_estimator\n            )\n            # `log_prob` supports only a single observation (i.e. `batchsize==1`).\n            # We now remove this additional dimension.\n            unnorm_log_prob = unnorm_log_prob.squeeze(dim=1)\n\n            # Force probability to be zero outside prior support.\n            in_prior_support = within_support(self.prior, theta)\n\n            masked_log_prob = torch.where(\n                in_prior_support,\n                unnorm_log_prob,\n                torch.tensor(float(\"-inf\"), dtype=torch.float32, device=self._device),\n            )\n\n            if leakage_correction_params is None:\n                leakage_correction_params = dict()  # use defaults\n            log_factor = (\n                log(self.leakage_correction(x=x, **leakage_correction_params))\n                if norm_posterior\n                else 0\n            )\n\n            return masked_log_prob - log_factor\n\n    def log_prob_batched(\n        self,\n        theta: Tensor,\n        x: Tensor,\n        norm_posterior: bool = True,\n        track_gradients: bool = False,\n        leakage_correction_params: Optional[dict] = None,\n    ) -&gt; Tensor:\n        \"\"\"Given a batch of observations [x_1, ..., x_B] and a batch of parameters \\\n            [$\\theta_1$,..., $\\theta_B$] this function evalautes the log-probabilities \\\n            of the posteriors $p(\\theta_1|x_1)$, ..., $p(\\theta_B|x_B)$ in a batched \\\n            (i.e. vectorized) manner.\n\n        Args:\n            theta: Batch of parameters $\\theta$ of shape \\\n                `(*sample_shape, batch_dim, *theta_shape)`.\n            x: Batch of observations $x$ of shape \\\n                `(batch_dim, *condition_shape)`.\n            norm_posterior: Whether to enforce a normalized posterior density.\n                Renormalization of the posterior is useful when some\n                probability falls out or leaks out of the prescribed prior support.\n                The normalizing factor is calculated via rejection sampling, so if you\n                need speedier but unnormalized log posterior estimates set here\n                `norm_posterior=False`. The returned log posterior is set to\n                -\u221e outside of the prior support regardless of this setting.\n            track_gradients: Whether the returned tensor supports tracking gradients.\n                This can be helpful for e.g. sensitivity analysis, but increases memory\n                consumption.\n            leakage_correction_params: A `dict` of keyword arguments to override the\n                default values of `leakage_correction()`. Possible options are:\n                `num_rejection_samples`, `force_update`, `show_progress_bars`, and\n                `rejection_sampling_batch_size`.\n                These parameters only have an effect if `norm_posterior=True`.\n\n        Returns:\n            `(len(\u03b8), B)`-shaped log posterior probability $\\\\log p(\\theta|x)$\\\\ for \u03b8 \\\n            in the support of the prior, -\u221e (corresponding to 0 probability) outside.\n        \"\"\"\n\n        theta = ensure_theta_batched(torch.as_tensor(theta))\n        event_shape = self.posterior_estimator.input_shape\n        theta_density_estimator = reshape_to_sample_batch_event(\n            theta, event_shape, leading_is_sample=True\n        )\n        x_density_estimator = reshape_to_batch_event(\n            x, event_shape=self.posterior_estimator.condition_shape\n        )\n\n        self.posterior_estimator.eval()\n\n        with torch.set_grad_enabled(track_gradients):\n            # Evaluate on device, move back to cpu for comparison with prior.\n            unnorm_log_prob = self.posterior_estimator.log_prob(\n                theta_density_estimator, condition=x_density_estimator\n            )\n\n            # Force probability to be zero outside prior support.\n            in_prior_support = within_support(self.prior, theta)\n\n            masked_log_prob = torch.where(\n                in_prior_support,\n                unnorm_log_prob,\n                torch.tensor(float(\"-inf\"), dtype=torch.float32, device=self._device),\n            )\n\n            if leakage_correction_params is None:\n                leakage_correction_params = dict()  # use defaults\n            log_factor = (\n                log(self.leakage_correction(x=x, **leakage_correction_params))\n                if norm_posterior\n                else 0\n            )\n\n            return masked_log_prob - log_factor\n\n    @torch.no_grad()\n    def leakage_correction(\n        self,\n        x: Tensor,\n        num_rejection_samples: int = 10_000,\n        force_update: bool = False,\n        show_progress_bars: bool = False,\n        rejection_sampling_batch_size: int = 10_000,\n    ) -&gt; Tensor:\n        r\"\"\"Return leakage correction factor for a leaky posterior density estimate.\n\n        The factor is estimated from the acceptance probability during rejection\n        sampling from the posterior.\n\n        This is to avoid re-estimating the acceptance probability from scratch\n        whenever `log_prob` is called and `norm_posterior=True`. Here, it\n        is estimated only once for `self.default_x` and saved for later. We\n        re-evaluate only whenever a new `x` is passed.\n\n        Arguments:\n            num_rejection_samples: Number of samples used to estimate correction factor.\n            show_progress_bars: Whether to show a progress bar during sampling.\n            rejection_sampling_batch_size: Batch size for rejection sampling.\n\n        Returns:\n            Saved or newly-estimated correction factor (as a scalar `Tensor`).\n        \"\"\"\n\n        def acceptance_at(x: Tensor) -&gt; Tensor:\n            # [1:] to remove batch-dimension for `reshape_to_batch_event`.\n            return rejection.accept_reject_sample(\n                proposal=self.posterior_estimator,\n                accept_reject_fn=lambda theta: within_support(self.prior, theta),\n                num_samples=num_rejection_samples,\n                show_progress_bars=show_progress_bars,\n                sample_for_correction_factor=True,\n                max_sampling_batch_size=rejection_sampling_batch_size,\n                proposal_sampling_kwargs={\n                    \"condition\": reshape_to_batch_event(\n                        x, event_shape=self.posterior_estimator.condition_shape\n                    )\n                },\n            )[1]\n\n        # Check if the provided x matches the default x (short-circuit on identity).\n        is_new_x = self.default_x is None or (\n            x is not self.default_x and (x != self.default_x).any()\n        )\n\n        not_saved_at_default_x = self._leakage_density_correction_factor is None\n\n        if is_new_x:  # Calculate at x; don't save.\n            return acceptance_at(x)\n        elif not_saved_at_default_x or force_update:  # Calculate at default_x; save.\n            assert self.default_x is not None\n            self._leakage_density_correction_factor = acceptance_at(self.default_x)\n\n        return self._leakage_density_correction_factor  # type: ignore\n\n    def map(\n        self,\n        x: Optional[Tensor] = None,\n        num_iter: int = 1_000,\n        num_to_optimize: int = 100,\n        learning_rate: float = 0.01,\n        init_method: Union[str, Tensor] = \"posterior\",\n        num_init_samples: int = 1_000,\n        save_best_every: int = 10,\n        show_progress_bars: bool = False,\n        force_update: bool = False,\n    ) -&gt; Tensor:\n        r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n        The method can be interrupted (Ctrl-C) when the user sees that the\n        log-probability converges. The best estimate will be saved in `self._map` and\n        can be accessed with `self.map()`. The MAP is obtained by running gradient\n        ascent from a given number of starting positions (samples from the posterior\n        with the highest log-probability). After the optimization is done, we select the\n        parameter set that has the highest log-probability after the optimization.\n\n        Warning: The default values used by this function are not well-tested. They\n        might require hand-tuning for the problem at hand.\n\n        For developers: if the prior is a `BoxUniform`, we carry out the optimization\n        in unbounded space and transform the result back into bounded space.\n\n        Args:\n            x: Deprecated - use `.set_default_x()` prior to `.map()`.\n            num_iter: Number of optimization steps that the algorithm takes\n                to find the MAP.\n            learning_rate: Learning rate of the optimizer.\n            init_method: How to select the starting parameters for the optimization. If\n                it is a string, it can be either [`posterior`, `prior`], which samples\n                the respective distribution `num_init_samples` times. If it is a\n                tensor, the tensor will be used as init locations.\n            num_init_samples: Draw this number of samples from the posterior and\n                evaluate the log-probability of all of them.\n            num_to_optimize: From the drawn `num_init_samples`, use the\n                `num_to_optimize` with highest log-probability as the initial points\n                for the optimization.\n            save_best_every: The best log-probability is computed, saved in the\n                `map`-attribute, and printed every `save_best_every`-th iteration.\n                Computing the best log-probability creates a significant overhead\n                (thus, the default is `10`.)\n            show_progress_bars: Whether to show a progressbar during sampling from the\n                posterior.\n            force_update: Whether to re-calculate the MAP when x is unchanged and\n                have a cached value.\n            log_prob_kwargs: Will be empty for SNLE and SNRE. Will contain\n                {'norm_posterior': True} for SNPE.\n\n        Returns:\n            The MAP estimate.\n        \"\"\"\n        return super().map(\n            x=x,\n            num_iter=num_iter,\n            num_to_optimize=num_to_optimize,\n            learning_rate=learning_rate,\n            init_method=init_method,\n            num_init_samples=num_init_samples,\n            save_best_every=save_best_every,\n            show_progress_bars=show_progress_bars,\n            force_update=force_update,\n        )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.direct_posterior.DirectPosterior.__init__","title":"<code>__init__(posterior_estimator, prior, max_sampling_batch_size=10000, device=None, x_shape=None, enable_transform=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Distribution</code> <p>Prior distribution with <code>.log_prob()</code> and <code>.sample()</code>.</p> required <code>posterior_estimator</code> <code>ConditionalDensityEstimator</code> <p>The trained neural posterior.</p> required <code>max_sampling_batch_size</code> <code>int</code> <p>Batchsize of samples being drawn from the proposal at every iteration.</p> <code>10000</code> <code>device</code> <code>Optional[str]</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:0\u201d. If None, <code>potential_fn.device</code> is used.</p> <code>None</code> <code>x_shape</code> <code>Optional[Size]</code> <p>Deprecated, should not be passed.</p> <code>None</code> <code>enable_transform</code> <code>bool</code> <p>Whether to transform parameters to unconstrained space during MAP optimization. When False, an identity transform will be returned for <code>theta_transform</code>.</p> <code>True</code> Source code in <code>sbi/inference/posteriors/direct_posterior.py</code> <pre><code>def __init__(\n    self,\n    posterior_estimator: ConditionalDensityEstimator,\n    prior: Distribution,\n    max_sampling_batch_size: int = 10_000,\n    device: Optional[str] = None,\n    x_shape: Optional[torch.Size] = None,\n    enable_transform: bool = True,\n):\n    \"\"\"\n    Args:\n        prior: Prior distribution with `.log_prob()` and `.sample()`.\n        posterior_estimator: The trained neural posterior.\n        max_sampling_batch_size: Batchsize of samples being drawn from\n            the proposal at every iteration.\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:0\". If None,\n            `potential_fn.device` is used.\n        x_shape: Deprecated, should not be passed.\n        enable_transform: Whether to transform parameters to unconstrained space\n            during MAP optimization. When False, an identity transform will be\n            returned for `theta_transform`.\n    \"\"\"\n    # Because `DirectPosterior` does not take the `potential_fn` as input, it\n    # builds it itself. The `potential_fn` and `theta_transform` are used only for\n    # obtaining the MAP.\n    check_prior(prior)\n    potential_fn, theta_transform = posterior_estimator_based_potential(\n        posterior_estimator,\n        prior,\n        x_o=None,\n        enable_transform=enable_transform,\n    )\n\n    super().__init__(\n        potential_fn=potential_fn,\n        theta_transform=theta_transform,\n        device=device,\n        x_shape=x_shape,\n    )\n\n    self.prior = prior\n    self.posterior_estimator = posterior_estimator\n\n    self.max_sampling_batch_size = max_sampling_batch_size\n    self._leakage_density_correction_factor = None\n\n    self._purpose = \"\"\"It samples the posterior network and rejects samples that\n        lie outside of the prior bounds.\"\"\"\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.direct_posterior.DirectPosterior.leakage_correction","title":"<code>leakage_correction(x, num_rejection_samples=10000, force_update=False, show_progress_bars=False, rejection_sampling_batch_size=10000)</code>","text":"<p>Return leakage correction factor for a leaky posterior density estimate.</p> <p>The factor is estimated from the acceptance probability during rejection sampling from the posterior.</p> <p>This is to avoid re-estimating the acceptance probability from scratch whenever <code>log_prob</code> is called and <code>norm_posterior=True</code>. Here, it is estimated only once for <code>self.default_x</code> and saved for later. We re-evaluate only whenever a new <code>x</code> is passed.</p> <p>Parameters:</p> Name Type Description Default <code>num_rejection_samples</code> <code>int</code> <p>Number of samples used to estimate correction factor.</p> <code>10000</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progress bar during sampling.</p> <code>False</code> <code>rejection_sampling_batch_size</code> <code>int</code> <p>Batch size for rejection sampling.</p> <code>10000</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Saved or newly-estimated correction factor (as a scalar <code>Tensor</code>).</p> Source code in <code>sbi/inference/posteriors/direct_posterior.py</code> <pre><code>@torch.no_grad()\ndef leakage_correction(\n    self,\n    x: Tensor,\n    num_rejection_samples: int = 10_000,\n    force_update: bool = False,\n    show_progress_bars: bool = False,\n    rejection_sampling_batch_size: int = 10_000,\n) -&gt; Tensor:\n    r\"\"\"Return leakage correction factor for a leaky posterior density estimate.\n\n    The factor is estimated from the acceptance probability during rejection\n    sampling from the posterior.\n\n    This is to avoid re-estimating the acceptance probability from scratch\n    whenever `log_prob` is called and `norm_posterior=True`. Here, it\n    is estimated only once for `self.default_x` and saved for later. We\n    re-evaluate only whenever a new `x` is passed.\n\n    Arguments:\n        num_rejection_samples: Number of samples used to estimate correction factor.\n        show_progress_bars: Whether to show a progress bar during sampling.\n        rejection_sampling_batch_size: Batch size for rejection sampling.\n\n    Returns:\n        Saved or newly-estimated correction factor (as a scalar `Tensor`).\n    \"\"\"\n\n    def acceptance_at(x: Tensor) -&gt; Tensor:\n        # [1:] to remove batch-dimension for `reshape_to_batch_event`.\n        return rejection.accept_reject_sample(\n            proposal=self.posterior_estimator,\n            accept_reject_fn=lambda theta: within_support(self.prior, theta),\n            num_samples=num_rejection_samples,\n            show_progress_bars=show_progress_bars,\n            sample_for_correction_factor=True,\n            max_sampling_batch_size=rejection_sampling_batch_size,\n            proposal_sampling_kwargs={\n                \"condition\": reshape_to_batch_event(\n                    x, event_shape=self.posterior_estimator.condition_shape\n                )\n            },\n        )[1]\n\n    # Check if the provided x matches the default x (short-circuit on identity).\n    is_new_x = self.default_x is None or (\n        x is not self.default_x and (x != self.default_x).any()\n    )\n\n    not_saved_at_default_x = self._leakage_density_correction_factor is None\n\n    if is_new_x:  # Calculate at x; don't save.\n        return acceptance_at(x)\n    elif not_saved_at_default_x or force_update:  # Calculate at default_x; save.\n        assert self.default_x is not None\n        self._leakage_density_correction_factor = acceptance_at(self.default_x)\n\n    return self._leakage_density_correction_factor  # type: ignore\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.direct_posterior.DirectPosterior.log_prob","title":"<code>log_prob(theta, x=None, norm_posterior=True, track_gradients=False, leakage_correction_params=None)</code>","text":"<p>Returns the log-probability of the posterior \\(p(\\theta|x)\\).</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Tensor</code> <p>Parameters \\(\\theta\\).</p> required <code>norm_posterior</code> <code>bool</code> <p>Whether to enforce a normalized posterior density. Renormalization of the posterior is useful when some probability falls out or leaks out of the prescribed prior support. The normalizing factor is calculated via rejection sampling, so if you need speedier but unnormalized log posterior estimates set here <code>norm_posterior=False</code>. The returned log posterior is set to -\u221e outside of the prior support regardless of this setting.</p> <code>True</code> <code>track_gradients</code> <code>bool</code> <p>Whether the returned tensor supports tracking gradients. This can be helpful for e.g. sensitivity analysis, but increases memory consumption.</p> <code>False</code> <code>leakage_correction_params</code> <code>Optional[dict]</code> <p>A <code>dict</code> of keyword arguments to override the default values of <code>leakage_correction()</code>. Possible options are: <code>num_rejection_samples</code>, <code>force_update</code>, <code>show_progress_bars</code>, and <code>rejection_sampling_batch_size</code>. These parameters only have an effect if <code>norm_posterior=True</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tensor</code> <p><code>(len(\u03b8),)</code>-shaped log posterior probability \\(\\log p(\\theta|x)\\) for \u03b8 in the</p> <code>Tensor</code> <p>support of the prior, -\u221e (corresponding to 0 probability) outside.</p> Source code in <code>sbi/inference/posteriors/direct_posterior.py</code> <pre><code>def log_prob(\n    self,\n    theta: Tensor,\n    x: Optional[Tensor] = None,\n    norm_posterior: bool = True,\n    track_gradients: bool = False,\n    leakage_correction_params: Optional[dict] = None,\n) -&gt; Tensor:\n    r\"\"\"Returns the log-probability of the posterior $p(\\theta|x)$.\n\n    Args:\n        theta: Parameters $\\theta$.\n        norm_posterior: Whether to enforce a normalized posterior density.\n            Renormalization of the posterior is useful when some\n            probability falls out or leaks out of the prescribed prior support.\n            The normalizing factor is calculated via rejection sampling, so if you\n            need speedier but unnormalized log posterior estimates set here\n            `norm_posterior=False`. The returned log posterior is set to\n            -\u221e outside of the prior support regardless of this setting.\n        track_gradients: Whether the returned tensor supports tracking gradients.\n            This can be helpful for e.g. sensitivity analysis, but increases memory\n            consumption.\n        leakage_correction_params: A `dict` of keyword arguments to override the\n            default values of `leakage_correction()`. Possible options are:\n            `num_rejection_samples`, `force_update`, `show_progress_bars`, and\n            `rejection_sampling_batch_size`.\n            These parameters only have an effect if `norm_posterior=True`.\n\n    Returns:\n        `(len(\u03b8),)`-shaped log posterior probability $\\log p(\\theta|x)$ for \u03b8 in the\n        support of the prior, -\u221e (corresponding to 0 probability) outside.\n    \"\"\"\n    x = self._x_else_default_x(x)\n\n    theta = ensure_theta_batched(torch.as_tensor(theta))\n    theta_density_estimator = reshape_to_sample_batch_event(\n        theta, theta.shape[1:], leading_is_sample=True\n    )\n    x_density_estimator = reshape_to_batch_event(\n        x, event_shape=self.posterior_estimator.condition_shape\n    )\n    if x_density_estimator.shape[0] &gt; 1:\n        raise ValueError(\n            \".log_prob() supports only `batchsize == 1`. If you intend \"\n            \"to evaluate given multiple observations, use `.log_prob_batched()`. \"\n            \"If you intend to evaluate given i.i.d. observations, set up the \"\n            \"posterior density estimator with an appropriate permutation \"\n            \"invariant embedding net.\"\n        )\n\n    self.posterior_estimator.eval()\n\n    with torch.set_grad_enabled(track_gradients):\n        # Evaluate on device, move back to cpu for comparison with prior.\n        unnorm_log_prob = self.posterior_estimator.log_prob(\n            theta_density_estimator, condition=x_density_estimator\n        )\n        # `log_prob` supports only a single observation (i.e. `batchsize==1`).\n        # We now remove this additional dimension.\n        unnorm_log_prob = unnorm_log_prob.squeeze(dim=1)\n\n        # Force probability to be zero outside prior support.\n        in_prior_support = within_support(self.prior, theta)\n\n        masked_log_prob = torch.where(\n            in_prior_support,\n            unnorm_log_prob,\n            torch.tensor(float(\"-inf\"), dtype=torch.float32, device=self._device),\n        )\n\n        if leakage_correction_params is None:\n            leakage_correction_params = dict()  # use defaults\n        log_factor = (\n            log(self.leakage_correction(x=x, **leakage_correction_params))\n            if norm_posterior\n            else 0\n        )\n\n        return masked_log_prob - log_factor\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.direct_posterior.DirectPosterior.log_prob_batched","title":"<code>log_prob_batched(theta, x, norm_posterior=True, track_gradients=False, leakage_correction_params=None)</code>","text":"<p>Given a batch of observations [x_1, \u2026, x_B] and a batch of parameters             [$  heta_1$,\u2026, $  heta_B$] this function evalautes the log-probabilities             of the posteriors \\(p(        heta_1|x_1)\\), \u2026, \\(p(  heta_B|x_B)\\) in a batched             (i.e. vectorized) manner.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Tensor</code> <p>Batch of parameters $        heta$ of shape                 <code>(*sample_shape, batch_dim, *theta_shape)</code>.</p> required <code>x</code> <code>Tensor</code> <p>Batch of observations \\(x\\) of shape                 <code>(batch_dim, *condition_shape)</code>.</p> required <code>norm_posterior</code> <code>bool</code> <p>Whether to enforce a normalized posterior density. Renormalization of the posterior is useful when some probability falls out or leaks out of the prescribed prior support. The normalizing factor is calculated via rejection sampling, so if you need speedier but unnormalized log posterior estimates set here <code>norm_posterior=False</code>. The returned log posterior is set to -\u221e outside of the prior support regardless of this setting.</p> <code>True</code> <code>track_gradients</code> <code>bool</code> <p>Whether the returned tensor supports tracking gradients. This can be helpful for e.g. sensitivity analysis, but increases memory consumption.</p> <code>False</code> <code>leakage_correction_params</code> <code>Optional[dict]</code> <p>A <code>dict</code> of keyword arguments to override the default values of <code>leakage_correction()</code>. Possible options are: <code>num_rejection_samples</code>, <code>force_update</code>, <code>show_progress_bars</code>, and <code>rejection_sampling_batch_size</code>. These parameters only have an effect if <code>norm_posterior=True</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tensor</code> <p><code>(len(\u03b8), B)</code>-shaped log posterior probability \\(\\log p(     heta|x)\\) for \u03b8             in the support of the prior, -\u221e (corresponding to 0 probability) outside.</p> Source code in <code>sbi/inference/posteriors/direct_posterior.py</code> <pre><code>def log_prob_batched(\n    self,\n    theta: Tensor,\n    x: Tensor,\n    norm_posterior: bool = True,\n    track_gradients: bool = False,\n    leakage_correction_params: Optional[dict] = None,\n) -&gt; Tensor:\n    \"\"\"Given a batch of observations [x_1, ..., x_B] and a batch of parameters \\\n        [$\\theta_1$,..., $\\theta_B$] this function evalautes the log-probabilities \\\n        of the posteriors $p(\\theta_1|x_1)$, ..., $p(\\theta_B|x_B)$ in a batched \\\n        (i.e. vectorized) manner.\n\n    Args:\n        theta: Batch of parameters $\\theta$ of shape \\\n            `(*sample_shape, batch_dim, *theta_shape)`.\n        x: Batch of observations $x$ of shape \\\n            `(batch_dim, *condition_shape)`.\n        norm_posterior: Whether to enforce a normalized posterior density.\n            Renormalization of the posterior is useful when some\n            probability falls out or leaks out of the prescribed prior support.\n            The normalizing factor is calculated via rejection sampling, so if you\n            need speedier but unnormalized log posterior estimates set here\n            `norm_posterior=False`. The returned log posterior is set to\n            -\u221e outside of the prior support regardless of this setting.\n        track_gradients: Whether the returned tensor supports tracking gradients.\n            This can be helpful for e.g. sensitivity analysis, but increases memory\n            consumption.\n        leakage_correction_params: A `dict` of keyword arguments to override the\n            default values of `leakage_correction()`. Possible options are:\n            `num_rejection_samples`, `force_update`, `show_progress_bars`, and\n            `rejection_sampling_batch_size`.\n            These parameters only have an effect if `norm_posterior=True`.\n\n    Returns:\n        `(len(\u03b8), B)`-shaped log posterior probability $\\\\log p(\\theta|x)$\\\\ for \u03b8 \\\n        in the support of the prior, -\u221e (corresponding to 0 probability) outside.\n    \"\"\"\n\n    theta = ensure_theta_batched(torch.as_tensor(theta))\n    event_shape = self.posterior_estimator.input_shape\n    theta_density_estimator = reshape_to_sample_batch_event(\n        theta, event_shape, leading_is_sample=True\n    )\n    x_density_estimator = reshape_to_batch_event(\n        x, event_shape=self.posterior_estimator.condition_shape\n    )\n\n    self.posterior_estimator.eval()\n\n    with torch.set_grad_enabled(track_gradients):\n        # Evaluate on device, move back to cpu for comparison with prior.\n        unnorm_log_prob = self.posterior_estimator.log_prob(\n            theta_density_estimator, condition=x_density_estimator\n        )\n\n        # Force probability to be zero outside prior support.\n        in_prior_support = within_support(self.prior, theta)\n\n        masked_log_prob = torch.where(\n            in_prior_support,\n            unnorm_log_prob,\n            torch.tensor(float(\"-inf\"), dtype=torch.float32, device=self._device),\n        )\n\n        if leakage_correction_params is None:\n            leakage_correction_params = dict()  # use defaults\n        log_factor = (\n            log(self.leakage_correction(x=x, **leakage_correction_params))\n            if norm_posterior\n            else 0\n        )\n\n        return masked_log_prob - log_factor\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.direct_posterior.DirectPosterior.map","title":"<code>map(x=None, num_iter=1000, num_to_optimize=100, learning_rate=0.01, init_method='posterior', num_init_samples=1000, save_best_every=10, show_progress_bars=False, force_update=False)</code>","text":"<p>Returns the maximum-a-posteriori estimate (MAP).</p> <p>The method can be interrupted (Ctrl-C) when the user sees that the log-probability converges. The best estimate will be saved in <code>self._map</code> and can be accessed with <code>self.map()</code>. The MAP is obtained by running gradient ascent from a given number of starting positions (samples from the posterior with the highest log-probability). After the optimization is done, we select the parameter set that has the highest log-probability after the optimization.</p> <p>Warning: The default values used by this function are not well-tested. They might require hand-tuning for the problem at hand.</p> <p>For developers: if the prior is a <code>BoxUniform</code>, we carry out the optimization in unbounded space and transform the result back into bounded space.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Optional[Tensor]</code> <p>Deprecated - use <code>.set_default_x()</code> prior to <code>.map()</code>.</p> <code>None</code> <code>num_iter</code> <code>int</code> <p>Number of optimization steps that the algorithm takes to find the MAP.</p> <code>1000</code> <code>learning_rate</code> <code>float</code> <p>Learning rate of the optimizer.</p> <code>0.01</code> <code>init_method</code> <code>Union[str, Tensor]</code> <p>How to select the starting parameters for the optimization. If it is a string, it can be either [<code>posterior</code>, <code>prior</code>], which samples the respective distribution <code>num_init_samples</code> times. If it is a tensor, the tensor will be used as init locations.</p> <code>'posterior'</code> <code>num_init_samples</code> <code>int</code> <p>Draw this number of samples from the posterior and evaluate the log-probability of all of them.</p> <code>1000</code> <code>num_to_optimize</code> <code>int</code> <p>From the drawn <code>num_init_samples</code>, use the <code>num_to_optimize</code> with highest log-probability as the initial points for the optimization.</p> <code>100</code> <code>save_best_every</code> <code>int</code> <p>The best log-probability is computed, saved in the <code>map</code>-attribute, and printed every <code>save_best_every</code>-th iteration. Computing the best log-probability creates a significant overhead (thus, the default is <code>10</code>.)</p> <code>10</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during sampling from the posterior.</p> <code>False</code> <code>force_update</code> <code>bool</code> <p>Whether to re-calculate the MAP when x is unchanged and have a cached value.</p> <code>False</code> <code>log_prob_kwargs</code> <p>Will be empty for SNLE and SNRE. Will contain {\u2018norm_posterior\u2019: True} for SNPE.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The MAP estimate.</p> Source code in <code>sbi/inference/posteriors/direct_posterior.py</code> <pre><code>def map(\n    self,\n    x: Optional[Tensor] = None,\n    num_iter: int = 1_000,\n    num_to_optimize: int = 100,\n    learning_rate: float = 0.01,\n    init_method: Union[str, Tensor] = \"posterior\",\n    num_init_samples: int = 1_000,\n    save_best_every: int = 10,\n    show_progress_bars: bool = False,\n    force_update: bool = False,\n) -&gt; Tensor:\n    r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n    The method can be interrupted (Ctrl-C) when the user sees that the\n    log-probability converges. The best estimate will be saved in `self._map` and\n    can be accessed with `self.map()`. The MAP is obtained by running gradient\n    ascent from a given number of starting positions (samples from the posterior\n    with the highest log-probability). After the optimization is done, we select the\n    parameter set that has the highest log-probability after the optimization.\n\n    Warning: The default values used by this function are not well-tested. They\n    might require hand-tuning for the problem at hand.\n\n    For developers: if the prior is a `BoxUniform`, we carry out the optimization\n    in unbounded space and transform the result back into bounded space.\n\n    Args:\n        x: Deprecated - use `.set_default_x()` prior to `.map()`.\n        num_iter: Number of optimization steps that the algorithm takes\n            to find the MAP.\n        learning_rate: Learning rate of the optimizer.\n        init_method: How to select the starting parameters for the optimization. If\n            it is a string, it can be either [`posterior`, `prior`], which samples\n            the respective distribution `num_init_samples` times. If it is a\n            tensor, the tensor will be used as init locations.\n        num_init_samples: Draw this number of samples from the posterior and\n            evaluate the log-probability of all of them.\n        num_to_optimize: From the drawn `num_init_samples`, use the\n            `num_to_optimize` with highest log-probability as the initial points\n            for the optimization.\n        save_best_every: The best log-probability is computed, saved in the\n            `map`-attribute, and printed every `save_best_every`-th iteration.\n            Computing the best log-probability creates a significant overhead\n            (thus, the default is `10`.)\n        show_progress_bars: Whether to show a progressbar during sampling from the\n            posterior.\n        force_update: Whether to re-calculate the MAP when x is unchanged and\n            have a cached value.\n        log_prob_kwargs: Will be empty for SNLE and SNRE. Will contain\n            {'norm_posterior': True} for SNPE.\n\n    Returns:\n        The MAP estimate.\n    \"\"\"\n    return super().map(\n        x=x,\n        num_iter=num_iter,\n        num_to_optimize=num_to_optimize,\n        learning_rate=learning_rate,\n        init_method=init_method,\n        num_init_samples=num_init_samples,\n        save_best_every=save_best_every,\n        show_progress_bars=show_progress_bars,\n        force_update=force_update,\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.direct_posterior.DirectPosterior.sample","title":"<code>sample(sample_shape=torch.Size(), x=None, max_sampling_batch_size=10000, sample_with=None, show_progress_bars=True)</code>","text":"<p>Return samples from posterior distribution \\(p(\\theta|x)\\).</p> <p>Parameters:</p> Name Type Description Default <code>sample_shape</code> <code>Shape</code> <p>Desired shape of samples that are drawn from posterior. If sample_shape is multidimensional we simply draw <code>sample_shape.numel()</code> samples and then reshape into the desired shape.</p> <code>Size()</code> <code>sample_with</code> <code>Optional[str]</code> <p>This argument only exists to keep backward-compatibility with <code>sbi</code> v0.17.2 or older. If it is set, we instantly raise an error.</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show sampling progress monitor.</p> <code>True</code> Source code in <code>sbi/inference/posteriors/direct_posterior.py</code> <pre><code>def sample(\n    self,\n    sample_shape: Shape = torch.Size(),\n    x: Optional[Tensor] = None,\n    max_sampling_batch_size: int = 10_000,\n    sample_with: Optional[str] = None,\n    show_progress_bars: bool = True,\n) -&gt; Tensor:\n    r\"\"\"Return samples from posterior distribution $p(\\theta|x)$.\n\n    Args:\n        sample_shape: Desired shape of samples that are drawn from posterior. If\n            sample_shape is multidimensional we simply draw `sample_shape.numel()`\n            samples and then reshape into the desired shape.\n        sample_with: This argument only exists to keep backward-compatibility with\n            `sbi` v0.17.2 or older. If it is set, we instantly raise an error.\n        show_progress_bars: Whether to show sampling progress monitor.\n    \"\"\"\n    num_samples = torch.Size(sample_shape).numel()\n    x = self._x_else_default_x(x)\n    x = reshape_to_batch_event(\n        x, event_shape=self.posterior_estimator.condition_shape\n    )\n    if x.shape[0] &gt; 1:\n        raise ValueError(\n            \".sample() supports only `batchsize == 1`. If you intend \"\n            \"to sample multiple observations, use `.sample_batched()`. \"\n            \"If you intend to sample i.i.d. observations, set up the \"\n            \"posterior density estimator with an appropriate permutation \"\n            \"invariant embedding net.\"\n        )\n\n    max_sampling_batch_size = (\n        self.max_sampling_batch_size\n        if max_sampling_batch_size is None\n        else max_sampling_batch_size\n    )\n\n    if sample_with is not None:\n        raise ValueError(\n            f\"You set `sample_with={sample_with}`. As of sbi v0.18.0, setting \"\n            f\"`sample_with` is no longer supported. You have to rerun \"\n            f\"`.build_posterior(sample_with={sample_with}).`\"\n        )\n\n    samples = rejection.accept_reject_sample(\n        proposal=self.posterior_estimator,\n        accept_reject_fn=lambda theta: within_support(self.prior, theta),\n        num_samples=num_samples,\n        show_progress_bars=show_progress_bars,\n        max_sampling_batch_size=max_sampling_batch_size,\n        proposal_sampling_kwargs={\"condition\": x},\n        alternative_method=\"build_posterior(..., sample_with='mcmc')\",\n    )[0]  # [0] to return only samples, not acceptance probabilities.\n\n    return samples[:, 0]  # Remove batch dimension.\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.direct_posterior.DirectPosterior.sample_batched","title":"<code>sample_batched(sample_shape, x, max_sampling_batch_size=10000, show_progress_bars=True)</code>","text":"<p>Given a batch of observations [x_1, \u2026, x_B] this function samples from posteriors \\(p(\\theta|x_1)\\), \u2026 ,\\(p(\\theta|x_B)\\), in a batched (i.e. vectorized) manner.</p> <p>Parameters:</p> Name Type Description Default <code>sample_shape</code> <code>Shape</code> <p>Desired shape of samples that are drawn from the posterior given every observation.</p> required <code>x</code> <code>Tensor</code> <p>A batch of observations, of shape <code>(batch_dim, event_shape_x)</code>. <code>batch_dim</code> corresponds to the number of observations to be drawn.</p> required <code>max_sampling_batch_size</code> <code>int</code> <p>Maximum batch size for rejection sampling.</p> <code>10000</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show sampling progress monitor.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Samples from the posteriors of shape (*sample_shape, B, *input_shape)</p> Source code in <code>sbi/inference/posteriors/direct_posterior.py</code> <pre><code>def sample_batched(\n    self,\n    sample_shape: Shape,\n    x: Tensor,\n    max_sampling_batch_size: int = 10_000,\n    show_progress_bars: bool = True,\n) -&gt; Tensor:\n    r\"\"\"Given a batch of observations [x_1, ..., x_B] this function samples from\n    posteriors $p(\\theta|x_1)$, ... ,$p(\\theta|x_B)$, in a batched (i.e. vectorized)\n    manner.\n\n    Args:\n        sample_shape: Desired shape of samples that are drawn from the posterior\n            given every observation.\n        x: A batch of observations, of shape `(batch_dim, event_shape_x)`.\n            `batch_dim` corresponds to the number of observations to be drawn.\n        max_sampling_batch_size: Maximum batch size for rejection sampling.\n        show_progress_bars: Whether to show sampling progress monitor.\n\n    Returns:\n        Samples from the posteriors of shape (*sample_shape, B, *input_shape)\n    \"\"\"\n    num_samples = torch.Size(sample_shape).numel()\n    condition_shape = self.posterior_estimator.condition_shape\n    x = reshape_to_batch_event(x, event_shape=condition_shape)\n\n    max_sampling_batch_size = (\n        self.max_sampling_batch_size\n        if max_sampling_batch_size is None\n        else max_sampling_batch_size\n    )\n\n    samples = rejection.accept_reject_sample(\n        proposal=self.posterior_estimator,\n        accept_reject_fn=lambda theta: within_support(self.prior, theta),\n        num_samples=num_samples,\n        show_progress_bars=show_progress_bars,\n        max_sampling_batch_size=max_sampling_batch_size,\n        proposal_sampling_kwargs={\"condition\": x},\n        alternative_method=\"build_posterior(..., sample_with='mcmc')\",\n    )[0]\n\n    return samples\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.importance_posterior.ImportanceSamplingPosterior","title":"<code>ImportanceSamplingPosterior</code>","text":"<p>               Bases: <code>NeuralPosterior</code></p> <p>Provides importance sampling to sample from the posterior. SNLE or SNRE train neural networks to approximate the likelihood(-ratios). <code>ImportanceSamplingPosterior</code> allows to estimate the posterior log-probability by estimating the normlalization constant with importance sampling. It also allows to perform importance sampling (with <code>.sample()</code>) and to draw approximate samples with sampling-importance-resampling (SIR) (with <code>.sir_sample()</code>)</p> Source code in <code>sbi/inference/posteriors/importance_posterior.py</code> <pre><code>class ImportanceSamplingPosterior(NeuralPosterior):\n    r\"\"\"Provides importance sampling to sample from the posterior.&lt;br/&gt;&lt;br/&gt;\n    SNLE or SNRE train neural networks to approximate the likelihood(-ratios).\n    `ImportanceSamplingPosterior` allows to estimate the posterior log-probability by\n    estimating the normlalization constant with importance sampling. It also allows to\n    perform importance sampling (with `.sample()`) and to draw approximate samples with\n    sampling-importance-resampling (SIR) (with `.sir_sample()`)\n    \"\"\"\n\n    def __init__(\n        self,\n        potential_fn: Union[Callable, BasePotential],\n        proposal: Any,\n        theta_transform: Optional[TorchTransform] = None,\n        method: str = \"sir\",\n        oversampling_factor: int = 32,\n        max_sampling_batch_size: int = 10_000,\n        device: Optional[str] = None,\n        x_shape: Optional[torch.Size] = None,\n    ):\n        \"\"\"\n        Args:\n            potential_fn: The potential function from which to draw samples. Must be a\n                `BasePotential` or a `Callable` which takes `theta` and `x_o` as inputs.\n            proposal: The proposal distribution.\n            theta_transform: Transformation that is applied to parameters. Is not used\n                during but only when calling `.map()`.\n            method: Either of [`sir`|`importance`]. This sets the behavior of the\n                `.sample()` method. With `sir`, approximate posterior samples are\n                generated with sampling importance resampling (SIR). With\n                `importance`, the `.sample()` method returns a tuple of samples and\n                corresponding importance weights.\n            oversampling_factor: Number of proposed samples from which only one is\n                selected based on its importance weight.\n            max_sampling_batch_size: The batch size of samples being drawn from the\n                proposal at every iteration.\n            device: Device on which to sample, e.g., \"cpu\", \"cuda\" or \"cuda:0\". If\n                None, `potential_fn.device` is used.\n            x_shape: Deprecated, should not be passed.\n        \"\"\"\n        super().__init__(\n            potential_fn,\n            theta_transform=theta_transform,\n            device=device,\n            x_shape=x_shape,\n        )\n\n        self.proposal = proposal\n        self._normalization_constant = None\n        self.method = method\n\n        self.oversampling_factor = oversampling_factor\n        self.max_sampling_batch_size = max_sampling_batch_size\n\n        self._purpose = (\n            \"It provides sampling-importance resampling (SIR) to .sample() from the \"\n            \"posterior and can evaluate the _unnormalized_ posterior density with \"\n            \".log_prob().\"\n        )\n\n    def log_prob(\n        self,\n        theta: Tensor,\n        x: Optional[Tensor] = None,\n        track_gradients: bool = False,\n        normalization_constant_params: Optional[dict] = None,\n    ) -&gt; Tensor:\n        r\"\"\"Returns the log-probability of theta under the posterior.\n\n        The normalization constant is estimated with importance sampling.\n\n        Args:\n            theta: Parameters $\\theta$.\n            track_gradients: Whether the returned tensor supports tracking gradients.\n                This can be helpful for e.g. sensitivity analysis, but increases memory\n                consumption.\n            normalization_constant_params: Parameters passed on to\n                `estimate_normalization_constant()`.\n\n        Returns:\n            `len($\\theta$)`-shaped log-probability.\n        \"\"\"\n        x = self._x_else_default_x(x)\n        self.potential_fn.set_x(x)\n\n        theta = ensure_theta_batched(torch.as_tensor(theta))\n\n        with torch.set_grad_enabled(track_gradients):\n            potential_values = self.potential_fn(\n                theta.to(self._device), track_gradients=track_gradients\n            )\n\n            if normalization_constant_params is None:\n                normalization_constant_params = dict()  # use defaults\n            normalization_constant = self.estimate_normalization_constant(\n                x, **normalization_constant_params\n            )\n\n            return (potential_values - torch.log(normalization_constant)).to(\n                self._device\n            )\n\n    @torch.no_grad()\n    def estimate_normalization_constant(\n        self, x: Tensor, num_samples: int = 10_000, force_update: bool = False\n    ) -&gt; Tensor:\n        \"\"\"Returns the normalization constant via importance sampling.\n\n        Args:\n            num_samples: Number of importance samples used for the estimate.\n            force_update: Whether to re-calculate the normlization constant when x is\n                unchanged and have a cached value.\n        \"\"\"\n        # Check if the provided x matches the default x (short-circuit on identity).\n        is_new_x = self.default_x is None or (\n            x is not self.default_x and (x != self.default_x).any()\n        )\n\n        not_saved_at_default_x = self._normalization_constant is None\n\n        if is_new_x:  # Calculate at x; don't save.\n            _, log_importance_weights = importance_sample(\n                self.potential_fn,\n                proposal=self.proposal,\n                num_samples=num_samples,\n            )\n            return torch.mean(torch.exp(log_importance_weights))\n        elif not_saved_at_default_x or force_update:  # Calculate at default_x; save.\n            assert self.default_x is not None\n            _, log_importance_weights = importance_sample(\n                self.potential_fn,\n                proposal=self.proposal,\n                num_samples=num_samples,\n            )\n            self._normalization_constant = torch.mean(torch.exp(log_importance_weights))\n\n        return self._normalization_constant.to(self._device)  # type: ignore\n\n    def sample(\n        self,\n        sample_shape: Shape = torch.Size(),\n        x: Optional[Tensor] = None,\n        method: Optional[str] = None,\n        oversampling_factor: int = 32,\n        max_sampling_batch_size: int = 10_000,\n        sample_with: Optional[str] = None,\n        show_progress_bars: bool = False,\n    ) -&gt; Union[Tensor, Tuple[Tensor, Tensor]]:\n        \"\"\"Return samples from the approximate posterior distribution.\n\n        Args:\n            sample_shape: Shape of samples that are drawn from posterior.\n            x: Observed data.\n            method: Either of [`sir`|`importance`]. This sets the behavior of the\n                `.sample()` method. With `sir`, approximate posterior samples are\n                generated with sampling importance resampling (SIR). With\n                `importance`, the `.sample()` method returns a tuple of samples and\n                corresponding importance weights.\n            oversampling_factor: Number of proposed samples from which only one is\n                selected based on its importance weight.\n            max_sampling_batch_size: The batch size of samples being drawn from the\n                proposal at every iteration.\n            show_progress_bars: Whether to show a progressbar during sampling.\n        \"\"\"\n\n        method = self.method if method is None else method\n\n        if sample_with is not None:\n            raise ValueError(\n                f\"You set `sample_with={sample_with}`. As of sbi v0.18.0, setting \"\n                f\"`sample_with` is no longer supported. You have to rerun \"\n                f\"`.build_posterior(sample_with={sample_with}).`\"\n            )\n\n        self.potential_fn.set_x(self._x_else_default_x(x))\n\n        if method == \"sir\":\n            return self._sir_sample(\n                sample_shape,\n                oversampling_factor=oversampling_factor,\n                max_sampling_batch_size=max_sampling_batch_size,\n                show_progress_bars=show_progress_bars,\n            )\n        elif method == \"importance\":\n            return self._importance_sample(sample_shape)\n        else:\n            raise NameError\n\n    def sample_batched(\n        self,\n        sample_shape: Shape,\n        x: Tensor,\n        max_sampling_batch_size: int = 10000,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        raise NotImplementedError(\n            \"Batched sampling is not implemented for ImportanceSamplingPosterior. \\\n            Alternatively you can use `sample` in a loop \\\n            [posterior.sample(theta, x_o) for x_o in x].\"\n        )\n\n    def _importance_sample(\n        self,\n        sample_shape: Shape = torch.Size(),\n        show_progress_bars: bool = False,\n    ) -&gt; Tuple[Tensor, Tensor]:\n        \"\"\"Returns samples from the proposal and log of their importance weights.\n\n        Args:\n            sample_shape: Desired shape of samples that are drawn from posterior.\n            sample_with: This argument only exists to keep backward-compatibility with\n                `sbi` v0.17.2 or older. If it is set, we instantly raise an error.\n            show_progress_bars: Whether to show sampling progress monitor.\n\n        Returns:\n            Samples and logarithm of corresponding importance weights.\n        \"\"\"\n        num_samples = torch.Size(sample_shape).numel()\n        samples, log_importance_weights = importance_sample(\n            self.potential_fn,\n            proposal=self.proposal,\n            num_samples=num_samples,\n            show_progress_bars=show_progress_bars,\n        )\n\n        samples = samples.reshape((*sample_shape, -1)).to(self._device)\n        return samples, log_importance_weights.to(self._device)\n\n    def _sir_sample(\n        self,\n        sample_shape: Shape = torch.Size(),\n        oversampling_factor: int = 32,\n        max_sampling_batch_size: int = 10_000,\n        show_progress_bars: bool = False,\n    ):\n        r\"\"\"Returns approximate samples from posterior $p(\\theta|x)$ via SIR.\n\n        Args:\n            sample_shape: Desired shape of samples that are drawn from posterior. If\n                sample_shape is multidimensional we simply draw `sample_shape.numel()`\n                samples and then reshape into the desired shape.\n            x: Observed data.\n            sample_with: This argument only exists to keep backward-compatibility with\n                `sbi` v0.17.2 or older. If it is set, we instantly raise an error.\n            oversampling_factor: Number of proposed samples form which only one is\n                selected based on its importance weight.\n            max_sampling_batch_size: The batchsize of samples being drawn from\n                the proposal at every iteration. Used only in `sir_sample()`.\n            show_progress_bars: Whether to show sampling progress monitor.\n\n        Returns:\n            Samples from posterior.\n        \"\"\"\n        # Replace arguments that were not passed with their default.\n        oversampling_factor = (\n            self.oversampling_factor\n            if oversampling_factor is None\n            else oversampling_factor\n        )\n        max_sampling_batch_size = (\n            self.max_sampling_batch_size\n            if max_sampling_batch_size is None\n            else max_sampling_batch_size\n        )\n\n        num_samples = torch.Size(sample_shape).numel()\n        samples = sampling_importance_resampling(\n            self.potential_fn,\n            proposal=self.proposal,\n            num_samples=num_samples,\n            num_candidate_samples=oversampling_factor,\n            show_progress_bars=show_progress_bars,\n            max_sampling_batch_size=max_sampling_batch_size,\n            device=self._device,\n        )\n\n        return samples.reshape((*sample_shape, -1)).to(self._device)\n\n    def map(\n        self,\n        x: Optional[Tensor] = None,\n        num_iter: int = 1_000,\n        num_to_optimize: int = 100,\n        learning_rate: float = 0.01,\n        init_method: Union[str, Tensor] = \"proposal\",\n        num_init_samples: int = 1_000,\n        save_best_every: int = 10,\n        show_progress_bars: bool = False,\n        force_update: bool = False,\n    ) -&gt; Tensor:\n        r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n        The method can be interrupted (Ctrl-C) when the user sees that the\n        log-probability converges. The best estimate will be saved in `self._map` and\n        can be accessed with `self.map()`. The MAP is obtained by running gradient\n        ascent from a given number of starting positions (samples from the posterior\n        with the highest log-probability). After the optimization is done, we select the\n        parameter set that has the highest log-probability after the optimization.\n\n        Warning: The default values used by this function are not well-tested. They\n        might require hand-tuning for the problem at hand.\n\n        For developers: if the prior is a `BoxUniform`, we carry out the optimization\n        in unbounded space and transform the result back into bounded space.\n\n        Args:\n            x: Deprecated - use `.set_default_x()` prior to `.map()`.\n            num_iter: Number of optimization steps that the algorithm takes\n                to find the MAP.\n            learning_rate: Learning rate of the optimizer.\n            init_method: How to select the starting parameters for the optimization. If\n                it is a string, it can be either [`posterior`, `prior`], which samples\n                the respective distribution `num_init_samples` times. If it is a\n                tensor, the tensor will be used as init locations.\n            num_init_samples: Draw this number of samples from the posterior and\n                evaluate the log-probability of all of them.\n            num_to_optimize: From the drawn `num_init_samples`, use the\n                `num_to_optimize` with highest log-probability as the initial points\n                for the optimization.\n            save_best_every: The best log-probability is computed, saved in the\n                `map`-attribute, and printed every `save_best_every`-th iteration.\n                Computing the best log-probability creates a significant overhead\n                (thus, the default is `10`.)\n            show_progress_bars: Whether to show a progressbar during sampling from the\n                posterior.\n            force_update: Whether to re-calculate the MAP when x is unchanged and\n                have a cached value.\n            log_prob_kwargs: Will be empty for SNLE and SNRE. Will contain\n                {'norm_posterior': True} for SNPE.\n\n        Returns:\n            The MAP estimate.\n        \"\"\"\n        return super().map(\n            x=x,\n            num_iter=num_iter,\n            num_to_optimize=num_to_optimize,\n            learning_rate=learning_rate,\n            init_method=init_method,\n            num_init_samples=num_init_samples,\n            save_best_every=save_best_every,\n            show_progress_bars=show_progress_bars,\n            force_update=force_update,\n        )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.importance_posterior.ImportanceSamplingPosterior.__init__","title":"<code>__init__(potential_fn, proposal, theta_transform=None, method='sir', oversampling_factor=32, max_sampling_batch_size=10000, device=None, x_shape=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>potential_fn</code> <code>Union[Callable, BasePotential]</code> <p>The potential function from which to draw samples. Must be a <code>BasePotential</code> or a <code>Callable</code> which takes <code>theta</code> and <code>x_o</code> as inputs.</p> required <code>proposal</code> <code>Any</code> <p>The proposal distribution.</p> required <code>theta_transform</code> <code>Optional[TorchTransform]</code> <p>Transformation that is applied to parameters. Is not used during but only when calling <code>.map()</code>.</p> <code>None</code> <code>method</code> <code>str</code> <p>Either of [<code>sir</code>|<code>importance</code>]. This sets the behavior of the <code>.sample()</code> method. With <code>sir</code>, approximate posterior samples are generated with sampling importance resampling (SIR). With <code>importance</code>, the <code>.sample()</code> method returns a tuple of samples and corresponding importance weights.</p> <code>'sir'</code> <code>oversampling_factor</code> <code>int</code> <p>Number of proposed samples from which only one is selected based on its importance weight.</p> <code>32</code> <code>max_sampling_batch_size</code> <code>int</code> <p>The batch size of samples being drawn from the proposal at every iteration.</p> <code>10000</code> <code>device</code> <code>Optional[str]</code> <p>Device on which to sample, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:0\u201d. If None, <code>potential_fn.device</code> is used.</p> <code>None</code> <code>x_shape</code> <code>Optional[Size]</code> <p>Deprecated, should not be passed.</p> <code>None</code> Source code in <code>sbi/inference/posteriors/importance_posterior.py</code> <pre><code>def __init__(\n    self,\n    potential_fn: Union[Callable, BasePotential],\n    proposal: Any,\n    theta_transform: Optional[TorchTransform] = None,\n    method: str = \"sir\",\n    oversampling_factor: int = 32,\n    max_sampling_batch_size: int = 10_000,\n    device: Optional[str] = None,\n    x_shape: Optional[torch.Size] = None,\n):\n    \"\"\"\n    Args:\n        potential_fn: The potential function from which to draw samples. Must be a\n            `BasePotential` or a `Callable` which takes `theta` and `x_o` as inputs.\n        proposal: The proposal distribution.\n        theta_transform: Transformation that is applied to parameters. Is not used\n            during but only when calling `.map()`.\n        method: Either of [`sir`|`importance`]. This sets the behavior of the\n            `.sample()` method. With `sir`, approximate posterior samples are\n            generated with sampling importance resampling (SIR). With\n            `importance`, the `.sample()` method returns a tuple of samples and\n            corresponding importance weights.\n        oversampling_factor: Number of proposed samples from which only one is\n            selected based on its importance weight.\n        max_sampling_batch_size: The batch size of samples being drawn from the\n            proposal at every iteration.\n        device: Device on which to sample, e.g., \"cpu\", \"cuda\" or \"cuda:0\". If\n            None, `potential_fn.device` is used.\n        x_shape: Deprecated, should not be passed.\n    \"\"\"\n    super().__init__(\n        potential_fn,\n        theta_transform=theta_transform,\n        device=device,\n        x_shape=x_shape,\n    )\n\n    self.proposal = proposal\n    self._normalization_constant = None\n    self.method = method\n\n    self.oversampling_factor = oversampling_factor\n    self.max_sampling_batch_size = max_sampling_batch_size\n\n    self._purpose = (\n        \"It provides sampling-importance resampling (SIR) to .sample() from the \"\n        \"posterior and can evaluate the _unnormalized_ posterior density with \"\n        \".log_prob().\"\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.importance_posterior.ImportanceSamplingPosterior.estimate_normalization_constant","title":"<code>estimate_normalization_constant(x, num_samples=10000, force_update=False)</code>","text":"<p>Returns the normalization constant via importance sampling.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int</code> <p>Number of importance samples used for the estimate.</p> <code>10000</code> <code>force_update</code> <code>bool</code> <p>Whether to re-calculate the normlization constant when x is unchanged and have a cached value.</p> <code>False</code> Source code in <code>sbi/inference/posteriors/importance_posterior.py</code> <pre><code>@torch.no_grad()\ndef estimate_normalization_constant(\n    self, x: Tensor, num_samples: int = 10_000, force_update: bool = False\n) -&gt; Tensor:\n    \"\"\"Returns the normalization constant via importance sampling.\n\n    Args:\n        num_samples: Number of importance samples used for the estimate.\n        force_update: Whether to re-calculate the normlization constant when x is\n            unchanged and have a cached value.\n    \"\"\"\n    # Check if the provided x matches the default x (short-circuit on identity).\n    is_new_x = self.default_x is None or (\n        x is not self.default_x and (x != self.default_x).any()\n    )\n\n    not_saved_at_default_x = self._normalization_constant is None\n\n    if is_new_x:  # Calculate at x; don't save.\n        _, log_importance_weights = importance_sample(\n            self.potential_fn,\n            proposal=self.proposal,\n            num_samples=num_samples,\n        )\n        return torch.mean(torch.exp(log_importance_weights))\n    elif not_saved_at_default_x or force_update:  # Calculate at default_x; save.\n        assert self.default_x is not None\n        _, log_importance_weights = importance_sample(\n            self.potential_fn,\n            proposal=self.proposal,\n            num_samples=num_samples,\n        )\n        self._normalization_constant = torch.mean(torch.exp(log_importance_weights))\n\n    return self._normalization_constant.to(self._device)  # type: ignore\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.importance_posterior.ImportanceSamplingPosterior.log_prob","title":"<code>log_prob(theta, x=None, track_gradients=False, normalization_constant_params=None)</code>","text":"<p>Returns the log-probability of theta under the posterior.</p> <p>The normalization constant is estimated with importance sampling.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Tensor</code> <p>Parameters \\(\\theta\\).</p> required <code>track_gradients</code> <code>bool</code> <p>Whether the returned tensor supports tracking gradients. This can be helpful for e.g. sensitivity analysis, but increases memory consumption.</p> <code>False</code> <code>normalization_constant_params</code> <code>Optional[dict]</code> <p>Parameters passed on to <code>estimate_normalization_constant()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tensor</code> <p><code>len($\\theta$)</code>-shaped log-probability.</p> Source code in <code>sbi/inference/posteriors/importance_posterior.py</code> <pre><code>def log_prob(\n    self,\n    theta: Tensor,\n    x: Optional[Tensor] = None,\n    track_gradients: bool = False,\n    normalization_constant_params: Optional[dict] = None,\n) -&gt; Tensor:\n    r\"\"\"Returns the log-probability of theta under the posterior.\n\n    The normalization constant is estimated with importance sampling.\n\n    Args:\n        theta: Parameters $\\theta$.\n        track_gradients: Whether the returned tensor supports tracking gradients.\n            This can be helpful for e.g. sensitivity analysis, but increases memory\n            consumption.\n        normalization_constant_params: Parameters passed on to\n            `estimate_normalization_constant()`.\n\n    Returns:\n        `len($\\theta$)`-shaped log-probability.\n    \"\"\"\n    x = self._x_else_default_x(x)\n    self.potential_fn.set_x(x)\n\n    theta = ensure_theta_batched(torch.as_tensor(theta))\n\n    with torch.set_grad_enabled(track_gradients):\n        potential_values = self.potential_fn(\n            theta.to(self._device), track_gradients=track_gradients\n        )\n\n        if normalization_constant_params is None:\n            normalization_constant_params = dict()  # use defaults\n        normalization_constant = self.estimate_normalization_constant(\n            x, **normalization_constant_params\n        )\n\n        return (potential_values - torch.log(normalization_constant)).to(\n            self._device\n        )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.importance_posterior.ImportanceSamplingPosterior.map","title":"<code>map(x=None, num_iter=1000, num_to_optimize=100, learning_rate=0.01, init_method='proposal', num_init_samples=1000, save_best_every=10, show_progress_bars=False, force_update=False)</code>","text":"<p>Returns the maximum-a-posteriori estimate (MAP).</p> <p>The method can be interrupted (Ctrl-C) when the user sees that the log-probability converges. The best estimate will be saved in <code>self._map</code> and can be accessed with <code>self.map()</code>. The MAP is obtained by running gradient ascent from a given number of starting positions (samples from the posterior with the highest log-probability). After the optimization is done, we select the parameter set that has the highest log-probability after the optimization.</p> <p>Warning: The default values used by this function are not well-tested. They might require hand-tuning for the problem at hand.</p> <p>For developers: if the prior is a <code>BoxUniform</code>, we carry out the optimization in unbounded space and transform the result back into bounded space.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Optional[Tensor]</code> <p>Deprecated - use <code>.set_default_x()</code> prior to <code>.map()</code>.</p> <code>None</code> <code>num_iter</code> <code>int</code> <p>Number of optimization steps that the algorithm takes to find the MAP.</p> <code>1000</code> <code>learning_rate</code> <code>float</code> <p>Learning rate of the optimizer.</p> <code>0.01</code> <code>init_method</code> <code>Union[str, Tensor]</code> <p>How to select the starting parameters for the optimization. If it is a string, it can be either [<code>posterior</code>, <code>prior</code>], which samples the respective distribution <code>num_init_samples</code> times. If it is a tensor, the tensor will be used as init locations.</p> <code>'proposal'</code> <code>num_init_samples</code> <code>int</code> <p>Draw this number of samples from the posterior and evaluate the log-probability of all of them.</p> <code>1000</code> <code>num_to_optimize</code> <code>int</code> <p>From the drawn <code>num_init_samples</code>, use the <code>num_to_optimize</code> with highest log-probability as the initial points for the optimization.</p> <code>100</code> <code>save_best_every</code> <code>int</code> <p>The best log-probability is computed, saved in the <code>map</code>-attribute, and printed every <code>save_best_every</code>-th iteration. Computing the best log-probability creates a significant overhead (thus, the default is <code>10</code>.)</p> <code>10</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during sampling from the posterior.</p> <code>False</code> <code>force_update</code> <code>bool</code> <p>Whether to re-calculate the MAP when x is unchanged and have a cached value.</p> <code>False</code> <code>log_prob_kwargs</code> <p>Will be empty for SNLE and SNRE. Will contain {\u2018norm_posterior\u2019: True} for SNPE.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The MAP estimate.</p> Source code in <code>sbi/inference/posteriors/importance_posterior.py</code> <pre><code>def map(\n    self,\n    x: Optional[Tensor] = None,\n    num_iter: int = 1_000,\n    num_to_optimize: int = 100,\n    learning_rate: float = 0.01,\n    init_method: Union[str, Tensor] = \"proposal\",\n    num_init_samples: int = 1_000,\n    save_best_every: int = 10,\n    show_progress_bars: bool = False,\n    force_update: bool = False,\n) -&gt; Tensor:\n    r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n    The method can be interrupted (Ctrl-C) when the user sees that the\n    log-probability converges. The best estimate will be saved in `self._map` and\n    can be accessed with `self.map()`. The MAP is obtained by running gradient\n    ascent from a given number of starting positions (samples from the posterior\n    with the highest log-probability). After the optimization is done, we select the\n    parameter set that has the highest log-probability after the optimization.\n\n    Warning: The default values used by this function are not well-tested. They\n    might require hand-tuning for the problem at hand.\n\n    For developers: if the prior is a `BoxUniform`, we carry out the optimization\n    in unbounded space and transform the result back into bounded space.\n\n    Args:\n        x: Deprecated - use `.set_default_x()` prior to `.map()`.\n        num_iter: Number of optimization steps that the algorithm takes\n            to find the MAP.\n        learning_rate: Learning rate of the optimizer.\n        init_method: How to select the starting parameters for the optimization. If\n            it is a string, it can be either [`posterior`, `prior`], which samples\n            the respective distribution `num_init_samples` times. If it is a\n            tensor, the tensor will be used as init locations.\n        num_init_samples: Draw this number of samples from the posterior and\n            evaluate the log-probability of all of them.\n        num_to_optimize: From the drawn `num_init_samples`, use the\n            `num_to_optimize` with highest log-probability as the initial points\n            for the optimization.\n        save_best_every: The best log-probability is computed, saved in the\n            `map`-attribute, and printed every `save_best_every`-th iteration.\n            Computing the best log-probability creates a significant overhead\n            (thus, the default is `10`.)\n        show_progress_bars: Whether to show a progressbar during sampling from the\n            posterior.\n        force_update: Whether to re-calculate the MAP when x is unchanged and\n            have a cached value.\n        log_prob_kwargs: Will be empty for SNLE and SNRE. Will contain\n            {'norm_posterior': True} for SNPE.\n\n    Returns:\n        The MAP estimate.\n    \"\"\"\n    return super().map(\n        x=x,\n        num_iter=num_iter,\n        num_to_optimize=num_to_optimize,\n        learning_rate=learning_rate,\n        init_method=init_method,\n        num_init_samples=num_init_samples,\n        save_best_every=save_best_every,\n        show_progress_bars=show_progress_bars,\n        force_update=force_update,\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.importance_posterior.ImportanceSamplingPosterior.sample","title":"<code>sample(sample_shape=torch.Size(), x=None, method=None, oversampling_factor=32, max_sampling_batch_size=10000, sample_with=None, show_progress_bars=False)</code>","text":"<p>Return samples from the approximate posterior distribution.</p> <p>Parameters:</p> Name Type Description Default <code>sample_shape</code> <code>Shape</code> <p>Shape of samples that are drawn from posterior.</p> <code>Size()</code> <code>x</code> <code>Optional[Tensor]</code> <p>Observed data.</p> <code>None</code> <code>method</code> <code>Optional[str]</code> <p>Either of [<code>sir</code>|<code>importance</code>]. This sets the behavior of the <code>.sample()</code> method. With <code>sir</code>, approximate posterior samples are generated with sampling importance resampling (SIR). With <code>importance</code>, the <code>.sample()</code> method returns a tuple of samples and corresponding importance weights.</p> <code>None</code> <code>oversampling_factor</code> <code>int</code> <p>Number of proposed samples from which only one is selected based on its importance weight.</p> <code>32</code> <code>max_sampling_batch_size</code> <code>int</code> <p>The batch size of samples being drawn from the proposal at every iteration.</p> <code>10000</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during sampling.</p> <code>False</code> Source code in <code>sbi/inference/posteriors/importance_posterior.py</code> <pre><code>def sample(\n    self,\n    sample_shape: Shape = torch.Size(),\n    x: Optional[Tensor] = None,\n    method: Optional[str] = None,\n    oversampling_factor: int = 32,\n    max_sampling_batch_size: int = 10_000,\n    sample_with: Optional[str] = None,\n    show_progress_bars: bool = False,\n) -&gt; Union[Tensor, Tuple[Tensor, Tensor]]:\n    \"\"\"Return samples from the approximate posterior distribution.\n\n    Args:\n        sample_shape: Shape of samples that are drawn from posterior.\n        x: Observed data.\n        method: Either of [`sir`|`importance`]. This sets the behavior of the\n            `.sample()` method. With `sir`, approximate posterior samples are\n            generated with sampling importance resampling (SIR). With\n            `importance`, the `.sample()` method returns a tuple of samples and\n            corresponding importance weights.\n        oversampling_factor: Number of proposed samples from which only one is\n            selected based on its importance weight.\n        max_sampling_batch_size: The batch size of samples being drawn from the\n            proposal at every iteration.\n        show_progress_bars: Whether to show a progressbar during sampling.\n    \"\"\"\n\n    method = self.method if method is None else method\n\n    if sample_with is not None:\n        raise ValueError(\n            f\"You set `sample_with={sample_with}`. As of sbi v0.18.0, setting \"\n            f\"`sample_with` is no longer supported. You have to rerun \"\n            f\"`.build_posterior(sample_with={sample_with}).`\"\n        )\n\n    self.potential_fn.set_x(self._x_else_default_x(x))\n\n    if method == \"sir\":\n        return self._sir_sample(\n            sample_shape,\n            oversampling_factor=oversampling_factor,\n            max_sampling_batch_size=max_sampling_batch_size,\n            show_progress_bars=show_progress_bars,\n        )\n    elif method == \"importance\":\n        return self._importance_sample(sample_shape)\n    else:\n        raise NameError\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.mcmc_posterior.MCMCPosterior","title":"<code>MCMCPosterior</code>","text":"<p>               Bases: <code>NeuralPosterior</code></p> <p>Provides MCMC to sample from the posterior. SNLE or SNRE train neural networks to approximate the likelihood(-ratios). <code>MCMCPosterior</code> allows to sample from the posterior with MCMC.</p> Source code in <code>sbi/inference/posteriors/mcmc_posterior.py</code> <pre><code>class MCMCPosterior(NeuralPosterior):\n    r\"\"\"Provides MCMC to sample from the posterior.&lt;br/&gt;&lt;br/&gt;\n    SNLE or SNRE train neural networks to approximate the likelihood(-ratios).\n    `MCMCPosterior` allows to sample from the posterior with MCMC.\n    \"\"\"\n\n    def __init__(\n        self,\n        potential_fn: Union[Callable, BasePotential],\n        proposal: Any,\n        theta_transform: Optional[TorchTransform] = None,\n        method: str = \"slice_np_vectorized\",\n        thin: int = -1,\n        warmup_steps: int = 200,\n        num_chains: int = 20,\n        init_strategy: str = \"resample\",\n        init_strategy_parameters: Optional[Dict[str, Any]] = None,\n        init_strategy_num_candidates: Optional[int] = None,\n        num_workers: int = 1,\n        mp_context: str = \"spawn\",\n        device: Optional[str] = None,\n        x_shape: Optional[torch.Size] = None,\n    ):\n        \"\"\"\n        Args:\n            potential_fn: The potential function from which to draw samples. Must be a\n                `BasePotential` or a `Callable` which takes `theta` and `x_o` as inputs.\n            proposal: Proposal distribution that is used to initialize the MCMC chain.\n            theta_transform: Transformation that will be applied during sampling.\n                Allows to perform MCMC in unconstrained space.\n            method: Method used for MCMC sampling, one of `slice_np`,\n                `slice_np_vectorized`, `hmc_pyro`, `nuts_pyro`, `slice_pymc`,\n                `hmc_pymc`, `nuts_pymc`. `slice_np` is a custom\n                numpy implementation of slice sampling. `slice_np_vectorized` is\n                identical to `slice_np`, but if `num_chains&gt;1`, the chains are\n                vectorized for `slice_np_vectorized` whereas they are run sequentially\n                for `slice_np`. The samplers ending on `_pyro` are using Pyro, and\n                likewise the samplers ending on `_pymc` are using PyMC.\n            thin: The thinning factor for the chain, default 1 (no thinning).\n            warmup_steps: The initial number of samples to discard.\n            num_chains: The number of chains. Should generally be at most\n                `num_workers - 1`.\n            init_strategy: The initialisation strategy for chains; `proposal` will draw\n                init locations from `proposal`, whereas `sir` will use Sequential-\n                Importance-Resampling (SIR). SIR initially samples\n                `init_strategy_num_candidates` from the `proposal`, evaluates all of\n                them under the `potential_fn` and `proposal`, and then resamples the\n                initial locations with weights proportional to `exp(potential_fn -\n                proposal.log_prob`. `resample` is the same as `sir` but\n                uses `exp(potential_fn)` as weights.\n            init_strategy_parameters: Dictionary of keyword arguments passed to the\n                init strategy, e.g., for `init_strategy=sir` this could be\n                `num_candidate_samples`, i.e., the number of candidates to find init\n                locations (internal default is `1000`), or `device`.\n            init_strategy_num_candidates: Number of candidates to find init\n                 locations in `init_strategy=sir` (deprecated, use\n                 init_strategy_parameters instead).\n            num_workers: number of cpu cores used to parallelize mcmc\n            mp_context: Multiprocessing start method, either `\"fork\"` or `\"spawn\"`\n                (default), used by Pyro and PyMC samplers. `\"fork\"` can be significantly\n                faster than `\"spawn\"` but is only supported on POSIX-based systems\n                (e.g. Linux and macOS, not Windows).\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:0\". If None,\n                `potential_fn.device` is used.\n            x_shape: Deprecated, should not be passed.\n        \"\"\"\n        if method == \"slice\":\n            warn(\n                \"The Pyro-based slice sampler is deprecated, and the method `slice` \"\n                \"has been changed to `slice_np`, i.e., the custom \"\n                \"numpy-based slice sampler.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            method = \"slice_np\"\n\n        thin = _process_thin_default(thin)\n\n        super().__init__(\n            potential_fn,\n            theta_transform=theta_transform,\n            device=device,\n            x_shape=x_shape,\n        )\n\n        self.proposal = proposal\n        self.method = method\n        self.thin = thin\n        self.warmup_steps = warmup_steps\n        self.num_chains = num_chains\n        self.init_strategy = init_strategy\n        self.init_strategy_parameters = init_strategy_parameters or {}\n        self.num_workers = num_workers\n        self.mp_context = mp_context\n        self._posterior_sampler = None\n        # Hardcode parameter name to reduce clutter kwargs.\n        self.param_name = \"theta\"\n\n        if init_strategy_num_candidates is not None:\n            warn(\n                \"Passing `init_strategy_num_candidates` is deprecated as of sbi \"\n                \"v0.19.0. Instead, use e.g., `init_strategy_parameters \"\n                f\"={'num_candidate_samples': 1000}`\",\n                stacklevel=2,\n            )\n            self.init_strategy_parameters[\"num_candidate_samples\"] = (\n                init_strategy_num_candidates\n            )\n\n        self.potential_ = self._prepare_potential(method)\n\n        self._purpose = (\n            \"It provides MCMC to .sample() from the posterior and \"\n            \"can evaluate the _unnormalized_ posterior density with .log_prob().\"\n        )\n\n    @property\n    def mcmc_method(self) -&gt; str:\n        \"\"\"Returns MCMC method.\"\"\"\n        return self._mcmc_method\n\n    @mcmc_method.setter\n    def mcmc_method(self, method: str) -&gt; None:\n        \"\"\"See `set_mcmc_method`.\"\"\"\n        self.set_mcmc_method(method)\n\n    @property\n    def posterior_sampler(self):\n        \"\"\"Returns sampler created by `sample`.\"\"\"\n        return self._posterior_sampler\n\n    def set_mcmc_method(self, method: str) -&gt; \"NeuralPosterior\":\n        \"\"\"Sets sampling method to for MCMC and returns `NeuralPosterior`.\n\n        Args:\n            method: Method to use.\n\n        Returns:\n            `NeuralPosterior` for chainable calls.\n        \"\"\"\n        self._mcmc_method = method\n        return self\n\n    def log_prob(\n        self, theta: Tensor, x: Optional[Tensor] = None, track_gradients: bool = False\n    ) -&gt; Tensor:\n        r\"\"\"Returns the log-probability of theta under the posterior.\n\n        Args:\n            theta: Parameters $\\theta$.\n            track_gradients: Whether the returned tensor supports tracking gradients.\n                This can be helpful for e.g. sensitivity analysis, but increases memory\n                consumption.\n\n        Returns:\n            `len($\\theta$)`-shaped log-probability.\n        \"\"\"\n        warn(\n            \"`.log_prob()` is deprecated for methods that can only evaluate the \"\n            \"log-probability up to a normalizing constant. Use `.potential()` instead.\",\n            stacklevel=2,\n        )\n        warn(\"The log-probability is unnormalized!\", stacklevel=2)\n\n        self.potential_fn.set_x(self._x_else_default_x(x))\n\n        theta = ensure_theta_batched(torch.as_tensor(theta))\n        return self.potential_fn(\n            theta.to(self._device), track_gradients=track_gradients\n        )\n\n    def sample(\n        self,\n        sample_shape: Shape = torch.Size(),\n        x: Optional[Tensor] = None,\n        method: Optional[str] = None,\n        thin: Optional[int] = None,\n        warmup_steps: Optional[int] = None,\n        num_chains: Optional[int] = None,\n        init_strategy: Optional[str] = None,\n        init_strategy_parameters: Optional[Dict[str, Any]] = None,\n        init_strategy_num_candidates: Optional[int] = None,\n        mcmc_parameters: Optional[Dict] = None,\n        mcmc_method: Optional[str] = None,\n        sample_with: Optional[str] = None,\n        num_workers: Optional[int] = None,\n        mp_context: Optional[str] = None,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        r\"\"\"Return samples from posterior distribution $p(\\theta|x)$ with MCMC.\n\n        Check the `__init__()` method for a description of all arguments as well as\n        their default values.\n\n        Args:\n            sample_shape: Desired shape of samples that are drawn from posterior. If\n                sample_shape is multidimensional we simply draw `sample_shape.numel()`\n                samples and then reshape into the desired shape.\n            mcmc_parameters: Dictionary that is passed only to support the API of\n                `sbi` v0.17.2 or older.\n            mcmc_method: This argument only exists to keep backward-compatibility with\n                `sbi` v0.17.2 or older. Please use `method` instead.\n            sample_with: This argument only exists to keep backward-compatibility with\n                `sbi` v0.17.2 or older. If it is set, we instantly raise an error.\n            show_progress_bars: Whether to show sampling progress monitor.\n\n        Returns:\n            Samples from posterior.\n        \"\"\"\n\n        self.potential_fn.set_x(self._x_else_default_x(x))\n\n        # Replace arguments that were not passed with their default.\n        method = self.method if method is None else method\n        thin = self.thin if thin is None else thin\n        warmup_steps = self.warmup_steps if warmup_steps is None else warmup_steps\n        num_chains = self.num_chains if num_chains is None else num_chains\n        init_strategy = self.init_strategy if init_strategy is None else init_strategy\n        num_workers = self.num_workers if num_workers is None else num_workers\n        mp_context = self.mp_context if mp_context is None else mp_context\n        init_strategy_parameters = (\n            self.init_strategy_parameters\n            if init_strategy_parameters is None\n            else init_strategy_parameters\n        )\n        if init_strategy_num_candidates is not None:\n            warn(\n                \"Passing `init_strategy_num_candidates` is deprecated as of sbi \"\n                \"v0.19.0. Instead, use e.g., \"\n                f\"`init_strategy_parameters={'num_candidate_samples': 1000}`\",\n                stacklevel=2,\n            )\n            self.init_strategy_parameters[\"num_candidate_samples\"] = (\n                init_strategy_num_candidates\n            )\n        if sample_with is not None:\n            raise ValueError(\n                f\"You set `sample_with={sample_with}`. As of sbi v0.18.0, setting \"\n                \"`sample_with` is no longer supported. You have to rerun \"\n                f\"`.build_posterior(sample_with={sample_with}).`\"\n            )\n        if mcmc_method is not None:\n            warn(\n                \"You passed `mcmc_method` to `.sample()`. As of sbi v0.18.0, this \"\n                \"is deprecated and will be removed in a future release. Use `method` \"\n                \"instead of `mcmc_method`.\",\n                stacklevel=2,\n            )\n            method = mcmc_method\n        if mcmc_parameters:\n            warn(\n                \"You passed `mcmc_parameters` to `.sample()`. As of sbi v0.18.0, this \"\n                \"is deprecated and will be removed in a future release. Instead, pass \"\n                \"the variable to `.sample()` directly, e.g. \"\n                \"`posterior.sample((1,), num_chains=5)`.\",\n                stacklevel=2,\n            )\n        # The following lines are only for backwards compatibility with sbi v0.17.2 or\n        # older.\n        m_p = mcmc_parameters or {}  # define to shorten the variable name\n        method = _maybe_use_dict_entry(method, \"mcmc_method\", m_p)\n        thin = _maybe_use_dict_entry(thin, \"thin\", m_p)\n        warmup_steps = _maybe_use_dict_entry(warmup_steps, \"warmup_steps\", m_p)\n        num_chains = _maybe_use_dict_entry(num_chains, \"num_chains\", m_p)\n        init_strategy = _maybe_use_dict_entry(init_strategy, \"init_strategy\", m_p)\n        self.potential_ = self._prepare_potential(method)  # type: ignore\n\n        initial_params = self._get_initial_params(\n            init_strategy,  # type: ignore\n            num_chains,  # type: ignore\n            num_workers,\n            show_progress_bars,\n            **init_strategy_parameters,\n        )\n        num_samples = torch.Size(sample_shape).numel()\n\n        track_gradients = method in (\"hmc_pyro\", \"nuts_pyro\", \"hmc_pymc\", \"nuts_pymc\")\n        with torch.set_grad_enabled(track_gradients):\n            if method in (\"slice_np\", \"slice_np_vectorized\"):\n                transformed_samples = self._slice_np_mcmc(\n                    num_samples=num_samples,\n                    potential_function=self.potential_,\n                    initial_params=initial_params,\n                    thin=thin,  # type: ignore\n                    warmup_steps=warmup_steps,  # type: ignore\n                    vectorized=(method == \"slice_np_vectorized\"),\n                    interchangeable_chains=True,\n                    num_workers=num_workers,\n                    show_progress_bars=show_progress_bars,\n                )\n            elif method in (\"hmc_pyro\", \"nuts_pyro\"):\n                transformed_samples = self._pyro_mcmc(\n                    num_samples=num_samples,\n                    potential_function=self.potential_,\n                    initial_params=initial_params,\n                    mcmc_method=method,  # type: ignore\n                    thin=thin,  # type: ignore\n                    warmup_steps=warmup_steps,  # type: ignore\n                    num_chains=num_chains,\n                    show_progress_bars=show_progress_bars,\n                    mp_context=mp_context,\n                )\n            elif method in (\"hmc_pymc\", \"nuts_pymc\", \"slice_pymc\"):\n                transformed_samples = self._pymc_mcmc(\n                    num_samples=num_samples,\n                    potential_function=self.potential_,\n                    initial_params=initial_params,\n                    mcmc_method=method,  # type: ignore\n                    thin=thin,  # type: ignore\n                    warmup_steps=warmup_steps,  # type: ignore\n                    num_chains=num_chains,\n                    show_progress_bars=show_progress_bars,\n                    mp_context=mp_context,\n                )\n            else:\n                raise NameError(f\"The sampling method {method} is not implemented!\")\n\n        samples = self.theta_transform.inv(transformed_samples)\n        # NOTE: Currently MCMCPosteriors will require a single dimension for the\n        # parameter dimension. With recent ConditionalDensity(Ratio) estimators, we\n        # can have multiple dimensions for the parameter dimension.\n        samples = samples.reshape((*sample_shape, -1))  # type: ignore\n\n        return samples\n\n    def sample_batched(\n        self,\n        sample_shape: Shape,\n        x: Tensor,\n        method: Optional[str] = None,\n        thin: Optional[int] = None,\n        warmup_steps: Optional[int] = None,\n        num_chains: Optional[int] = None,\n        init_strategy: Optional[str] = None,\n        init_strategy_parameters: Optional[Dict[str, Any]] = None,\n        num_workers: Optional[int] = None,\n        mp_context: Optional[str] = None,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        r\"\"\"Given a batch of observations [x_1, ..., x_B] this function samples from\n        posteriors $p(\\theta|x_1)$, ... ,$p(\\theta|x_B)$, in a batched (i.e. vectorized)\n        manner.\n\n        Check the `__init__()` method for a description of all arguments as well as\n        their default values.\n\n        Args:\n            sample_shape: Desired shape of samples that are drawn from the posterior\n                given every observation.\n            x: A batch of observations, of shape `(batch_dim, event_shape_x)`.\n                `batch_dim` corresponds to the number of observations to be\n                drawn.\n            method: Method used for MCMC sampling, e.g., \"slice_np_vectorized\".\n            thin: The thinning factor for the chain, default 1 (no thinning).\n            warmup_steps: The initial number of samples to discard.\n            num_chains: The number of chains used for each `x` passed in the batch.\n            init_strategy: The initialisation strategy for chains.\n            init_strategy_parameters: Dictionary of keyword arguments passed to\n                the init strategy.\n            num_workers: number of cpu cores used to parallelize initial\n                parameter generation and mcmc sampling.\n            mp_context: Multiprocessing start method, either `\"fork\"` or `\"spawn\"`\n            show_progress_bars: Whether to show sampling progress monitor.\n\n        Returns:\n            Samples from the posteriors of shape (*sample_shape, B, *input_shape)\n        \"\"\"\n\n        # Replace arguments that were not passed with their default.\n        method = self.method if method is None else method\n        thin = self.thin if thin is None else thin\n        warmup_steps = self.warmup_steps if warmup_steps is None else warmup_steps\n        num_chains = self.num_chains if num_chains is None else num_chains\n        init_strategy = self.init_strategy if init_strategy is None else init_strategy\n        num_workers = self.num_workers if num_workers is None else num_workers\n        mp_context = self.mp_context if mp_context is None else mp_context\n        init_strategy_parameters = (\n            self.init_strategy_parameters\n            if init_strategy_parameters is None\n            else init_strategy_parameters\n        )\n\n        assert (\n            method == \"slice_np_vectorized\"\n        ), \"Batched sampling only supported for vectorized samplers!\"\n\n        # warn if num_chains is larger than num requested samples\n        if num_chains &gt; torch.Size(sample_shape).numel():\n            warnings.warn(\n                \"The passed number of MCMC chains is larger than the number of \"\n                f\"requested samples: {num_chains} &gt; {torch.Size(sample_shape).numel()},\"\n                f\" resetting it to {torch.Size(sample_shape).numel()}.\",\n                stacklevel=2,\n            )\n            num_chains = torch.Size(sample_shape).numel()\n\n        # custom shape handling to make sure to match the batch size of x and theta\n        # without unnecessary combinations.\n        if len(x.shape) == 1:\n            x = x.unsqueeze(0)\n        batch_size = x.shape[0]\n\n        x = reshape_to_batch_event(x, event_shape=x.shape[1:])\n\n        # For batched sampling, we want `num_chains` for each observation in the batch.\n        # Here we repeat the observations ABC -&gt; AAABBBCCC, so that the chains are\n        # in the order of the observations.\n        x_ = x.repeat_interleave(num_chains, dim=0)\n\n        self.potential_fn.set_x(x_, x_is_iid=False)\n        self.potential_ = self._prepare_potential(method)  # type: ignore\n\n        # For each observation in the batch, we have num_chains independent chains.\n        num_chains_extended = batch_size * num_chains\n        if num_chains_extended &gt; 100:\n            warnings.warn(\n                \"Note that for batched sampling, we use num_chains many chains for each\"\n                \" x in the batch. With the given settings, this results in a large \"\n                f\"number large number of chains ({num_chains_extended}), which can be \"\n                \"slow and memory-intensive for vectorized MCMC. Consider reducing the \"\n                \"number of chains.\",\n                stacklevel=2,\n            )\n        init_strategy_parameters[\"num_return_samples\"] = num_chains_extended\n        initial_params = self._get_initial_params_batched(\n            x,\n            init_strategy,  # type: ignore\n            num_chains,  # type: ignore\n            num_workers,\n            show_progress_bars,\n            **init_strategy_parameters,\n        )\n        # We need num_samples from each posterior in the batch\n        num_samples = torch.Size(sample_shape).numel() * batch_size\n\n        with torch.set_grad_enabled(False):\n            transformed_samples = self._slice_np_mcmc(\n                num_samples=num_samples,\n                potential_function=self.potential_,\n                initial_params=initial_params,\n                thin=thin,  # type: ignore\n                warmup_steps=warmup_steps,  # type: ignore\n                vectorized=(method == \"slice_np_vectorized\"),\n                interchangeable_chains=False,\n                num_workers=num_workers,\n                show_progress_bars=show_progress_bars,\n            )\n\n        # (num_chains_extended, samples_per_chain, *input_shape)\n        samples_per_chain: Tensor = self.theta_transform.inv(transformed_samples)  # type: ignore\n        dim_theta = samples_per_chain.shape[-1]\n        # We need to collect samples for each x from the respective chains.\n        # However, using samples.reshape(*sample_shape, batch_size, dim_theta)\n        # does not combine the samples in the right order, since this mixes\n        # samples that belong to different `x`. The following permute is a\n        # workaround to reshape the samples in the right order.\n        samples_per_x = samples_per_chain.reshape((\n            batch_size,\n            # We are flattening the sample shape here using -1 because we might have\n            # generated more samples than requested (more chains, or multiple of\n            # chains not matching sample_shape)\n            -1,\n            dim_theta,\n        )).permute(1, 0, -1)\n\n        # Shape is now (-1, batch_size, dim_theta)\n        # We can now select the number of requested samples\n        samples = samples_per_x[: torch.Size(sample_shape).numel()]\n        # and reshape into (*sample_shape, batch_size, dim_theta)\n        samples = samples.reshape((*sample_shape, batch_size, dim_theta))\n        return samples\n\n    def _build_mcmc_init_fn(\n        self,\n        proposal: Any,\n        potential_fn: Callable,\n        transform: torch_tf.Transform,\n        init_strategy: str,\n        **kwargs,\n    ) -&gt; Callable:\n        \"\"\"Return function that, when called, creates an initial parameter set for MCMC.\n\n        Args:\n            proposal: Proposal distribution.\n            potential_fn: Potential function that the candidate samples are weighted\n                with.\n            init_strategy: Specifies the initialization method. Either of\n                [`proposal`|`sir`|`resample`|`latest_sample`].\n            kwargs: Passed on to init function. This way, init specific keywords can\n                be set through `mcmc_parameters`. Unused arguments will be absorbed by\n                the intitialization method.\n\n        Returns: Initialization function.\n        \"\"\"\n        if init_strategy == \"proposal\" or init_strategy == \"prior\":\n            if init_strategy == \"prior\":\n                warn(\n                    \"You set `init_strategy=prior`. As of sbi v0.18.0, this is \"\n                    \"deprecated and it will be removed in a future release. Use \"\n                    \"`init_strategy=proposal` instead.\",\n                    stacklevel=2,\n                )\n            return lambda: proposal_init(proposal, transform=transform, **kwargs)\n        elif init_strategy == \"sir\":\n            warn(\n                \"As of sbi v0.19.0, the behavior of the SIR initialization for MCMC \"\n                \"has changed. If you wish to restore the behavior of sbi v0.18.0, set \"\n                \"`init_strategy='resample'.`\",\n                stacklevel=2,\n            )\n            return lambda: sir_init(\n                proposal, potential_fn, transform=transform, **kwargs\n            )\n        elif init_strategy == \"resample\":\n            return lambda: resample_given_potential_fn(\n                proposal, potential_fn, transform=transform, **kwargs\n            )\n        elif init_strategy == \"latest_sample\":\n            latest_sample = IterateParameters(self._mcmc_init_params, **kwargs)\n            return latest_sample\n        else:\n            raise NotImplementedError\n\n    def _get_initial_params(\n        self,\n        init_strategy: str,\n        num_chains: int,\n        num_workers: int,\n        show_progress_bars: bool,\n        **kwargs,\n    ) -&gt; Tensor:\n        \"\"\"Return initial parameters for MCMC obtained with given init strategy.\n\n        Parallelizes across CPU cores only for resample and SIR.\n\n        Args:\n            init_strategy: Specifies the initialization method. Either of\n                [`proposal`|`sir`|`resample`|`latest_sample`].\n            num_chains: number of MCMC chains, generates initial params for each\n            num_workers: number of CPU cores for parallization\n            show_progress_bars: whether to show progress bars for SIR init\n            kwargs: Passed on to `_build_mcmc_init_fn`.\n\n        Returns:\n            Tensor: initial parameters, one for each chain\n        \"\"\"\n        # Build init function\n        init_fn = self._build_mcmc_init_fn(\n            self.proposal,\n            self.potential_fn,\n            transform=self.theta_transform,\n            init_strategy=init_strategy,  # type: ignore\n            **kwargs,\n        )\n\n        # Parallelize inits for resampling only.\n        if num_workers &gt; 1 and (init_strategy == \"resample\" or init_strategy == \"sir\"):\n\n            def seeded_init_fn(seed):\n                torch.manual_seed(seed)\n                return init_fn()\n\n            seeds = torch.randint(high=2**31, size=(num_chains,))\n\n            # Generate initial params parallelized over num_workers.\n            initial_params = list(\n                tqdm(\n                    Parallel(return_as=\"generator\", n_jobs=num_workers)(\n                        delayed(seeded_init_fn)(seed) for seed in seeds\n                    ),\n                    total=len(seeds),\n                    desc=f\"\"\"Generating {num_chains} MCMC inits with\n                            {num_workers} workers.\"\"\",\n                    disable=not show_progress_bars,\n                )\n            )\n            initial_params = torch.cat(initial_params)  # type: ignore\n        else:\n            initial_params = torch.cat(\n                [init_fn() for _ in range(num_chains)]  # type: ignore\n            )\n        return initial_params\n\n    def _get_initial_params_batched(\n        self,\n        x: torch.Tensor,\n        init_strategy: str,\n        num_chains_per_x: int,\n        num_workers: int,\n        show_progress_bars: bool,\n        **kwargs,\n    ) -&gt; Tensor:\n        \"\"\"Return initial parameters for MCMC for a batch of `x`, obtained with given\n           init strategy.\n\n        Parallelizes across CPU cores only for resample and SIR.\n\n        Args:\n            x: Batch of observations to create different initial parameters for.\n            init_strategy: Specifies the initialization method. Either of\n                [`proposal`|`sir`|`resample`|`latest_sample`].\n            num_chains_per_x: number of MCMC chains for each x, generates initial params\n                for each x\n            num_workers: number of CPU cores for parallization\n            show_progress_bars: whether to show progress bars for SIR init\n            kwargs: Passed on to `_build_mcmc_init_fn`.\n\n        Returns:\n            Tensor: initial parameters, one for each chain\n        \"\"\"\n\n        potential_ = deepcopy(self.potential_fn)\n        initial_params = []\n        init_fn = self._build_mcmc_init_fn(\n            self.proposal,\n            potential_fn=potential_,\n            transform=self.theta_transform,\n            init_strategy=init_strategy,  # type: ignore\n            **kwargs,\n        )\n        for xi in x:\n            # Build init function\n            potential_.set_x(xi)\n\n            # Parallelize inits for resampling or sir.\n            if num_workers &gt; 1 and (\n                init_strategy == \"resample\" or init_strategy == \"sir\"\n            ):\n\n                def seeded_init_fn(seed):\n                    torch.manual_seed(seed)\n                    return init_fn()\n\n                seeds = torch.randint(high=2**31, size=(num_chains_per_x,))\n\n                # Generate initial params parallelized over num_workers.\n                initial_params = initial_params + list(\n                    tqdm(\n                        Parallel(return_as=\"generator\", n_jobs=num_workers)(\n                            delayed(seeded_init_fn)(seed) for seed in seeds\n                        ),\n                        total=len(seeds),\n                        desc=f\"\"\"Generating {num_chains_per_x} MCMC inits with\n                                {num_workers} workers.\"\"\",\n                        disable=not show_progress_bars,\n                    )\n                )\n\n            else:\n                initial_params = initial_params + [\n                    init_fn() for _ in range(num_chains_per_x)\n                ]  # type: ignore\n\n        initial_params = torch.cat(initial_params)\n        return initial_params\n\n    def _slice_np_mcmc(\n        self,\n        num_samples: int,\n        potential_function: Callable,\n        initial_params: Tensor,\n        thin: int,\n        warmup_steps: int,\n        vectorized: bool = False,\n        interchangeable_chains=True,\n        num_workers: int = 1,\n        init_width: Union[float, ndarray] = 0.01,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        \"\"\"Custom implementation of slice sampling using Numpy.\n\n        Args:\n            num_samples: Desired number of samples.\n            potential_function: A callable **class**.\n            initial_params: Initial parameters for MCMC chain.\n            thin: Thinning (subsampling) factor, default 1 (no thinning).\n            warmup_steps: Initial number of samples to discard.\n            vectorized: Whether to use a vectorized implementation of the\n                `SliceSampler`.\n            interchangeable_chains: Whether chains are interchangeable, i.e., whether\n                we can mix samples between chains.\n            num_workers: Number of CPU cores to use.\n            init_width: Inital width of brackets.\n            show_progress_bars: Whether to show a progressbar during sampling;\n                can only be turned off for vectorized sampler.\n\n        Returns:\n            Tensor of shape (num_samples, shape_of_single_theta).\n        \"\"\"\n\n        num_chains, dim_samples = initial_params.shape\n\n        if not vectorized:\n            SliceSamplerMultiChain = SliceSamplerSerial\n        else:\n            SliceSamplerMultiChain = SliceSamplerVectorized\n\n        def multi_obs_potential(params):\n            # Params are of shape (num_chains * num_obs, event).\n            all_potentials = potential_function(params)  # Shape: (num_chains, num_obs)\n            return all_potentials.flatten()\n\n        posterior_sampler = SliceSamplerMultiChain(\n            init_params=tensor2numpy(initial_params),\n            log_prob_fn=multi_obs_potential,\n            num_chains=num_chains,\n            thin=thin,\n            verbose=show_progress_bars,\n            num_workers=num_workers,\n            init_width=init_width,\n        )\n        warmup_ = warmup_steps * thin\n        num_samples_ = ceil((num_samples * thin) / num_chains)\n        # Run mcmc including warmup\n        samples = posterior_sampler.run(warmup_ + num_samples_)\n        samples = samples[:, warmup_steps:, :]  # discard warmup steps\n        samples = torch.from_numpy(samples)  # chains x samples x dim\n\n        # Save posterior sampler.\n        self._posterior_sampler = posterior_sampler\n\n        # Save sample as potential next init (if init_strategy == 'latest_sample').\n        self._mcmc_init_params = samples[:, -1, :].reshape(num_chains, dim_samples)\n\n        # Update: If chains are interchangeable, return concatenated samples. Otherwise\n        # return samples per chain.\n        if interchangeable_chains:\n            # Collect samples from all chains.\n            samples = samples.reshape(-1, dim_samples)[:num_samples]\n\n        return samples.type(torch.float32).to(self._device)\n\n    def _pyro_mcmc(\n        self,\n        num_samples: int,\n        potential_function: Callable,\n        initial_params: Tensor,\n        mcmc_method: str = \"nuts_pyro\",\n        thin: int = -1,\n        warmup_steps: int = 200,\n        num_chains: Optional[int] = 1,\n        show_progress_bars: bool = True,\n        mp_context: str = \"spawn\",\n    ) -&gt; Tensor:\n        r\"\"\"Return samples obtained using Pyro's HMC or NUTS sampler.\n\n        Args:\n            num_samples: Desired number of samples.\n            potential_function: A callable **class**. A class, but not a function,\n                is picklable for Pyro MCMC to use it across chains in parallel,\n                even when the potential function requires evaluating a neural network.\n            initial_params: Initial parameters for MCMC chain.\n            mcmc_method: Pyro MCMC method to use, either `\"hmc_pyro\"` or\n                `\"nuts_pyro\"` (default).\n            thin: Thinning (subsampling) factor, default 1 (no thinning).\n            warmup_steps: Initial number of samples to discard.\n            num_chains: Whether to sample in parallel. If None, use all but one CPU.\n            show_progress_bars: Whether to show a progressbar during sampling.\n\n        Returns:\n            Tensor of shape (num_samples, shape_of_single_theta).\n        \"\"\"\n        thin = _process_thin_default(thin)\n        num_chains = mp.cpu_count() - 1 if num_chains is None else num_chains\n        kernels = dict(hmc_pyro=HMC, nuts_pyro=NUTS)\n\n        sampler = MCMC(\n            kernel=kernels[mcmc_method](potential_fn=potential_function),\n            num_samples=ceil((thin * num_samples) / num_chains),\n            warmup_steps=warmup_steps,\n            initial_params={self.param_name: initial_params},\n            num_chains=num_chains,\n            mp_context=mp_context,\n            disable_progbar=not show_progress_bars,\n            transforms={},\n        )\n        sampler.run()\n        samples = next(iter(sampler.get_samples().values())).reshape(\n            -1,\n            initial_params.shape[1],  # .shape[1] = dim of theta\n        )\n\n        # Save posterior sampler.\n        self._posterior_sampler = sampler\n\n        samples = samples[::thin][:num_samples]\n\n        return samples.detach()\n\n    def _pymc_mcmc(\n        self,\n        num_samples: int,\n        potential_function: Callable,\n        initial_params: Tensor,\n        mcmc_method: str = \"nuts_pymc\",\n        thin: int = -1,\n        warmup_steps: int = 200,\n        num_chains: Optional[int] = 1,\n        show_progress_bars: bool = True,\n        mp_context: str = \"spawn\",\n    ) -&gt; Tensor:\n        r\"\"\"Return samples obtained using PyMC's HMC, NUTS or slice samplers.\n\n        Args:\n            num_samples: Desired number of samples.\n            potential_function: A callable **class**. A class, but not a function,\n                is picklable for PyMC MCMC to use it across chains in parallel,\n                even when the potential function requires evaluating a neural network.\n            initial_params: Initial parameters for MCMC chain.\n            mcmc_method: mcmc_method: Pyro MCMC method to use, either `\"hmc_pymc\"` or\n                `\"slice_pymc\"`, or `\"nuts_pymc\"` (default).\n            thin: Thinning (subsampling) factor, default 1 (no thinning).\n            warmup_steps: Initial number of samples to discard.\n            num_chains: Whether to sample in parallel. If None, use all but one CPU.\n            show_progress_bars: Whether to show a progressbar during sampling.\n\n        Returns:\n            Tensor of shape (num_samples, shape_of_single_theta).\n        \"\"\"\n        thin = _process_thin_default(thin)\n        num_chains = mp.cpu_count() - 1 if num_chains is None else num_chains\n        steps = dict(slice_pymc=\"slice\", hmc_pymc=\"hmc\", nuts_pymc=\"nuts\")\n\n        sampler = PyMCSampler(\n            potential_fn=potential_function,\n            step=steps[mcmc_method],\n            initvals=tensor2numpy(initial_params),\n            draws=ceil((thin * num_samples) / num_chains),\n            tune=warmup_steps,\n            chains=num_chains,\n            mp_ctx=mp_context,\n            progressbar=show_progress_bars,\n            param_name=self.param_name,\n            device=self._device,\n        )\n        samples = sampler.run()\n        samples = torch.from_numpy(samples).to(dtype=torch.float32, device=self._device)\n        samples = samples.reshape(-1, initial_params.shape[1])\n\n        # Save posterior sampler.\n        self._posterior_sampler = sampler\n\n        samples = samples[::thin][:num_samples]\n\n        return samples\n\n    def _prepare_potential(self, method: str) -&gt; Callable:\n        \"\"\"Combines potential and transform and takes care of gradients and pyro.\n\n        Args:\n            method: Which MCMC method to use.\n\n        Returns:\n            A potential function that is ready to be used in MCMC.\n        \"\"\"\n        if method in (\"hmc_pyro\", \"nuts_pyro\"):\n            track_gradients = True\n            pyro = True\n        elif method in (\"hmc_pymc\", \"nuts_pymc\"):\n            track_gradients = True\n            pyro = False\n        elif method in (\"slice_np\", \"slice_np_vectorized\", \"slice_pymc\"):\n            track_gradients = False\n            pyro = False\n        else:\n            if \"hmc\" in method or \"nuts\" in method:\n                warn(\n                    \"The kwargs 'hmc' and 'nuts' are deprecated. Use 'hmc_pyro', \"\n                    \"'nuts_pyro', 'hmc_pymc', or 'nuts_pymc' instead.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n            raise NotImplementedError(f\"MCMC method {method} is not implemented.\")\n\n        prepared_potential = partial(\n            transformed_potential,\n            potential_fn=self.potential_fn,\n            theta_transform=self.theta_transform,\n            device=self._device,\n            track_gradients=track_gradients,\n        )\n        if pyro:\n            prepared_potential = partial(\n                pyro_potential_wrapper, potential=prepared_potential\n            )\n\n        return prepared_potential\n\n    def map(\n        self,\n        x: Optional[Tensor] = None,\n        num_iter: int = 1_000,\n        num_to_optimize: int = 100,\n        learning_rate: float = 0.01,\n        init_method: Union[str, Tensor] = \"proposal\",\n        num_init_samples: int = 1_000,\n        save_best_every: int = 10,\n        show_progress_bars: bool = False,\n        force_update: bool = False,\n    ) -&gt; Tensor:\n        r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n        The method can be interrupted (Ctrl-C) when the user sees that the\n        log-probability converges. The best estimate will be saved in `self._map` and\n        can be accessed with `self.map()`. The MAP is obtained by running gradient\n        ascent from a given number of starting positions (samples from the posterior\n        with the highest log-probability). After the optimization is done, we select the\n        parameter set that has the highest log-probability after the optimization.\n\n        Warning: The default values used by this function are not well-tested. They\n        might require hand-tuning for the problem at hand.\n\n        For developers: if the prior is a `BoxUniform`, we carry out the optimization\n        in unbounded space and transform the result back into bounded space.\n\n        Args:\n            x: Deprecated - use `.set_default_x()` prior to `.map()`.\n            num_iter: Number of optimization steps that the algorithm takes\n                to find the MAP.\n            learning_rate: Learning rate of the optimizer.\n            init_method: How to select the starting parameters for the optimization. If\n                it is a string, it can be either [`posterior`, `prior`], which samples\n                the respective distribution `num_init_samples` times. If it is a\n                tensor, the tensor will be used as init locations.\n            num_init_samples: Draw this number of samples from the posterior and\n                evaluate the log-probability of all of them.\n            num_to_optimize: From the drawn `num_init_samples`, use the\n                `num_to_optimize` with highest log-probability as the initial points\n                for the optimization.\n            save_best_every: The best log-probability is computed, saved in the\n                `map`-attribute, and printed every `save_best_every`-th iteration.\n                Computing the best log-probability creates a significant overhead\n                (thus, the default is `10`.)\n            show_progress_bars: Whether to show a progressbar during sampling from\n                the posterior.\n            force_update: Whether to re-calculate the MAP when x is unchanged and\n                have a cached value.\n            log_prob_kwargs: Will be empty for SNLE and SNRE. Will contain\n                {'norm_posterior': True} for SNPE.\n\n        Returns:\n            The MAP estimate.\n        \"\"\"\n        return super().map(\n            x=x,\n            num_iter=num_iter,\n            num_to_optimize=num_to_optimize,\n            learning_rate=learning_rate,\n            init_method=init_method,\n            num_init_samples=num_init_samples,\n            save_best_every=save_best_every,\n            show_progress_bars=show_progress_bars,\n            force_update=force_update,\n        )\n\n    def get_arviz_inference_data(self) -&gt; InferenceData:\n        \"\"\"Returns arviz InferenceData object constructed most recent samples.\n\n        Note: the InferenceData is constructed using the posterior samples generated in\n        most recent call to `.sample(...)`.\n\n        For Pyro and PyMC samplers, InferenceData will contain diagnostics, but for\n        sbi slice samplers, only the samples are added.\n\n        Returns:\n            inference_data: Arviz InferenceData object.\n        \"\"\"\n        assert (\n            self._posterior_sampler is not None\n        ), \"\"\"No samples have been generated, call .sample() first.\"\"\"\n\n        sampler: Union[\n            MCMC, SliceSamplerSerial, SliceSamplerVectorized, PyMCSampler\n        ] = self._posterior_sampler\n\n        # If Pyro sampler and samples not transformed, use arviz' from_pyro.\n        if isinstance(sampler, (HMC, NUTS)) and isinstance(\n            self.theta_transform, torch_tf.IndependentTransform\n        ):\n            inference_data = az.from_pyro(sampler)\n        # If PyMC sampler and samples not transformed, get cached InferenceData.\n        elif isinstance(sampler, PyMCSampler) and isinstance(\n            self.theta_transform, torch_tf.IndependentTransform\n        ):\n            inference_data = sampler.get_inference_data()\n\n        # otherwise get samples from sampler and transform to original space.\n        else:\n            transformed_samples = sampler.get_samples(group_by_chain=True)\n            # Pyro samplers returns dicts, get values.\n            if isinstance(transformed_samples, Dict):\n                # popitem gets last items, [1] get the values as tensor.\n                transformed_samples = transformed_samples.popitem()[1]\n            # Our slice samplers return numpy arrays.\n            elif isinstance(transformed_samples, ndarray):\n                transformed_samples = torch.from_numpy(transformed_samples).type(\n                    torch.float32\n                )\n            # For MultipleIndependent priors transforms first dim must be batch dim.\n            # thus, reshape back and forth to have batch dim in front.\n            samples_shape = transformed_samples.shape\n            samples = self.theta_transform.inv(  # type: ignore\n                transformed_samples.reshape(-1, samples_shape[-1])\n            ).reshape(  # type: ignore\n                *samples_shape\n            )\n\n            inference_data = az.convert_to_inference_data({\n                f\"{self.param_name}\": samples\n            })\n\n        return inference_data\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.mcmc_posterior.MCMCPosterior.mcmc_method","title":"<code>mcmc_method: str</code>  <code>property</code> <code>writable</code>","text":"<p>Returns MCMC method.</p>"},{"location":"reference/posteriors/#sbi.inference.posteriors.mcmc_posterior.MCMCPosterior.posterior_sampler","title":"<code>posterior_sampler</code>  <code>property</code>","text":"<p>Returns sampler created by <code>sample</code>.</p>"},{"location":"reference/posteriors/#sbi.inference.posteriors.mcmc_posterior.MCMCPosterior.__init__","title":"<code>__init__(potential_fn, proposal, theta_transform=None, method='slice_np_vectorized', thin=-1, warmup_steps=200, num_chains=20, init_strategy='resample', init_strategy_parameters=None, init_strategy_num_candidates=None, num_workers=1, mp_context='spawn', device=None, x_shape=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>potential_fn</code> <code>Union[Callable, BasePotential]</code> <p>The potential function from which to draw samples. Must be a <code>BasePotential</code> or a <code>Callable</code> which takes <code>theta</code> and <code>x_o</code> as inputs.</p> required <code>proposal</code> <code>Any</code> <p>Proposal distribution that is used to initialize the MCMC chain.</p> required <code>theta_transform</code> <code>Optional[TorchTransform]</code> <p>Transformation that will be applied during sampling. Allows to perform MCMC in unconstrained space.</p> <code>None</code> <code>method</code> <code>str</code> <p>Method used for MCMC sampling, one of <code>slice_np</code>, <code>slice_np_vectorized</code>, <code>hmc_pyro</code>, <code>nuts_pyro</code>, <code>slice_pymc</code>, <code>hmc_pymc</code>, <code>nuts_pymc</code>. <code>slice_np</code> is a custom numpy implementation of slice sampling. <code>slice_np_vectorized</code> is identical to <code>slice_np</code>, but if <code>num_chains&gt;1</code>, the chains are vectorized for <code>slice_np_vectorized</code> whereas they are run sequentially for <code>slice_np</code>. The samplers ending on <code>_pyro</code> are using Pyro, and likewise the samplers ending on <code>_pymc</code> are using PyMC.</p> <code>'slice_np_vectorized'</code> <code>thin</code> <code>int</code> <p>The thinning factor for the chain, default 1 (no thinning).</p> <code>-1</code> <code>warmup_steps</code> <code>int</code> <p>The initial number of samples to discard.</p> <code>200</code> <code>num_chains</code> <code>int</code> <p>The number of chains. Should generally be at most <code>num_workers - 1</code>.</p> <code>20</code> <code>init_strategy</code> <code>str</code> <p>The initialisation strategy for chains; <code>proposal</code> will draw init locations from <code>proposal</code>, whereas <code>sir</code> will use Sequential- Importance-Resampling (SIR). SIR initially samples <code>init_strategy_num_candidates</code> from the <code>proposal</code>, evaluates all of them under the <code>potential_fn</code> and <code>proposal</code>, and then resamples the initial locations with weights proportional to <code>exp(potential_fn - proposal.log_prob</code>. <code>resample</code> is the same as <code>sir</code> but uses <code>exp(potential_fn)</code> as weights.</p> <code>'resample'</code> <code>init_strategy_parameters</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary of keyword arguments passed to the init strategy, e.g., for <code>init_strategy=sir</code> this could be <code>num_candidate_samples</code>, i.e., the number of candidates to find init locations (internal default is <code>1000</code>), or <code>device</code>.</p> <code>None</code> <code>init_strategy_num_candidates</code> <code>Optional[int]</code> <p>Number of candidates to find init  locations in <code>init_strategy=sir</code> (deprecated, use  init_strategy_parameters instead).</p> <code>None</code> <code>num_workers</code> <code>int</code> <p>number of cpu cores used to parallelize mcmc</p> <code>1</code> <code>mp_context</code> <code>str</code> <p>Multiprocessing start method, either <code>\"fork\"</code> or <code>\"spawn\"</code> (default), used by Pyro and PyMC samplers. <code>\"fork\"</code> can be significantly faster than <code>\"spawn\"</code> but is only supported on POSIX-based systems (e.g. Linux and macOS, not Windows).</p> <code>'spawn'</code> <code>device</code> <code>Optional[str]</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:0\u201d. If None, <code>potential_fn.device</code> is used.</p> <code>None</code> <code>x_shape</code> <code>Optional[Size]</code> <p>Deprecated, should not be passed.</p> <code>None</code> Source code in <code>sbi/inference/posteriors/mcmc_posterior.py</code> <pre><code>def __init__(\n    self,\n    potential_fn: Union[Callable, BasePotential],\n    proposal: Any,\n    theta_transform: Optional[TorchTransform] = None,\n    method: str = \"slice_np_vectorized\",\n    thin: int = -1,\n    warmup_steps: int = 200,\n    num_chains: int = 20,\n    init_strategy: str = \"resample\",\n    init_strategy_parameters: Optional[Dict[str, Any]] = None,\n    init_strategy_num_candidates: Optional[int] = None,\n    num_workers: int = 1,\n    mp_context: str = \"spawn\",\n    device: Optional[str] = None,\n    x_shape: Optional[torch.Size] = None,\n):\n    \"\"\"\n    Args:\n        potential_fn: The potential function from which to draw samples. Must be a\n            `BasePotential` or a `Callable` which takes `theta` and `x_o` as inputs.\n        proposal: Proposal distribution that is used to initialize the MCMC chain.\n        theta_transform: Transformation that will be applied during sampling.\n            Allows to perform MCMC in unconstrained space.\n        method: Method used for MCMC sampling, one of `slice_np`,\n            `slice_np_vectorized`, `hmc_pyro`, `nuts_pyro`, `slice_pymc`,\n            `hmc_pymc`, `nuts_pymc`. `slice_np` is a custom\n            numpy implementation of slice sampling. `slice_np_vectorized` is\n            identical to `slice_np`, but if `num_chains&gt;1`, the chains are\n            vectorized for `slice_np_vectorized` whereas they are run sequentially\n            for `slice_np`. The samplers ending on `_pyro` are using Pyro, and\n            likewise the samplers ending on `_pymc` are using PyMC.\n        thin: The thinning factor for the chain, default 1 (no thinning).\n        warmup_steps: The initial number of samples to discard.\n        num_chains: The number of chains. Should generally be at most\n            `num_workers - 1`.\n        init_strategy: The initialisation strategy for chains; `proposal` will draw\n            init locations from `proposal`, whereas `sir` will use Sequential-\n            Importance-Resampling (SIR). SIR initially samples\n            `init_strategy_num_candidates` from the `proposal`, evaluates all of\n            them under the `potential_fn` and `proposal`, and then resamples the\n            initial locations with weights proportional to `exp(potential_fn -\n            proposal.log_prob`. `resample` is the same as `sir` but\n            uses `exp(potential_fn)` as weights.\n        init_strategy_parameters: Dictionary of keyword arguments passed to the\n            init strategy, e.g., for `init_strategy=sir` this could be\n            `num_candidate_samples`, i.e., the number of candidates to find init\n            locations (internal default is `1000`), or `device`.\n        init_strategy_num_candidates: Number of candidates to find init\n             locations in `init_strategy=sir` (deprecated, use\n             init_strategy_parameters instead).\n        num_workers: number of cpu cores used to parallelize mcmc\n        mp_context: Multiprocessing start method, either `\"fork\"` or `\"spawn\"`\n            (default), used by Pyro and PyMC samplers. `\"fork\"` can be significantly\n            faster than `\"spawn\"` but is only supported on POSIX-based systems\n            (e.g. Linux and macOS, not Windows).\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:0\". If None,\n            `potential_fn.device` is used.\n        x_shape: Deprecated, should not be passed.\n    \"\"\"\n    if method == \"slice\":\n        warn(\n            \"The Pyro-based slice sampler is deprecated, and the method `slice` \"\n            \"has been changed to `slice_np`, i.e., the custom \"\n            \"numpy-based slice sampler.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        method = \"slice_np\"\n\n    thin = _process_thin_default(thin)\n\n    super().__init__(\n        potential_fn,\n        theta_transform=theta_transform,\n        device=device,\n        x_shape=x_shape,\n    )\n\n    self.proposal = proposal\n    self.method = method\n    self.thin = thin\n    self.warmup_steps = warmup_steps\n    self.num_chains = num_chains\n    self.init_strategy = init_strategy\n    self.init_strategy_parameters = init_strategy_parameters or {}\n    self.num_workers = num_workers\n    self.mp_context = mp_context\n    self._posterior_sampler = None\n    # Hardcode parameter name to reduce clutter kwargs.\n    self.param_name = \"theta\"\n\n    if init_strategy_num_candidates is not None:\n        warn(\n            \"Passing `init_strategy_num_candidates` is deprecated as of sbi \"\n            \"v0.19.0. Instead, use e.g., `init_strategy_parameters \"\n            f\"={'num_candidate_samples': 1000}`\",\n            stacklevel=2,\n        )\n        self.init_strategy_parameters[\"num_candidate_samples\"] = (\n            init_strategy_num_candidates\n        )\n\n    self.potential_ = self._prepare_potential(method)\n\n    self._purpose = (\n        \"It provides MCMC to .sample() from the posterior and \"\n        \"can evaluate the _unnormalized_ posterior density with .log_prob().\"\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.mcmc_posterior.MCMCPosterior.get_arviz_inference_data","title":"<code>get_arviz_inference_data()</code>","text":"<p>Returns arviz InferenceData object constructed most recent samples.</p> <p>Note: the InferenceData is constructed using the posterior samples generated in most recent call to <code>.sample(...)</code>.</p> <p>For Pyro and PyMC samplers, InferenceData will contain diagnostics, but for sbi slice samplers, only the samples are added.</p> <p>Returns:</p> Name Type Description <code>inference_data</code> <code>InferenceData</code> <p>Arviz InferenceData object.</p> Source code in <code>sbi/inference/posteriors/mcmc_posterior.py</code> <pre><code>def get_arviz_inference_data(self) -&gt; InferenceData:\n    \"\"\"Returns arviz InferenceData object constructed most recent samples.\n\n    Note: the InferenceData is constructed using the posterior samples generated in\n    most recent call to `.sample(...)`.\n\n    For Pyro and PyMC samplers, InferenceData will contain diagnostics, but for\n    sbi slice samplers, only the samples are added.\n\n    Returns:\n        inference_data: Arviz InferenceData object.\n    \"\"\"\n    assert (\n        self._posterior_sampler is not None\n    ), \"\"\"No samples have been generated, call .sample() first.\"\"\"\n\n    sampler: Union[\n        MCMC, SliceSamplerSerial, SliceSamplerVectorized, PyMCSampler\n    ] = self._posterior_sampler\n\n    # If Pyro sampler and samples not transformed, use arviz' from_pyro.\n    if isinstance(sampler, (HMC, NUTS)) and isinstance(\n        self.theta_transform, torch_tf.IndependentTransform\n    ):\n        inference_data = az.from_pyro(sampler)\n    # If PyMC sampler and samples not transformed, get cached InferenceData.\n    elif isinstance(sampler, PyMCSampler) and isinstance(\n        self.theta_transform, torch_tf.IndependentTransform\n    ):\n        inference_data = sampler.get_inference_data()\n\n    # otherwise get samples from sampler and transform to original space.\n    else:\n        transformed_samples = sampler.get_samples(group_by_chain=True)\n        # Pyro samplers returns dicts, get values.\n        if isinstance(transformed_samples, Dict):\n            # popitem gets last items, [1] get the values as tensor.\n            transformed_samples = transformed_samples.popitem()[1]\n        # Our slice samplers return numpy arrays.\n        elif isinstance(transformed_samples, ndarray):\n            transformed_samples = torch.from_numpy(transformed_samples).type(\n                torch.float32\n            )\n        # For MultipleIndependent priors transforms first dim must be batch dim.\n        # thus, reshape back and forth to have batch dim in front.\n        samples_shape = transformed_samples.shape\n        samples = self.theta_transform.inv(  # type: ignore\n            transformed_samples.reshape(-1, samples_shape[-1])\n        ).reshape(  # type: ignore\n            *samples_shape\n        )\n\n        inference_data = az.convert_to_inference_data({\n            f\"{self.param_name}\": samples\n        })\n\n    return inference_data\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.mcmc_posterior.MCMCPosterior.log_prob","title":"<code>log_prob(theta, x=None, track_gradients=False)</code>","text":"<p>Returns the log-probability of theta under the posterior.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Tensor</code> <p>Parameters \\(\\theta\\).</p> required <code>track_gradients</code> <code>bool</code> <p>Whether the returned tensor supports tracking gradients. This can be helpful for e.g. sensitivity analysis, but increases memory consumption.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tensor</code> <p><code>len($\\theta$)</code>-shaped log-probability.</p> Source code in <code>sbi/inference/posteriors/mcmc_posterior.py</code> <pre><code>def log_prob(\n    self, theta: Tensor, x: Optional[Tensor] = None, track_gradients: bool = False\n) -&gt; Tensor:\n    r\"\"\"Returns the log-probability of theta under the posterior.\n\n    Args:\n        theta: Parameters $\\theta$.\n        track_gradients: Whether the returned tensor supports tracking gradients.\n            This can be helpful for e.g. sensitivity analysis, but increases memory\n            consumption.\n\n    Returns:\n        `len($\\theta$)`-shaped log-probability.\n    \"\"\"\n    warn(\n        \"`.log_prob()` is deprecated for methods that can only evaluate the \"\n        \"log-probability up to a normalizing constant. Use `.potential()` instead.\",\n        stacklevel=2,\n    )\n    warn(\"The log-probability is unnormalized!\", stacklevel=2)\n\n    self.potential_fn.set_x(self._x_else_default_x(x))\n\n    theta = ensure_theta_batched(torch.as_tensor(theta))\n    return self.potential_fn(\n        theta.to(self._device), track_gradients=track_gradients\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.mcmc_posterior.MCMCPosterior.map","title":"<code>map(x=None, num_iter=1000, num_to_optimize=100, learning_rate=0.01, init_method='proposal', num_init_samples=1000, save_best_every=10, show_progress_bars=False, force_update=False)</code>","text":"<p>Returns the maximum-a-posteriori estimate (MAP).</p> <p>The method can be interrupted (Ctrl-C) when the user sees that the log-probability converges. The best estimate will be saved in <code>self._map</code> and can be accessed with <code>self.map()</code>. The MAP is obtained by running gradient ascent from a given number of starting positions (samples from the posterior with the highest log-probability). After the optimization is done, we select the parameter set that has the highest log-probability after the optimization.</p> <p>Warning: The default values used by this function are not well-tested. They might require hand-tuning for the problem at hand.</p> <p>For developers: if the prior is a <code>BoxUniform</code>, we carry out the optimization in unbounded space and transform the result back into bounded space.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Optional[Tensor]</code> <p>Deprecated - use <code>.set_default_x()</code> prior to <code>.map()</code>.</p> <code>None</code> <code>num_iter</code> <code>int</code> <p>Number of optimization steps that the algorithm takes to find the MAP.</p> <code>1000</code> <code>learning_rate</code> <code>float</code> <p>Learning rate of the optimizer.</p> <code>0.01</code> <code>init_method</code> <code>Union[str, Tensor]</code> <p>How to select the starting parameters for the optimization. If it is a string, it can be either [<code>posterior</code>, <code>prior</code>], which samples the respective distribution <code>num_init_samples</code> times. If it is a tensor, the tensor will be used as init locations.</p> <code>'proposal'</code> <code>num_init_samples</code> <code>int</code> <p>Draw this number of samples from the posterior and evaluate the log-probability of all of them.</p> <code>1000</code> <code>num_to_optimize</code> <code>int</code> <p>From the drawn <code>num_init_samples</code>, use the <code>num_to_optimize</code> with highest log-probability as the initial points for the optimization.</p> <code>100</code> <code>save_best_every</code> <code>int</code> <p>The best log-probability is computed, saved in the <code>map</code>-attribute, and printed every <code>save_best_every</code>-th iteration. Computing the best log-probability creates a significant overhead (thus, the default is <code>10</code>.)</p> <code>10</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during sampling from the posterior.</p> <code>False</code> <code>force_update</code> <code>bool</code> <p>Whether to re-calculate the MAP when x is unchanged and have a cached value.</p> <code>False</code> <code>log_prob_kwargs</code> <p>Will be empty for SNLE and SNRE. Will contain {\u2018norm_posterior\u2019: True} for SNPE.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The MAP estimate.</p> Source code in <code>sbi/inference/posteriors/mcmc_posterior.py</code> <pre><code>def map(\n    self,\n    x: Optional[Tensor] = None,\n    num_iter: int = 1_000,\n    num_to_optimize: int = 100,\n    learning_rate: float = 0.01,\n    init_method: Union[str, Tensor] = \"proposal\",\n    num_init_samples: int = 1_000,\n    save_best_every: int = 10,\n    show_progress_bars: bool = False,\n    force_update: bool = False,\n) -&gt; Tensor:\n    r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n    The method can be interrupted (Ctrl-C) when the user sees that the\n    log-probability converges. The best estimate will be saved in `self._map` and\n    can be accessed with `self.map()`. The MAP is obtained by running gradient\n    ascent from a given number of starting positions (samples from the posterior\n    with the highest log-probability). After the optimization is done, we select the\n    parameter set that has the highest log-probability after the optimization.\n\n    Warning: The default values used by this function are not well-tested. They\n    might require hand-tuning for the problem at hand.\n\n    For developers: if the prior is a `BoxUniform`, we carry out the optimization\n    in unbounded space and transform the result back into bounded space.\n\n    Args:\n        x: Deprecated - use `.set_default_x()` prior to `.map()`.\n        num_iter: Number of optimization steps that the algorithm takes\n            to find the MAP.\n        learning_rate: Learning rate of the optimizer.\n        init_method: How to select the starting parameters for the optimization. If\n            it is a string, it can be either [`posterior`, `prior`], which samples\n            the respective distribution `num_init_samples` times. If it is a\n            tensor, the tensor will be used as init locations.\n        num_init_samples: Draw this number of samples from the posterior and\n            evaluate the log-probability of all of them.\n        num_to_optimize: From the drawn `num_init_samples`, use the\n            `num_to_optimize` with highest log-probability as the initial points\n            for the optimization.\n        save_best_every: The best log-probability is computed, saved in the\n            `map`-attribute, and printed every `save_best_every`-th iteration.\n            Computing the best log-probability creates a significant overhead\n            (thus, the default is `10`.)\n        show_progress_bars: Whether to show a progressbar during sampling from\n            the posterior.\n        force_update: Whether to re-calculate the MAP when x is unchanged and\n            have a cached value.\n        log_prob_kwargs: Will be empty for SNLE and SNRE. Will contain\n            {'norm_posterior': True} for SNPE.\n\n    Returns:\n        The MAP estimate.\n    \"\"\"\n    return super().map(\n        x=x,\n        num_iter=num_iter,\n        num_to_optimize=num_to_optimize,\n        learning_rate=learning_rate,\n        init_method=init_method,\n        num_init_samples=num_init_samples,\n        save_best_every=save_best_every,\n        show_progress_bars=show_progress_bars,\n        force_update=force_update,\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.mcmc_posterior.MCMCPosterior.sample","title":"<code>sample(sample_shape=torch.Size(), x=None, method=None, thin=None, warmup_steps=None, num_chains=None, init_strategy=None, init_strategy_parameters=None, init_strategy_num_candidates=None, mcmc_parameters=None, mcmc_method=None, sample_with=None, num_workers=None, mp_context=None, show_progress_bars=True)</code>","text":"<p>Return samples from posterior distribution \\(p(\\theta|x)\\) with MCMC.</p> <p>Check the <code>__init__()</code> method for a description of all arguments as well as their default values.</p> <p>Parameters:</p> Name Type Description Default <code>sample_shape</code> <code>Shape</code> <p>Desired shape of samples that are drawn from posterior. If sample_shape is multidimensional we simply draw <code>sample_shape.numel()</code> samples and then reshape into the desired shape.</p> <code>Size()</code> <code>mcmc_parameters</code> <code>Optional[Dict]</code> <p>Dictionary that is passed only to support the API of <code>sbi</code> v0.17.2 or older.</p> <code>None</code> <code>mcmc_method</code> <code>Optional[str]</code> <p>This argument only exists to keep backward-compatibility with <code>sbi</code> v0.17.2 or older. Please use <code>method</code> instead.</p> <code>None</code> <code>sample_with</code> <code>Optional[str]</code> <p>This argument only exists to keep backward-compatibility with <code>sbi</code> v0.17.2 or older. If it is set, we instantly raise an error.</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show sampling progress monitor.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Samples from posterior.</p> Source code in <code>sbi/inference/posteriors/mcmc_posterior.py</code> <pre><code>def sample(\n    self,\n    sample_shape: Shape = torch.Size(),\n    x: Optional[Tensor] = None,\n    method: Optional[str] = None,\n    thin: Optional[int] = None,\n    warmup_steps: Optional[int] = None,\n    num_chains: Optional[int] = None,\n    init_strategy: Optional[str] = None,\n    init_strategy_parameters: Optional[Dict[str, Any]] = None,\n    init_strategy_num_candidates: Optional[int] = None,\n    mcmc_parameters: Optional[Dict] = None,\n    mcmc_method: Optional[str] = None,\n    sample_with: Optional[str] = None,\n    num_workers: Optional[int] = None,\n    mp_context: Optional[str] = None,\n    show_progress_bars: bool = True,\n) -&gt; Tensor:\n    r\"\"\"Return samples from posterior distribution $p(\\theta|x)$ with MCMC.\n\n    Check the `__init__()` method for a description of all arguments as well as\n    their default values.\n\n    Args:\n        sample_shape: Desired shape of samples that are drawn from posterior. If\n            sample_shape is multidimensional we simply draw `sample_shape.numel()`\n            samples and then reshape into the desired shape.\n        mcmc_parameters: Dictionary that is passed only to support the API of\n            `sbi` v0.17.2 or older.\n        mcmc_method: This argument only exists to keep backward-compatibility with\n            `sbi` v0.17.2 or older. Please use `method` instead.\n        sample_with: This argument only exists to keep backward-compatibility with\n            `sbi` v0.17.2 or older. If it is set, we instantly raise an error.\n        show_progress_bars: Whether to show sampling progress monitor.\n\n    Returns:\n        Samples from posterior.\n    \"\"\"\n\n    self.potential_fn.set_x(self._x_else_default_x(x))\n\n    # Replace arguments that were not passed with their default.\n    method = self.method if method is None else method\n    thin = self.thin if thin is None else thin\n    warmup_steps = self.warmup_steps if warmup_steps is None else warmup_steps\n    num_chains = self.num_chains if num_chains is None else num_chains\n    init_strategy = self.init_strategy if init_strategy is None else init_strategy\n    num_workers = self.num_workers if num_workers is None else num_workers\n    mp_context = self.mp_context if mp_context is None else mp_context\n    init_strategy_parameters = (\n        self.init_strategy_parameters\n        if init_strategy_parameters is None\n        else init_strategy_parameters\n    )\n    if init_strategy_num_candidates is not None:\n        warn(\n            \"Passing `init_strategy_num_candidates` is deprecated as of sbi \"\n            \"v0.19.0. Instead, use e.g., \"\n            f\"`init_strategy_parameters={'num_candidate_samples': 1000}`\",\n            stacklevel=2,\n        )\n        self.init_strategy_parameters[\"num_candidate_samples\"] = (\n            init_strategy_num_candidates\n        )\n    if sample_with is not None:\n        raise ValueError(\n            f\"You set `sample_with={sample_with}`. As of sbi v0.18.0, setting \"\n            \"`sample_with` is no longer supported. You have to rerun \"\n            f\"`.build_posterior(sample_with={sample_with}).`\"\n        )\n    if mcmc_method is not None:\n        warn(\n            \"You passed `mcmc_method` to `.sample()`. As of sbi v0.18.0, this \"\n            \"is deprecated and will be removed in a future release. Use `method` \"\n            \"instead of `mcmc_method`.\",\n            stacklevel=2,\n        )\n        method = mcmc_method\n    if mcmc_parameters:\n        warn(\n            \"You passed `mcmc_parameters` to `.sample()`. As of sbi v0.18.0, this \"\n            \"is deprecated and will be removed in a future release. Instead, pass \"\n            \"the variable to `.sample()` directly, e.g. \"\n            \"`posterior.sample((1,), num_chains=5)`.\",\n            stacklevel=2,\n        )\n    # The following lines are only for backwards compatibility with sbi v0.17.2 or\n    # older.\n    m_p = mcmc_parameters or {}  # define to shorten the variable name\n    method = _maybe_use_dict_entry(method, \"mcmc_method\", m_p)\n    thin = _maybe_use_dict_entry(thin, \"thin\", m_p)\n    warmup_steps = _maybe_use_dict_entry(warmup_steps, \"warmup_steps\", m_p)\n    num_chains = _maybe_use_dict_entry(num_chains, \"num_chains\", m_p)\n    init_strategy = _maybe_use_dict_entry(init_strategy, \"init_strategy\", m_p)\n    self.potential_ = self._prepare_potential(method)  # type: ignore\n\n    initial_params = self._get_initial_params(\n        init_strategy,  # type: ignore\n        num_chains,  # type: ignore\n        num_workers,\n        show_progress_bars,\n        **init_strategy_parameters,\n    )\n    num_samples = torch.Size(sample_shape).numel()\n\n    track_gradients = method in (\"hmc_pyro\", \"nuts_pyro\", \"hmc_pymc\", \"nuts_pymc\")\n    with torch.set_grad_enabled(track_gradients):\n        if method in (\"slice_np\", \"slice_np_vectorized\"):\n            transformed_samples = self._slice_np_mcmc(\n                num_samples=num_samples,\n                potential_function=self.potential_,\n                initial_params=initial_params,\n                thin=thin,  # type: ignore\n                warmup_steps=warmup_steps,  # type: ignore\n                vectorized=(method == \"slice_np_vectorized\"),\n                interchangeable_chains=True,\n                num_workers=num_workers,\n                show_progress_bars=show_progress_bars,\n            )\n        elif method in (\"hmc_pyro\", \"nuts_pyro\"):\n            transformed_samples = self._pyro_mcmc(\n                num_samples=num_samples,\n                potential_function=self.potential_,\n                initial_params=initial_params,\n                mcmc_method=method,  # type: ignore\n                thin=thin,  # type: ignore\n                warmup_steps=warmup_steps,  # type: ignore\n                num_chains=num_chains,\n                show_progress_bars=show_progress_bars,\n                mp_context=mp_context,\n            )\n        elif method in (\"hmc_pymc\", \"nuts_pymc\", \"slice_pymc\"):\n            transformed_samples = self._pymc_mcmc(\n                num_samples=num_samples,\n                potential_function=self.potential_,\n                initial_params=initial_params,\n                mcmc_method=method,  # type: ignore\n                thin=thin,  # type: ignore\n                warmup_steps=warmup_steps,  # type: ignore\n                num_chains=num_chains,\n                show_progress_bars=show_progress_bars,\n                mp_context=mp_context,\n            )\n        else:\n            raise NameError(f\"The sampling method {method} is not implemented!\")\n\n    samples = self.theta_transform.inv(transformed_samples)\n    # NOTE: Currently MCMCPosteriors will require a single dimension for the\n    # parameter dimension. With recent ConditionalDensity(Ratio) estimators, we\n    # can have multiple dimensions for the parameter dimension.\n    samples = samples.reshape((*sample_shape, -1))  # type: ignore\n\n    return samples\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.mcmc_posterior.MCMCPosterior.sample_batched","title":"<code>sample_batched(sample_shape, x, method=None, thin=None, warmup_steps=None, num_chains=None, init_strategy=None, init_strategy_parameters=None, num_workers=None, mp_context=None, show_progress_bars=True)</code>","text":"<p>Given a batch of observations [x_1, \u2026, x_B] this function samples from posteriors \\(p(\\theta|x_1)\\), \u2026 ,\\(p(\\theta|x_B)\\), in a batched (i.e. vectorized) manner.</p> <p>Check the <code>__init__()</code> method for a description of all arguments as well as their default values.</p> <p>Parameters:</p> Name Type Description Default <code>sample_shape</code> <code>Shape</code> <p>Desired shape of samples that are drawn from the posterior given every observation.</p> required <code>x</code> <code>Tensor</code> <p>A batch of observations, of shape <code>(batch_dim, event_shape_x)</code>. <code>batch_dim</code> corresponds to the number of observations to be drawn.</p> required <code>method</code> <code>Optional[str]</code> <p>Method used for MCMC sampling, e.g., \u201cslice_np_vectorized\u201d.</p> <code>None</code> <code>thin</code> <code>Optional[int]</code> <p>The thinning factor for the chain, default 1 (no thinning).</p> <code>None</code> <code>warmup_steps</code> <code>Optional[int]</code> <p>The initial number of samples to discard.</p> <code>None</code> <code>num_chains</code> <code>Optional[int]</code> <p>The number of chains used for each <code>x</code> passed in the batch.</p> <code>None</code> <code>init_strategy</code> <code>Optional[str]</code> <p>The initialisation strategy for chains.</p> <code>None</code> <code>init_strategy_parameters</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary of keyword arguments passed to the init strategy.</p> <code>None</code> <code>num_workers</code> <code>Optional[int]</code> <p>number of cpu cores used to parallelize initial parameter generation and mcmc sampling.</p> <code>None</code> <code>mp_context</code> <code>Optional[str]</code> <p>Multiprocessing start method, either <code>\"fork\"</code> or <code>\"spawn\"</code></p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show sampling progress monitor.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Samples from the posteriors of shape (*sample_shape, B, *input_shape)</p> Source code in <code>sbi/inference/posteriors/mcmc_posterior.py</code> <pre><code>def sample_batched(\n    self,\n    sample_shape: Shape,\n    x: Tensor,\n    method: Optional[str] = None,\n    thin: Optional[int] = None,\n    warmup_steps: Optional[int] = None,\n    num_chains: Optional[int] = None,\n    init_strategy: Optional[str] = None,\n    init_strategy_parameters: Optional[Dict[str, Any]] = None,\n    num_workers: Optional[int] = None,\n    mp_context: Optional[str] = None,\n    show_progress_bars: bool = True,\n) -&gt; Tensor:\n    r\"\"\"Given a batch of observations [x_1, ..., x_B] this function samples from\n    posteriors $p(\\theta|x_1)$, ... ,$p(\\theta|x_B)$, in a batched (i.e. vectorized)\n    manner.\n\n    Check the `__init__()` method for a description of all arguments as well as\n    their default values.\n\n    Args:\n        sample_shape: Desired shape of samples that are drawn from the posterior\n            given every observation.\n        x: A batch of observations, of shape `(batch_dim, event_shape_x)`.\n            `batch_dim` corresponds to the number of observations to be\n            drawn.\n        method: Method used for MCMC sampling, e.g., \"slice_np_vectorized\".\n        thin: The thinning factor for the chain, default 1 (no thinning).\n        warmup_steps: The initial number of samples to discard.\n        num_chains: The number of chains used for each `x` passed in the batch.\n        init_strategy: The initialisation strategy for chains.\n        init_strategy_parameters: Dictionary of keyword arguments passed to\n            the init strategy.\n        num_workers: number of cpu cores used to parallelize initial\n            parameter generation and mcmc sampling.\n        mp_context: Multiprocessing start method, either `\"fork\"` or `\"spawn\"`\n        show_progress_bars: Whether to show sampling progress monitor.\n\n    Returns:\n        Samples from the posteriors of shape (*sample_shape, B, *input_shape)\n    \"\"\"\n\n    # Replace arguments that were not passed with their default.\n    method = self.method if method is None else method\n    thin = self.thin if thin is None else thin\n    warmup_steps = self.warmup_steps if warmup_steps is None else warmup_steps\n    num_chains = self.num_chains if num_chains is None else num_chains\n    init_strategy = self.init_strategy if init_strategy is None else init_strategy\n    num_workers = self.num_workers if num_workers is None else num_workers\n    mp_context = self.mp_context if mp_context is None else mp_context\n    init_strategy_parameters = (\n        self.init_strategy_parameters\n        if init_strategy_parameters is None\n        else init_strategy_parameters\n    )\n\n    assert (\n        method == \"slice_np_vectorized\"\n    ), \"Batched sampling only supported for vectorized samplers!\"\n\n    # warn if num_chains is larger than num requested samples\n    if num_chains &gt; torch.Size(sample_shape).numel():\n        warnings.warn(\n            \"The passed number of MCMC chains is larger than the number of \"\n            f\"requested samples: {num_chains} &gt; {torch.Size(sample_shape).numel()},\"\n            f\" resetting it to {torch.Size(sample_shape).numel()}.\",\n            stacklevel=2,\n        )\n        num_chains = torch.Size(sample_shape).numel()\n\n    # custom shape handling to make sure to match the batch size of x and theta\n    # without unnecessary combinations.\n    if len(x.shape) == 1:\n        x = x.unsqueeze(0)\n    batch_size = x.shape[0]\n\n    x = reshape_to_batch_event(x, event_shape=x.shape[1:])\n\n    # For batched sampling, we want `num_chains` for each observation in the batch.\n    # Here we repeat the observations ABC -&gt; AAABBBCCC, so that the chains are\n    # in the order of the observations.\n    x_ = x.repeat_interleave(num_chains, dim=0)\n\n    self.potential_fn.set_x(x_, x_is_iid=False)\n    self.potential_ = self._prepare_potential(method)  # type: ignore\n\n    # For each observation in the batch, we have num_chains independent chains.\n    num_chains_extended = batch_size * num_chains\n    if num_chains_extended &gt; 100:\n        warnings.warn(\n            \"Note that for batched sampling, we use num_chains many chains for each\"\n            \" x in the batch. With the given settings, this results in a large \"\n            f\"number large number of chains ({num_chains_extended}), which can be \"\n            \"slow and memory-intensive for vectorized MCMC. Consider reducing the \"\n            \"number of chains.\",\n            stacklevel=2,\n        )\n    init_strategy_parameters[\"num_return_samples\"] = num_chains_extended\n    initial_params = self._get_initial_params_batched(\n        x,\n        init_strategy,  # type: ignore\n        num_chains,  # type: ignore\n        num_workers,\n        show_progress_bars,\n        **init_strategy_parameters,\n    )\n    # We need num_samples from each posterior in the batch\n    num_samples = torch.Size(sample_shape).numel() * batch_size\n\n    with torch.set_grad_enabled(False):\n        transformed_samples = self._slice_np_mcmc(\n            num_samples=num_samples,\n            potential_function=self.potential_,\n            initial_params=initial_params,\n            thin=thin,  # type: ignore\n            warmup_steps=warmup_steps,  # type: ignore\n            vectorized=(method == \"slice_np_vectorized\"),\n            interchangeable_chains=False,\n            num_workers=num_workers,\n            show_progress_bars=show_progress_bars,\n        )\n\n    # (num_chains_extended, samples_per_chain, *input_shape)\n    samples_per_chain: Tensor = self.theta_transform.inv(transformed_samples)  # type: ignore\n    dim_theta = samples_per_chain.shape[-1]\n    # We need to collect samples for each x from the respective chains.\n    # However, using samples.reshape(*sample_shape, batch_size, dim_theta)\n    # does not combine the samples in the right order, since this mixes\n    # samples that belong to different `x`. The following permute is a\n    # workaround to reshape the samples in the right order.\n    samples_per_x = samples_per_chain.reshape((\n        batch_size,\n        # We are flattening the sample shape here using -1 because we might have\n        # generated more samples than requested (more chains, or multiple of\n        # chains not matching sample_shape)\n        -1,\n        dim_theta,\n    )).permute(1, 0, -1)\n\n    # Shape is now (-1, batch_size, dim_theta)\n    # We can now select the number of requested samples\n    samples = samples_per_x[: torch.Size(sample_shape).numel()]\n    # and reshape into (*sample_shape, batch_size, dim_theta)\n    samples = samples.reshape((*sample_shape, batch_size, dim_theta))\n    return samples\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.mcmc_posterior.MCMCPosterior.set_mcmc_method","title":"<code>set_mcmc_method(method)</code>","text":"<p>Sets sampling method to for MCMC and returns <code>NeuralPosterior</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Method to use.</p> required <p>Returns:</p> Type Description <code>NeuralPosterior</code> <p><code>NeuralPosterior</code> for chainable calls.</p> Source code in <code>sbi/inference/posteriors/mcmc_posterior.py</code> <pre><code>def set_mcmc_method(self, method: str) -&gt; \"NeuralPosterior\":\n    \"\"\"Sets sampling method to for MCMC and returns `NeuralPosterior`.\n\n    Args:\n        method: Method to use.\n\n    Returns:\n        `NeuralPosterior` for chainable calls.\n    \"\"\"\n    self._mcmc_method = method\n    return self\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.rejection_posterior.RejectionPosterior","title":"<code>RejectionPosterior</code>","text":"<p>               Bases: <code>NeuralPosterior</code></p> <p>Provides rejection sampling to sample from the posterior. SNLE or SNRE train neural networks to approximate the likelihood(-ratios). <code>RejectionPosterior</code> allows to sample from the posterior with rejection sampling.</p> Source code in <code>sbi/inference/posteriors/rejection_posterior.py</code> <pre><code>class RejectionPosterior(NeuralPosterior):\n    r\"\"\"Provides rejection sampling to sample from the posterior.&lt;br/&gt;&lt;br/&gt;\n    SNLE or SNRE train neural networks to approximate the likelihood(-ratios).\n    `RejectionPosterior` allows to sample from the posterior with rejection sampling.\n    \"\"\"\n\n    def __init__(\n        self,\n        potential_fn: Union[Callable, BasePotential],\n        proposal: Any,\n        theta_transform: Optional[TorchTransform] = None,\n        max_sampling_batch_size: int = 10_000,\n        num_samples_to_find_max: int = 10_000,\n        num_iter_to_find_max: int = 100,\n        m: float = 1.2,\n        device: Optional[str] = None,\n        x_shape: Optional[torch.Size] = None,\n    ):\n        \"\"\"\n        Args:\n            potential_fn: The potential function from which to draw samples. Must be a\n                `BasePotential` or a `Callable` which takes `theta` and `x_o` as inputs.\n            proposal: The proposal distribution.\n            theta_transform: Transformation that is applied to parameters. Is not used\n                during but only when calling `.map()`.\n            max_sampling_batch_size: The batchsize of samples being drawn from\n                the proposal at every iteration.\n            num_samples_to_find_max: The number of samples that are used to find the\n                maximum of the `potential_fn / proposal` ratio.\n            num_iter_to_find_max: The number of gradient ascent iterations to find the\n                maximum of the `potential_fn / proposal` ratio.\n            m: Multiplier to the `potential_fn / proposal` ratio.\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:0\". If None,\n                `potential_fn.device` is used.\n            x_shape: Deprecated, should not be passed.\n        \"\"\"\n        super().__init__(\n            potential_fn,\n            theta_transform=theta_transform,\n            device=device,\n            x_shape=x_shape,\n        )\n\n        self.proposal = proposal\n        self.max_sampling_batch_size = max_sampling_batch_size\n        self.num_samples_to_find_max = num_samples_to_find_max\n        self.num_iter_to_find_max = num_iter_to_find_max\n        self.m = m\n\n        self._purpose = (\n            \"It provides rejection sampling to .sample() from the posterior and \"\n            \"can evaluate the _unnormalized_ posterior density with .log_prob().\"\n        )\n\n    def log_prob(\n        self, theta: Tensor, x: Optional[Tensor] = None, track_gradients: bool = False\n    ) -&gt; Tensor:\n        r\"\"\"Returns the log-probability of theta under the posterior.\n\n        Args:\n            theta: Parameters $\\theta$.\n            track_gradients: Whether the returned tensor supports tracking gradients.\n                This can be helpful for e.g. sensitivity analysis, but increases memory\n                consumption.\n\n        Returns:\n            `len($\\theta$)`-shaped log-probability.\n        \"\"\"\n        warn(\n            \"`.log_prob()` is deprecated for methods that can only evaluate the \"\n            \"log-probability up to a normalizing constant. Use `.potential()` instead.\",\n            stacklevel=2,\n        )\n        warn(\"The log-probability is unnormalized!\", stacklevel=2)\n\n        self.potential_fn.set_x(self._x_else_default_x(x))\n\n        theta = ensure_theta_batched(torch.as_tensor(theta))\n        return self.potential_fn(\n            theta.to(self._device), track_gradients=track_gradients\n        )\n\n    def sample(\n        self,\n        sample_shape: Shape = torch.Size(),\n        x: Optional[Tensor] = None,\n        max_sampling_batch_size: Optional[int] = None,\n        num_samples_to_find_max: Optional[int] = None,\n        num_iter_to_find_max: Optional[int] = None,\n        m: Optional[float] = None,\n        sample_with: Optional[str] = None,\n        show_progress_bars: bool = True,\n    ):\n        r\"\"\"Return samples from posterior $p(\\theta|x)$ via rejection sampling.\n\n        Args:\n            sample_shape: Desired shape of samples that are drawn from posterior. If\n                sample_shape is multidimensional we simply draw `sample_shape.numel()`\n                samples and then reshape into the desired shape.\n            sample_with: This argument only exists to keep backward-compatibility with\n                `sbi` v0.17.2 or older. If it is set, we instantly raise an error.\n            show_progress_bars: Whether to show sampling progress monitor.\n\n        Returns:\n            Samples from posterior.\n        \"\"\"\n        num_samples = torch.Size(sample_shape).numel()\n        self.potential_fn.set_x(self._x_else_default_x(x))\n\n        potential = partial(self.potential_fn, track_gradients=True)\n\n        if sample_with is not None:\n            raise ValueError(\n                f\"You set `sample_with={sample_with}`. As of sbi v0.18.0, setting \"\n                f\"`sample_with` is no longer supported. You have to rerun \"\n                f\"`.build_posterior(sample_with={sample_with}).`\"\n            )\n        # Replace arguments that were not passed with their default.\n        max_sampling_batch_size = (\n            self.max_sampling_batch_size\n            if max_sampling_batch_size is None\n            else max_sampling_batch_size\n        )\n        num_samples_to_find_max = (\n            self.num_samples_to_find_max\n            if num_samples_to_find_max is None\n            else num_samples_to_find_max\n        )\n        num_iter_to_find_max = (\n            self.num_iter_to_find_max\n            if num_iter_to_find_max is None\n            else num_iter_to_find_max\n        )\n        m = self.m if m is None else m\n\n        samples, _ = rejection_sample(\n            potential,\n            proposal=self.proposal,\n            num_samples=num_samples,\n            show_progress_bars=show_progress_bars,\n            warn_acceptance=0.01,\n            max_sampling_batch_size=max_sampling_batch_size,\n            num_samples_to_find_max=num_samples_to_find_max,\n            num_iter_to_find_max=num_iter_to_find_max,\n            m=m,\n            device=self._device,\n        )\n\n        return samples.reshape((*sample_shape, -1))\n\n    def sample_batched(\n        self,\n        sample_shape: Shape,\n        x: Tensor,\n        max_sampling_batch_size: int = 10000,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        raise NotImplementedError(\n            \"Batched sampling is not implemented for RejectionPosterior. \\\n            Alternatively you can use `sample` in a loop \\\n            [posterior.sample(theta, x_o) for x_o in x].\"\n        )\n\n    def map(\n        self,\n        x: Optional[Tensor] = None,\n        num_iter: int = 1_000,\n        num_to_optimize: int = 100,\n        learning_rate: float = 0.01,\n        init_method: Union[str, Tensor] = \"proposal\",\n        num_init_samples: int = 1_000,\n        save_best_every: int = 10,\n        show_progress_bars: bool = False,\n        force_update: bool = False,\n    ) -&gt; Tensor:\n        r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n        The method can be interrupted (Ctrl-C) when the user sees that the\n        log-probability converges. The best estimate will be saved in `self._map` and\n        can be accessed with `self.map()`. The MAP is obtained by running gradient\n        ascent from a given number of starting positions (samples from the posterior\n        with the highest log-probability). After the optimization is done, we select the\n        parameter set that has the highest log-probability after the optimization.\n\n        Warning: The default values used by this function are not well-tested. They\n        might require hand-tuning for the problem at hand.\n\n        For developers: if the prior is a `BoxUniform`, we carry out the optimization\n        in unbounded space and transform the result back into bounded space.\n\n        Args:\n            x: Deprecated - use `.set_default_x()` prior to `.map()`.\n            num_iter: Number of optimization steps that the algorithm takes\n                to find the MAP.\n            learning_rate: Learning rate of the optimizer.\n            init_method: How to select the starting parameters for the optimization. If\n                it is a string, it can be either [`posterior`, `prior`], which samples\n                the respective distribution `num_init_samples` times. If it is a\n                tensor, the tensor will be used as init locations.\n            num_init_samples: Draw this number of samples from the posterior and\n                evaluate the log-probability of all of them.\n            num_to_optimize: From the drawn `num_init_samples`, use the\n                `num_to_optimize` with highest log-probability as the initial points\n                for the optimization.\n            save_best_every: The best log-probability is computed, saved in the\n                `map`-attribute, and printed every `save_best_every`-th iteration.\n                Computing the best log-probability creates a significant overhead\n                (thus, the default is `10`.)\n            show_progress_bars: Whether to show a progressbar during sampling from\n                the posterior.\n            force_update: Whether to re-calculate the MAP when x is unchanged and\n                have a cached value.\n            log_prob_kwargs: Will be empty for SNLE and SNRE. Will contain\n                {'norm_posterior': True} for SNPE.\n\n        Returns:\n            The MAP estimate.\n        \"\"\"\n        return super().map(\n            x=x,\n            num_iter=num_iter,\n            num_to_optimize=num_to_optimize,\n            learning_rate=learning_rate,\n            init_method=init_method,\n            num_init_samples=num_init_samples,\n            save_best_every=save_best_every,\n            show_progress_bars=show_progress_bars,\n            force_update=force_update,\n        )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.rejection_posterior.RejectionPosterior.__init__","title":"<code>__init__(potential_fn, proposal, theta_transform=None, max_sampling_batch_size=10000, num_samples_to_find_max=10000, num_iter_to_find_max=100, m=1.2, device=None, x_shape=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>potential_fn</code> <code>Union[Callable, BasePotential]</code> <p>The potential function from which to draw samples. Must be a <code>BasePotential</code> or a <code>Callable</code> which takes <code>theta</code> and <code>x_o</code> as inputs.</p> required <code>proposal</code> <code>Any</code> <p>The proposal distribution.</p> required <code>theta_transform</code> <code>Optional[TorchTransform]</code> <p>Transformation that is applied to parameters. Is not used during but only when calling <code>.map()</code>.</p> <code>None</code> <code>max_sampling_batch_size</code> <code>int</code> <p>The batchsize of samples being drawn from the proposal at every iteration.</p> <code>10000</code> <code>num_samples_to_find_max</code> <code>int</code> <p>The number of samples that are used to find the maximum of the <code>potential_fn / proposal</code> ratio.</p> <code>10000</code> <code>num_iter_to_find_max</code> <code>int</code> <p>The number of gradient ascent iterations to find the maximum of the <code>potential_fn / proposal</code> ratio.</p> <code>100</code> <code>m</code> <code>float</code> <p>Multiplier to the <code>potential_fn / proposal</code> ratio.</p> <code>1.2</code> <code>device</code> <code>Optional[str]</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:0\u201d. If None, <code>potential_fn.device</code> is used.</p> <code>None</code> <code>x_shape</code> <code>Optional[Size]</code> <p>Deprecated, should not be passed.</p> <code>None</code> Source code in <code>sbi/inference/posteriors/rejection_posterior.py</code> <pre><code>def __init__(\n    self,\n    potential_fn: Union[Callable, BasePotential],\n    proposal: Any,\n    theta_transform: Optional[TorchTransform] = None,\n    max_sampling_batch_size: int = 10_000,\n    num_samples_to_find_max: int = 10_000,\n    num_iter_to_find_max: int = 100,\n    m: float = 1.2,\n    device: Optional[str] = None,\n    x_shape: Optional[torch.Size] = None,\n):\n    \"\"\"\n    Args:\n        potential_fn: The potential function from which to draw samples. Must be a\n            `BasePotential` or a `Callable` which takes `theta` and `x_o` as inputs.\n        proposal: The proposal distribution.\n        theta_transform: Transformation that is applied to parameters. Is not used\n            during but only when calling `.map()`.\n        max_sampling_batch_size: The batchsize of samples being drawn from\n            the proposal at every iteration.\n        num_samples_to_find_max: The number of samples that are used to find the\n            maximum of the `potential_fn / proposal` ratio.\n        num_iter_to_find_max: The number of gradient ascent iterations to find the\n            maximum of the `potential_fn / proposal` ratio.\n        m: Multiplier to the `potential_fn / proposal` ratio.\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:0\". If None,\n            `potential_fn.device` is used.\n        x_shape: Deprecated, should not be passed.\n    \"\"\"\n    super().__init__(\n        potential_fn,\n        theta_transform=theta_transform,\n        device=device,\n        x_shape=x_shape,\n    )\n\n    self.proposal = proposal\n    self.max_sampling_batch_size = max_sampling_batch_size\n    self.num_samples_to_find_max = num_samples_to_find_max\n    self.num_iter_to_find_max = num_iter_to_find_max\n    self.m = m\n\n    self._purpose = (\n        \"It provides rejection sampling to .sample() from the posterior and \"\n        \"can evaluate the _unnormalized_ posterior density with .log_prob().\"\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.rejection_posterior.RejectionPosterior.log_prob","title":"<code>log_prob(theta, x=None, track_gradients=False)</code>","text":"<p>Returns the log-probability of theta under the posterior.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Tensor</code> <p>Parameters \\(\\theta\\).</p> required <code>track_gradients</code> <code>bool</code> <p>Whether the returned tensor supports tracking gradients. This can be helpful for e.g. sensitivity analysis, but increases memory consumption.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tensor</code> <p><code>len($\\theta$)</code>-shaped log-probability.</p> Source code in <code>sbi/inference/posteriors/rejection_posterior.py</code> <pre><code>def log_prob(\n    self, theta: Tensor, x: Optional[Tensor] = None, track_gradients: bool = False\n) -&gt; Tensor:\n    r\"\"\"Returns the log-probability of theta under the posterior.\n\n    Args:\n        theta: Parameters $\\theta$.\n        track_gradients: Whether the returned tensor supports tracking gradients.\n            This can be helpful for e.g. sensitivity analysis, but increases memory\n            consumption.\n\n    Returns:\n        `len($\\theta$)`-shaped log-probability.\n    \"\"\"\n    warn(\n        \"`.log_prob()` is deprecated for methods that can only evaluate the \"\n        \"log-probability up to a normalizing constant. Use `.potential()` instead.\",\n        stacklevel=2,\n    )\n    warn(\"The log-probability is unnormalized!\", stacklevel=2)\n\n    self.potential_fn.set_x(self._x_else_default_x(x))\n\n    theta = ensure_theta_batched(torch.as_tensor(theta))\n    return self.potential_fn(\n        theta.to(self._device), track_gradients=track_gradients\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.rejection_posterior.RejectionPosterior.map","title":"<code>map(x=None, num_iter=1000, num_to_optimize=100, learning_rate=0.01, init_method='proposal', num_init_samples=1000, save_best_every=10, show_progress_bars=False, force_update=False)</code>","text":"<p>Returns the maximum-a-posteriori estimate (MAP).</p> <p>The method can be interrupted (Ctrl-C) when the user sees that the log-probability converges. The best estimate will be saved in <code>self._map</code> and can be accessed with <code>self.map()</code>. The MAP is obtained by running gradient ascent from a given number of starting positions (samples from the posterior with the highest log-probability). After the optimization is done, we select the parameter set that has the highest log-probability after the optimization.</p> <p>Warning: The default values used by this function are not well-tested. They might require hand-tuning for the problem at hand.</p> <p>For developers: if the prior is a <code>BoxUniform</code>, we carry out the optimization in unbounded space and transform the result back into bounded space.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Optional[Tensor]</code> <p>Deprecated - use <code>.set_default_x()</code> prior to <code>.map()</code>.</p> <code>None</code> <code>num_iter</code> <code>int</code> <p>Number of optimization steps that the algorithm takes to find the MAP.</p> <code>1000</code> <code>learning_rate</code> <code>float</code> <p>Learning rate of the optimizer.</p> <code>0.01</code> <code>init_method</code> <code>Union[str, Tensor]</code> <p>How to select the starting parameters for the optimization. If it is a string, it can be either [<code>posterior</code>, <code>prior</code>], which samples the respective distribution <code>num_init_samples</code> times. If it is a tensor, the tensor will be used as init locations.</p> <code>'proposal'</code> <code>num_init_samples</code> <code>int</code> <p>Draw this number of samples from the posterior and evaluate the log-probability of all of them.</p> <code>1000</code> <code>num_to_optimize</code> <code>int</code> <p>From the drawn <code>num_init_samples</code>, use the <code>num_to_optimize</code> with highest log-probability as the initial points for the optimization.</p> <code>100</code> <code>save_best_every</code> <code>int</code> <p>The best log-probability is computed, saved in the <code>map</code>-attribute, and printed every <code>save_best_every</code>-th iteration. Computing the best log-probability creates a significant overhead (thus, the default is <code>10</code>.)</p> <code>10</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during sampling from the posterior.</p> <code>False</code> <code>force_update</code> <code>bool</code> <p>Whether to re-calculate the MAP when x is unchanged and have a cached value.</p> <code>False</code> <code>log_prob_kwargs</code> <p>Will be empty for SNLE and SNRE. Will contain {\u2018norm_posterior\u2019: True} for SNPE.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The MAP estimate.</p> Source code in <code>sbi/inference/posteriors/rejection_posterior.py</code> <pre><code>def map(\n    self,\n    x: Optional[Tensor] = None,\n    num_iter: int = 1_000,\n    num_to_optimize: int = 100,\n    learning_rate: float = 0.01,\n    init_method: Union[str, Tensor] = \"proposal\",\n    num_init_samples: int = 1_000,\n    save_best_every: int = 10,\n    show_progress_bars: bool = False,\n    force_update: bool = False,\n) -&gt; Tensor:\n    r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n    The method can be interrupted (Ctrl-C) when the user sees that the\n    log-probability converges. The best estimate will be saved in `self._map` and\n    can be accessed with `self.map()`. The MAP is obtained by running gradient\n    ascent from a given number of starting positions (samples from the posterior\n    with the highest log-probability). After the optimization is done, we select the\n    parameter set that has the highest log-probability after the optimization.\n\n    Warning: The default values used by this function are not well-tested. They\n    might require hand-tuning for the problem at hand.\n\n    For developers: if the prior is a `BoxUniform`, we carry out the optimization\n    in unbounded space and transform the result back into bounded space.\n\n    Args:\n        x: Deprecated - use `.set_default_x()` prior to `.map()`.\n        num_iter: Number of optimization steps that the algorithm takes\n            to find the MAP.\n        learning_rate: Learning rate of the optimizer.\n        init_method: How to select the starting parameters for the optimization. If\n            it is a string, it can be either [`posterior`, `prior`], which samples\n            the respective distribution `num_init_samples` times. If it is a\n            tensor, the tensor will be used as init locations.\n        num_init_samples: Draw this number of samples from the posterior and\n            evaluate the log-probability of all of them.\n        num_to_optimize: From the drawn `num_init_samples`, use the\n            `num_to_optimize` with highest log-probability as the initial points\n            for the optimization.\n        save_best_every: The best log-probability is computed, saved in the\n            `map`-attribute, and printed every `save_best_every`-th iteration.\n            Computing the best log-probability creates a significant overhead\n            (thus, the default is `10`.)\n        show_progress_bars: Whether to show a progressbar during sampling from\n            the posterior.\n        force_update: Whether to re-calculate the MAP when x is unchanged and\n            have a cached value.\n        log_prob_kwargs: Will be empty for SNLE and SNRE. Will contain\n            {'norm_posterior': True} for SNPE.\n\n    Returns:\n        The MAP estimate.\n    \"\"\"\n    return super().map(\n        x=x,\n        num_iter=num_iter,\n        num_to_optimize=num_to_optimize,\n        learning_rate=learning_rate,\n        init_method=init_method,\n        num_init_samples=num_init_samples,\n        save_best_every=save_best_every,\n        show_progress_bars=show_progress_bars,\n        force_update=force_update,\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.rejection_posterior.RejectionPosterior.sample","title":"<code>sample(sample_shape=torch.Size(), x=None, max_sampling_batch_size=None, num_samples_to_find_max=None, num_iter_to_find_max=None, m=None, sample_with=None, show_progress_bars=True)</code>","text":"<p>Return samples from posterior \\(p(\\theta|x)\\) via rejection sampling.</p> <p>Parameters:</p> Name Type Description Default <code>sample_shape</code> <code>Shape</code> <p>Desired shape of samples that are drawn from posterior. If sample_shape is multidimensional we simply draw <code>sample_shape.numel()</code> samples and then reshape into the desired shape.</p> <code>Size()</code> <code>sample_with</code> <code>Optional[str]</code> <p>This argument only exists to keep backward-compatibility with <code>sbi</code> v0.17.2 or older. If it is set, we instantly raise an error.</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show sampling progress monitor.</p> <code>True</code> <p>Returns:</p> Type Description <p>Samples from posterior.</p> Source code in <code>sbi/inference/posteriors/rejection_posterior.py</code> <pre><code>def sample(\n    self,\n    sample_shape: Shape = torch.Size(),\n    x: Optional[Tensor] = None,\n    max_sampling_batch_size: Optional[int] = None,\n    num_samples_to_find_max: Optional[int] = None,\n    num_iter_to_find_max: Optional[int] = None,\n    m: Optional[float] = None,\n    sample_with: Optional[str] = None,\n    show_progress_bars: bool = True,\n):\n    r\"\"\"Return samples from posterior $p(\\theta|x)$ via rejection sampling.\n\n    Args:\n        sample_shape: Desired shape of samples that are drawn from posterior. If\n            sample_shape is multidimensional we simply draw `sample_shape.numel()`\n            samples and then reshape into the desired shape.\n        sample_with: This argument only exists to keep backward-compatibility with\n            `sbi` v0.17.2 or older. If it is set, we instantly raise an error.\n        show_progress_bars: Whether to show sampling progress monitor.\n\n    Returns:\n        Samples from posterior.\n    \"\"\"\n    num_samples = torch.Size(sample_shape).numel()\n    self.potential_fn.set_x(self._x_else_default_x(x))\n\n    potential = partial(self.potential_fn, track_gradients=True)\n\n    if sample_with is not None:\n        raise ValueError(\n            f\"You set `sample_with={sample_with}`. As of sbi v0.18.0, setting \"\n            f\"`sample_with` is no longer supported. You have to rerun \"\n            f\"`.build_posterior(sample_with={sample_with}).`\"\n        )\n    # Replace arguments that were not passed with their default.\n    max_sampling_batch_size = (\n        self.max_sampling_batch_size\n        if max_sampling_batch_size is None\n        else max_sampling_batch_size\n    )\n    num_samples_to_find_max = (\n        self.num_samples_to_find_max\n        if num_samples_to_find_max is None\n        else num_samples_to_find_max\n    )\n    num_iter_to_find_max = (\n        self.num_iter_to_find_max\n        if num_iter_to_find_max is None\n        else num_iter_to_find_max\n    )\n    m = self.m if m is None else m\n\n    samples, _ = rejection_sample(\n        potential,\n        proposal=self.proposal,\n        num_samples=num_samples,\n        show_progress_bars=show_progress_bars,\n        warn_acceptance=0.01,\n        max_sampling_batch_size=max_sampling_batch_size,\n        num_samples_to_find_max=num_samples_to_find_max,\n        num_iter_to_find_max=num_iter_to_find_max,\n        m=m,\n        device=self._device,\n    )\n\n    return samples.reshape((*sample_shape, -1))\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.score_posterior.ScorePosterior","title":"<code>ScorePosterior</code>","text":"<p>               Bases: <code>NeuralPosterior</code></p> <p>Posterior \\(p(\\theta|x_o)\\) with <code>log_prob()</code> and <code>sample()</code> methods. It samples from the diffusion model given the score_estimator and rejects samples that lie outside of the prior bounds.</p> <p>The posterior is defined by a score estimator and a prior. The score estimator provides the gradient of the log-posterior with respect to the parameters. The prior is used to reject samples that lie outside of the prior bounds.</p> <p>Sampling is done by running a diffusion process with a predictor and optionally a corrector.</p> <p>Log probabilities are obtained by calling the potential function, which in turn uses zuko probabilistic ODEs to compute the log-probability.</p> Source code in <code>sbi/inference/posteriors/score_posterior.py</code> <pre><code>class ScorePosterior(NeuralPosterior):\n    r\"\"\"Posterior $p(\\theta|x_o)$ with `log_prob()` and `sample()` methods. It samples\n    from the diffusion model given the score_estimator and rejects samples that lie\n    outside of the prior bounds.\n\n    The posterior is defined by a score estimator and a prior. The score estimator\n    provides the gradient of the log-posterior with respect to the parameters. The prior\n    is used to reject samples that lie outside of the prior bounds.\n\n    Sampling is done by running a diffusion process with a predictor and optionally a\n    corrector.\n\n    Log probabilities are obtained by calling the potential function, which in turn uses\n    zuko probabilistic ODEs to compute the log-probability.\n    \"\"\"\n\n    def __init__(\n        self,\n        score_estimator: ConditionalScoreEstimator,\n        prior: Distribution,\n        max_sampling_batch_size: int = 10_000,\n        device: Optional[str] = None,\n        enable_transform: bool = False,\n        sample_with: str = \"sde\",\n    ):\n        \"\"\"\n        Args:\n            prior: Prior distribution with `.log_prob()` and `.sample()`.\n            score_estimator: The trained neural score estimator.\n            max_sampling_batch_size: Batchsize of samples being drawn from\n                the proposal at every iteration.\n            device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:0\". If None,\n                `potential_fn.device` is used.\n            enable_transform: Whether to transform parameters to unconstrained space\n                during MAP optimization. When False, an identity transform will be\n                returned for `theta_transform`. True is not supported yet.\n            sample_with: Whether to sample from the posterior using the ODE-based\n                sampler or the SDE-based sampler.\n        \"\"\"\n\n        check_prior(prior)\n        potential_fn, theta_transform = score_estimator_based_potential(\n            score_estimator,\n            prior,\n            x_o=None,\n            enable_transform=enable_transform,\n        )\n        super().__init__(\n            potential_fn=potential_fn,\n            theta_transform=theta_transform,\n            device=device,\n        )\n        # Set the potential function type.\n        self.potential_fn: PosteriorScoreBasedPotential = potential_fn\n\n        self.prior = prior\n        self.score_estimator = score_estimator\n\n        self.sample_with = sample_with\n        assert self.sample_with in [\n            \"ode\",\n            \"sde\",\n        ], f\"sample_with must be 'ode' or 'sde', but is {self.sample_with}.\"\n        self.max_sampling_batch_size = max_sampling_batch_size\n\n        self._purpose = \"\"\"It samples from the diffusion model given the \\\n            score_estimator.\"\"\"\n\n    def sample(\n        self,\n        sample_shape: Shape = torch.Size(),\n        x: Optional[Tensor] = None,\n        predictor: Union[str, Predictor] = \"euler_maruyama\",\n        corrector: Optional[Union[str, Corrector]] = None,\n        predictor_params: Optional[Dict] = None,\n        corrector_params: Optional[Dict] = None,\n        steps: int = 500,\n        ts: Optional[Tensor] = None,\n        max_sampling_batch_size: int = 10_000,\n        sample_with: Optional[str] = None,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        r\"\"\"Return samples from posterior distribution $p(\\theta|x)$.\n\n        Args:\n            sample_shape: Shape of the samples to be drawn.\n            x: Deprecated - use `.set_default_x()` prior to `.sample()`.\n            predictor: The predictor for the diffusion-based sampler. Can be a string or\n                a custom predictor following the API in `sbi.samplers.score.predictors`.\n                Currently, only `euler_maruyama` is implemented.\n            corrector: The corrector for the diffusion-based sampler. Either of\n                [None].\n            predictor_params: Additional parameters passed to predictor.\n            corrector_params: Additional parameters passed to corrector.\n            steps: Number of steps to take for the Euler-Maruyama method.\n            ts: Time points at which to evaluate the diffusion process. If None, a\n                linear grid between t_max and t_min is used.\n            max_sampling_batch_size: Maximum batch size for sampling.\n            sample_with: Deprecated - use `.build_posterior(sample_with=...)` prior to\n                `.sample()`.\n            show_progress_bars: Whether to show a progress bar during sampling.\n        \"\"\"\n\n        if sample_with is not None:\n            raise ValueError(\n                f\"You set `sample_with={sample_with}`. As of sbi v0.18.0, setting \"\n                f\"`sample_with` is no longer supported. You have to rerun \"\n                f\"`.build_posterior(sample_with={sample_with}).`\"\n            )\n\n        x = self._x_else_default_x(x)\n        x = reshape_to_batch_event(x, self.score_estimator.condition_shape)\n        self.potential_fn.set_x(x)\n\n        if self.sample_with == \"ode\":\n            samples = self.sample_via_zuko(sample_shape=sample_shape, x=x)\n        elif self.sample_with == \"sde\":\n            samples = self._sample_via_diffusion(\n                sample_shape=sample_shape,\n                predictor=predictor,\n                corrector=corrector,\n                predictor_params=predictor_params,\n                corrector_params=corrector_params,\n                steps=steps,\n                ts=ts,\n                max_sampling_batch_size=max_sampling_batch_size,\n                show_progress_bars=show_progress_bars,\n            )\n\n        return samples\n\n    def _sample_via_diffusion(\n        self,\n        sample_shape: Shape = torch.Size(),\n        predictor: Union[str, Predictor] = \"euler_maruyama\",\n        corrector: Optional[Union[str, Corrector]] = None,\n        predictor_params: Optional[Dict] = None,\n        corrector_params: Optional[Dict] = None,\n        steps: int = 500,\n        ts: Optional[Tensor] = None,\n        max_sampling_batch_size: int = 10_000,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        r\"\"\"Return samples from posterior distribution $p(\\theta|x)$.\n\n        Args:\n            sample_shape: Shape of the samples to be drawn.\n            x: Deprecated - use `.set_default_x()` prior to `.sample()`.\n            predictor: The predictor for the diffusion-based sampler. Can be a string or\n                a custom predictor following the API in `sbi.samplers.score.predictors`.\n                Currently, only `euler_maruyama` is implemented.\n            corrector: The corrector for the diffusion-based sampler. Either of\n                [None].\n            steps: Number of steps to take for the Euler-Maruyama method.\n            ts: Time points at which to evaluate the diffusion process. If None, a\n                linear grid between t_max and t_min is used.\n            max_sampling_batch_size: Maximum batch size for sampling.\n            sample_with: Deprecated - use `.build_posterior(sample_with=...)` prior to\n                `.sample()`.\n            show_progress_bars: Whether to show a progress bar during sampling.\n        \"\"\"\n\n        num_samples = torch.Size(sample_shape).numel()\n\n        max_sampling_batch_size = (\n            self.max_sampling_batch_size\n            if max_sampling_batch_size is None\n            else max_sampling_batch_size\n        )\n\n        if ts is None:\n            t_max = self.score_estimator.t_max\n            t_min = self.score_estimator.t_min\n            ts = torch.linspace(t_max, t_min, steps)\n\n        diffuser = Diffuser(\n            self.potential_fn,\n            predictor=predictor,\n            corrector=corrector,\n            predictor_params=predictor_params,\n            corrector_params=corrector_params,\n        )\n        max_sampling_batch_size = min(max_sampling_batch_size, num_samples)\n        samples = []\n        num_iter = num_samples // max_sampling_batch_size\n        num_iter = (\n            num_iter + 1 if (num_samples % max_sampling_batch_size) != 0 else num_iter\n        )\n        for _ in range(num_iter):\n            samples.append(\n                diffuser.run(\n                    num_samples=max_sampling_batch_size,\n                    ts=ts,\n                    show_progress_bars=show_progress_bars,\n                )\n            )\n        samples = torch.cat(samples, dim=0)[:num_samples]\n\n        return samples.reshape(sample_shape + self.score_estimator.input_shape)\n\n    def sample_via_zuko(\n        self,\n        x: Tensor,\n        sample_shape: Shape = torch.Size(),\n    ) -&gt; Tensor:\n        r\"\"\"Return samples from posterior distribution with probability flow ODE.\n\n        This build the probability flow ODE and then samples from the corresponding\n        flow. This is implemented via the zuko library.\n\n        Args:\n            x: Condition.\n            sample_shape: The shape of the samples to be returned.\n\n        Returns:\n            Samples.\n        \"\"\"\n        num_samples = torch.Size(sample_shape).numel()\n\n        flow = self.potential_fn.get_continuous_normalizing_flow(condition=x)\n        samples = flow.sample(torch.Size((num_samples,)))\n\n        return samples.reshape(sample_shape + self.score_estimator.input_shape)\n\n    def log_prob(\n        self,\n        theta: Tensor,\n        x: Optional[Tensor] = None,\n        track_gradients: bool = False,\n        atol: float = 1e-5,\n        rtol: float = 1e-6,\n        exact: bool = True,\n    ) -&gt; Tensor:\n        r\"\"\"Returns the log-probability of the posterior $p(\\theta|x)$.\n\n        This requires building and evaluating the probability flow ODE.\n\n        Args:\n            theta: Parameters $\\theta$.\n            x: Observed data $x_o$. If None, the default $x_o$ is used.\n            track_gradients: Whether the returned tensor supports tracking gradients.\n                This can be helpful for e.g. sensitivity analysis, but increases memory\n                consumption.\n            atol: Absolute tolerance for the ODE solver.\n            rtol: Relative tolerance for the ODE solver.\n            exact: Whether to use the exact Jacobian of the transformation or an\n                stochastic approximation, which is faster but less accurate.\n\n        Returns:\n            `(len(\u03b8),)`-shaped log posterior probability $\\log p(\\theta|x)$ for \u03b8 in the\n            support of the prior, -\u221e (corresponding to 0 probability) outside.\n        \"\"\"\n        self.potential_fn.set_x(self._x_else_default_x(x))\n\n        theta = ensure_theta_batched(torch.as_tensor(theta))\n        return self.potential_fn(\n            theta.to(self._device),\n            track_gradients=track_gradients,\n            atol=atol,\n            rtol=rtol,\n            exact=exact,\n        )\n\n    def sample_batched(\n        self,\n        sample_shape: torch.Size,\n        x: Tensor,\n        max_sampling_batch_size: int = 10000,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        raise NotImplementedError(\n            \"Batched sampling is not implemented for ScorePosterior.\"\n        )\n\n    def map(\n        self,\n        x: Optional[Tensor] = None,\n        num_iter: int = 1000,\n        num_to_optimize: int = 1000,\n        learning_rate: float = 1e-5,\n        init_method: Union[str, Tensor] = \"posterior\",\n        num_init_samples: int = 1000,\n        save_best_every: int = 1000,\n        show_progress_bars: bool = False,\n        force_update: bool = False,\n    ) -&gt; Tensor:\n        r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n        The method can be interrupted (Ctrl-C) when the user sees that the\n        log-probability converges. The best estimate will be saved in `self._map` and\n        can be accessed with `self.map()`. The MAP is obtained by running gradient\n        ascent from a given number of starting positions (samples from the posterior\n        with the highest log-probability). After the optimization is done, we select the\n        parameter set that has the highest log-probability after the optimization.\n\n        Warning: The default values used by this function are not well-tested. They\n        might require hand-tuning for the problem at hand.\n\n        For developers: if the prior is a `BoxUniform`, we carry out the optimization\n        in unbounded space and transform the result back into bounded space.\n\n        Args:\n            x: Deprecated - use `.set_default_x()` prior to `.map()`.\n            num_iter: Number of optimization steps that the algorithm takes\n                to find the MAP.\n            num_to_optimize: From the drawn `num_init_samples`, use the\n                `num_to_optimize` with highest log-probability as the initial points\n                for the optimization.\n            learning_rate: Learning rate of the optimizer.\n            init_method: How to select the starting parameters for the optimization. If\n                it is a string, it can be either [`posterior`, `prior`], which samples\n                the respective distribution `num_init_samples` times. If it is a\n                tensor, the tensor will be used as init locations.\n            num_init_samples: Draw this number of samples from the posterior and\n                evaluate the log-probability of all of them.\n            save_best_every: The best log-probability is computed, saved in the\n                `map`-attribute, and printed every `save_best_every`-th iteration.\n                Computing the best log-probability creates a significant overhead\n                (thus, the default is `10`.)\n            show_progress_bars: Whether to show a progressbar during sampling from\n                the posterior.\n            force_update: Whether to re-calculate the MAP when x is unchanged and\n                have a cached value.\n\n        Returns:\n            The MAP estimate.\n        \"\"\"\n        raise NotImplementedError(\n            \"MAP estimation is currently not working accurately for ScorePosterior.\"\n        )\n        return super().map(\n            x=x,\n            num_iter=num_iter,\n            num_to_optimize=num_to_optimize,\n            learning_rate=learning_rate,\n            init_method=init_method,\n            num_init_samples=num_init_samples,\n            save_best_every=save_best_every,\n            show_progress_bars=show_progress_bars,\n            force_update=force_update,\n        )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.score_posterior.ScorePosterior.__init__","title":"<code>__init__(score_estimator, prior, max_sampling_batch_size=10000, device=None, enable_transform=False, sample_with='sde')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>prior</code> <code>Distribution</code> <p>Prior distribution with <code>.log_prob()</code> and <code>.sample()</code>.</p> required <code>score_estimator</code> <code>ConditionalScoreEstimator</code> <p>The trained neural score estimator.</p> required <code>max_sampling_batch_size</code> <code>int</code> <p>Batchsize of samples being drawn from the proposal at every iteration.</p> <code>10000</code> <code>device</code> <code>Optional[str]</code> <p>Training device, e.g., \u201ccpu\u201d, \u201ccuda\u201d or \u201ccuda:0\u201d. If None, <code>potential_fn.device</code> is used.</p> <code>None</code> <code>enable_transform</code> <code>bool</code> <p>Whether to transform parameters to unconstrained space during MAP optimization. When False, an identity transform will be returned for <code>theta_transform</code>. True is not supported yet.</p> <code>False</code> <code>sample_with</code> <code>str</code> <p>Whether to sample from the posterior using the ODE-based sampler or the SDE-based sampler.</p> <code>'sde'</code> Source code in <code>sbi/inference/posteriors/score_posterior.py</code> <pre><code>def __init__(\n    self,\n    score_estimator: ConditionalScoreEstimator,\n    prior: Distribution,\n    max_sampling_batch_size: int = 10_000,\n    device: Optional[str] = None,\n    enable_transform: bool = False,\n    sample_with: str = \"sde\",\n):\n    \"\"\"\n    Args:\n        prior: Prior distribution with `.log_prob()` and `.sample()`.\n        score_estimator: The trained neural score estimator.\n        max_sampling_batch_size: Batchsize of samples being drawn from\n            the proposal at every iteration.\n        device: Training device, e.g., \"cpu\", \"cuda\" or \"cuda:0\". If None,\n            `potential_fn.device` is used.\n        enable_transform: Whether to transform parameters to unconstrained space\n            during MAP optimization. When False, an identity transform will be\n            returned for `theta_transform`. True is not supported yet.\n        sample_with: Whether to sample from the posterior using the ODE-based\n            sampler or the SDE-based sampler.\n    \"\"\"\n\n    check_prior(prior)\n    potential_fn, theta_transform = score_estimator_based_potential(\n        score_estimator,\n        prior,\n        x_o=None,\n        enable_transform=enable_transform,\n    )\n    super().__init__(\n        potential_fn=potential_fn,\n        theta_transform=theta_transform,\n        device=device,\n    )\n    # Set the potential function type.\n    self.potential_fn: PosteriorScoreBasedPotential = potential_fn\n\n    self.prior = prior\n    self.score_estimator = score_estimator\n\n    self.sample_with = sample_with\n    assert self.sample_with in [\n        \"ode\",\n        \"sde\",\n    ], f\"sample_with must be 'ode' or 'sde', but is {self.sample_with}.\"\n    self.max_sampling_batch_size = max_sampling_batch_size\n\n    self._purpose = \"\"\"It samples from the diffusion model given the \\\n        score_estimator.\"\"\"\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.score_posterior.ScorePosterior.log_prob","title":"<code>log_prob(theta, x=None, track_gradients=False, atol=1e-05, rtol=1e-06, exact=True)</code>","text":"<p>Returns the log-probability of the posterior \\(p(\\theta|x)\\).</p> <p>This requires building and evaluating the probability flow ODE.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Tensor</code> <p>Parameters \\(\\theta\\).</p> required <code>x</code> <code>Optional[Tensor]</code> <p>Observed data \\(x_o\\). If None, the default \\(x_o\\) is used.</p> <code>None</code> <code>track_gradients</code> <code>bool</code> <p>Whether the returned tensor supports tracking gradients. This can be helpful for e.g. sensitivity analysis, but increases memory consumption.</p> <code>False</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for the ODE solver.</p> <code>1e-05</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the ODE solver.</p> <code>1e-06</code> <code>exact</code> <code>bool</code> <p>Whether to use the exact Jacobian of the transformation or an stochastic approximation, which is faster but less accurate.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tensor</code> <p><code>(len(\u03b8),)</code>-shaped log posterior probability \\(\\log p(\\theta|x)\\) for \u03b8 in the</p> <code>Tensor</code> <p>support of the prior, -\u221e (corresponding to 0 probability) outside.</p> Source code in <code>sbi/inference/posteriors/score_posterior.py</code> <pre><code>def log_prob(\n    self,\n    theta: Tensor,\n    x: Optional[Tensor] = None,\n    track_gradients: bool = False,\n    atol: float = 1e-5,\n    rtol: float = 1e-6,\n    exact: bool = True,\n) -&gt; Tensor:\n    r\"\"\"Returns the log-probability of the posterior $p(\\theta|x)$.\n\n    This requires building and evaluating the probability flow ODE.\n\n    Args:\n        theta: Parameters $\\theta$.\n        x: Observed data $x_o$. If None, the default $x_o$ is used.\n        track_gradients: Whether the returned tensor supports tracking gradients.\n            This can be helpful for e.g. sensitivity analysis, but increases memory\n            consumption.\n        atol: Absolute tolerance for the ODE solver.\n        rtol: Relative tolerance for the ODE solver.\n        exact: Whether to use the exact Jacobian of the transformation or an\n            stochastic approximation, which is faster but less accurate.\n\n    Returns:\n        `(len(\u03b8),)`-shaped log posterior probability $\\log p(\\theta|x)$ for \u03b8 in the\n        support of the prior, -\u221e (corresponding to 0 probability) outside.\n    \"\"\"\n    self.potential_fn.set_x(self._x_else_default_x(x))\n\n    theta = ensure_theta_batched(torch.as_tensor(theta))\n    return self.potential_fn(\n        theta.to(self._device),\n        track_gradients=track_gradients,\n        atol=atol,\n        rtol=rtol,\n        exact=exact,\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.score_posterior.ScorePosterior.map","title":"<code>map(x=None, num_iter=1000, num_to_optimize=1000, learning_rate=1e-05, init_method='posterior', num_init_samples=1000, save_best_every=1000, show_progress_bars=False, force_update=False)</code>","text":"<p>Returns the maximum-a-posteriori estimate (MAP).</p> <p>The method can be interrupted (Ctrl-C) when the user sees that the log-probability converges. The best estimate will be saved in <code>self._map</code> and can be accessed with <code>self.map()</code>. The MAP is obtained by running gradient ascent from a given number of starting positions (samples from the posterior with the highest log-probability). After the optimization is done, we select the parameter set that has the highest log-probability after the optimization.</p> <p>Warning: The default values used by this function are not well-tested. They might require hand-tuning for the problem at hand.</p> <p>For developers: if the prior is a <code>BoxUniform</code>, we carry out the optimization in unbounded space and transform the result back into bounded space.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Optional[Tensor]</code> <p>Deprecated - use <code>.set_default_x()</code> prior to <code>.map()</code>.</p> <code>None</code> <code>num_iter</code> <code>int</code> <p>Number of optimization steps that the algorithm takes to find the MAP.</p> <code>1000</code> <code>num_to_optimize</code> <code>int</code> <p>From the drawn <code>num_init_samples</code>, use the <code>num_to_optimize</code> with highest log-probability as the initial points for the optimization.</p> <code>1000</code> <code>learning_rate</code> <code>float</code> <p>Learning rate of the optimizer.</p> <code>1e-05</code> <code>init_method</code> <code>Union[str, Tensor]</code> <p>How to select the starting parameters for the optimization. If it is a string, it can be either [<code>posterior</code>, <code>prior</code>], which samples the respective distribution <code>num_init_samples</code> times. If it is a tensor, the tensor will be used as init locations.</p> <code>'posterior'</code> <code>num_init_samples</code> <code>int</code> <p>Draw this number of samples from the posterior and evaluate the log-probability of all of them.</p> <code>1000</code> <code>save_best_every</code> <code>int</code> <p>The best log-probability is computed, saved in the <code>map</code>-attribute, and printed every <code>save_best_every</code>-th iteration. Computing the best log-probability creates a significant overhead (thus, the default is <code>10</code>.)</p> <code>1000</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during sampling from the posterior.</p> <code>False</code> <code>force_update</code> <code>bool</code> <p>Whether to re-calculate the MAP when x is unchanged and have a cached value.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>The MAP estimate.</p> Source code in <code>sbi/inference/posteriors/score_posterior.py</code> <pre><code>def map(\n    self,\n    x: Optional[Tensor] = None,\n    num_iter: int = 1000,\n    num_to_optimize: int = 1000,\n    learning_rate: float = 1e-5,\n    init_method: Union[str, Tensor] = \"posterior\",\n    num_init_samples: int = 1000,\n    save_best_every: int = 1000,\n    show_progress_bars: bool = False,\n    force_update: bool = False,\n) -&gt; Tensor:\n    r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n    The method can be interrupted (Ctrl-C) when the user sees that the\n    log-probability converges. The best estimate will be saved in `self._map` and\n    can be accessed with `self.map()`. The MAP is obtained by running gradient\n    ascent from a given number of starting positions (samples from the posterior\n    with the highest log-probability). After the optimization is done, we select the\n    parameter set that has the highest log-probability after the optimization.\n\n    Warning: The default values used by this function are not well-tested. They\n    might require hand-tuning for the problem at hand.\n\n    For developers: if the prior is a `BoxUniform`, we carry out the optimization\n    in unbounded space and transform the result back into bounded space.\n\n    Args:\n        x: Deprecated - use `.set_default_x()` prior to `.map()`.\n        num_iter: Number of optimization steps that the algorithm takes\n            to find the MAP.\n        num_to_optimize: From the drawn `num_init_samples`, use the\n            `num_to_optimize` with highest log-probability as the initial points\n            for the optimization.\n        learning_rate: Learning rate of the optimizer.\n        init_method: How to select the starting parameters for the optimization. If\n            it is a string, it can be either [`posterior`, `prior`], which samples\n            the respective distribution `num_init_samples` times. If it is a\n            tensor, the tensor will be used as init locations.\n        num_init_samples: Draw this number of samples from the posterior and\n            evaluate the log-probability of all of them.\n        save_best_every: The best log-probability is computed, saved in the\n            `map`-attribute, and printed every `save_best_every`-th iteration.\n            Computing the best log-probability creates a significant overhead\n            (thus, the default is `10`.)\n        show_progress_bars: Whether to show a progressbar during sampling from\n            the posterior.\n        force_update: Whether to re-calculate the MAP when x is unchanged and\n            have a cached value.\n\n    Returns:\n        The MAP estimate.\n    \"\"\"\n    raise NotImplementedError(\n        \"MAP estimation is currently not working accurately for ScorePosterior.\"\n    )\n    return super().map(\n        x=x,\n        num_iter=num_iter,\n        num_to_optimize=num_to_optimize,\n        learning_rate=learning_rate,\n        init_method=init_method,\n        num_init_samples=num_init_samples,\n        save_best_every=save_best_every,\n        show_progress_bars=show_progress_bars,\n        force_update=force_update,\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.score_posterior.ScorePosterior.sample","title":"<code>sample(sample_shape=torch.Size(), x=None, predictor='euler_maruyama', corrector=None, predictor_params=None, corrector_params=None, steps=500, ts=None, max_sampling_batch_size=10000, sample_with=None, show_progress_bars=True)</code>","text":"<p>Return samples from posterior distribution \\(p(\\theta|x)\\).</p> <p>Parameters:</p> Name Type Description Default <code>sample_shape</code> <code>Shape</code> <p>Shape of the samples to be drawn.</p> <code>Size()</code> <code>x</code> <code>Optional[Tensor]</code> <p>Deprecated - use <code>.set_default_x()</code> prior to <code>.sample()</code>.</p> <code>None</code> <code>predictor</code> <code>Union[str, Predictor]</code> <p>The predictor for the diffusion-based sampler. Can be a string or a custom predictor following the API in <code>sbi.samplers.score.predictors</code>. Currently, only <code>euler_maruyama</code> is implemented.</p> <code>'euler_maruyama'</code> <code>corrector</code> <code>Optional[Union[str, Corrector]]</code> <p>The corrector for the diffusion-based sampler. Either of [None].</p> <code>None</code> <code>predictor_params</code> <code>Optional[Dict]</code> <p>Additional parameters passed to predictor.</p> <code>None</code> <code>corrector_params</code> <code>Optional[Dict]</code> <p>Additional parameters passed to corrector.</p> <code>None</code> <code>steps</code> <code>int</code> <p>Number of steps to take for the Euler-Maruyama method.</p> <code>500</code> <code>ts</code> <code>Optional[Tensor]</code> <p>Time points at which to evaluate the diffusion process. If None, a linear grid between t_max and t_min is used.</p> <code>None</code> <code>max_sampling_batch_size</code> <code>int</code> <p>Maximum batch size for sampling.</p> <code>10000</code> <code>sample_with</code> <code>Optional[str]</code> <p>Deprecated - use <code>.build_posterior(sample_with=...)</code> prior to <code>.sample()</code>.</p> <code>None</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progress bar during sampling.</p> <code>True</code> Source code in <code>sbi/inference/posteriors/score_posterior.py</code> <pre><code>def sample(\n    self,\n    sample_shape: Shape = torch.Size(),\n    x: Optional[Tensor] = None,\n    predictor: Union[str, Predictor] = \"euler_maruyama\",\n    corrector: Optional[Union[str, Corrector]] = None,\n    predictor_params: Optional[Dict] = None,\n    corrector_params: Optional[Dict] = None,\n    steps: int = 500,\n    ts: Optional[Tensor] = None,\n    max_sampling_batch_size: int = 10_000,\n    sample_with: Optional[str] = None,\n    show_progress_bars: bool = True,\n) -&gt; Tensor:\n    r\"\"\"Return samples from posterior distribution $p(\\theta|x)$.\n\n    Args:\n        sample_shape: Shape of the samples to be drawn.\n        x: Deprecated - use `.set_default_x()` prior to `.sample()`.\n        predictor: The predictor for the diffusion-based sampler. Can be a string or\n            a custom predictor following the API in `sbi.samplers.score.predictors`.\n            Currently, only `euler_maruyama` is implemented.\n        corrector: The corrector for the diffusion-based sampler. Either of\n            [None].\n        predictor_params: Additional parameters passed to predictor.\n        corrector_params: Additional parameters passed to corrector.\n        steps: Number of steps to take for the Euler-Maruyama method.\n        ts: Time points at which to evaluate the diffusion process. If None, a\n            linear grid between t_max and t_min is used.\n        max_sampling_batch_size: Maximum batch size for sampling.\n        sample_with: Deprecated - use `.build_posterior(sample_with=...)` prior to\n            `.sample()`.\n        show_progress_bars: Whether to show a progress bar during sampling.\n    \"\"\"\n\n    if sample_with is not None:\n        raise ValueError(\n            f\"You set `sample_with={sample_with}`. As of sbi v0.18.0, setting \"\n            f\"`sample_with` is no longer supported. You have to rerun \"\n            f\"`.build_posterior(sample_with={sample_with}).`\"\n        )\n\n    x = self._x_else_default_x(x)\n    x = reshape_to_batch_event(x, self.score_estimator.condition_shape)\n    self.potential_fn.set_x(x)\n\n    if self.sample_with == \"ode\":\n        samples = self.sample_via_zuko(sample_shape=sample_shape, x=x)\n    elif self.sample_with == \"sde\":\n        samples = self._sample_via_diffusion(\n            sample_shape=sample_shape,\n            predictor=predictor,\n            corrector=corrector,\n            predictor_params=predictor_params,\n            corrector_params=corrector_params,\n            steps=steps,\n            ts=ts,\n            max_sampling_batch_size=max_sampling_batch_size,\n            show_progress_bars=show_progress_bars,\n        )\n\n    return samples\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.score_posterior.ScorePosterior.sample_via_zuko","title":"<code>sample_via_zuko(x, sample_shape=torch.Size())</code>","text":"<p>Return samples from posterior distribution with probability flow ODE.</p> <p>This build the probability flow ODE and then samples from the corresponding flow. This is implemented via the zuko library.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>Condition.</p> required <code>sample_shape</code> <code>Shape</code> <p>The shape of the samples to be returned.</p> <code>Size()</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Samples.</p> Source code in <code>sbi/inference/posteriors/score_posterior.py</code> <pre><code>def sample_via_zuko(\n    self,\n    x: Tensor,\n    sample_shape: Shape = torch.Size(),\n) -&gt; Tensor:\n    r\"\"\"Return samples from posterior distribution with probability flow ODE.\n\n    This build the probability flow ODE and then samples from the corresponding\n    flow. This is implemented via the zuko library.\n\n    Args:\n        x: Condition.\n        sample_shape: The shape of the samples to be returned.\n\n    Returns:\n        Samples.\n    \"\"\"\n    num_samples = torch.Size(sample_shape).numel()\n\n    flow = self.potential_fn.get_continuous_normalizing_flow(condition=x)\n    samples = flow.sample(torch.Size((num_samples,)))\n\n    return samples.reshape(sample_shape + self.score_estimator.input_shape)\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior","title":"<code>VIPosterior</code>","text":"<p>               Bases: <code>NeuralPosterior</code></p> <p>Provides VI (Variational Inference) to sample from the posterior. SNLE or SNRE train neural networks to approximate the likelihood(-ratios). <code>VIPosterior</code> allows to learn a tractable variational posterior \\(q(\\theta)\\) which approximates the true posterior \\(p(\\theta|x_o)\\). After this second training stage, we can produce approximate posterior samples, by just sampling from q with no additional cost. For additional information see [1] and [2]. References: [1] Variational methods for simulation-based inference, Manuel Gl\u00f6ckler, Michael Deistler, Jakob Macke, 2022, https://openreview.net/forum?id=kZ0UYdhqkNY [2] Sequential Neural Posterior and Likelihood Approximation, Samuel Wiqvist, Jes Frellsen, Umberto Picchini, 2021, https://arxiv.org/abs/2102.06522</p> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>class VIPosterior(NeuralPosterior):\n    r\"\"\"Provides VI (Variational Inference) to sample from the posterior.&lt;br/&gt;&lt;br/&gt;\n    SNLE or SNRE train neural networks to approximate the likelihood(-ratios).\n    `VIPosterior` allows to learn a tractable variational posterior $q(\\theta)$ which\n    approximates the true posterior $p(\\theta|x_o)$. After this second training stage,\n    we can produce approximate posterior samples, by just sampling from q with no\n    additional cost. For additional information see [1] and [2].&lt;br/&gt;&lt;br/&gt;\n    References:&lt;br/&gt;\n    [1] Variational methods for simulation-based inference, Manuel Gl\u00f6ckler, Michael\n    Deistler, Jakob Macke, 2022, https://openreview.net/forum?id=kZ0UYdhqkNY&lt;br/&gt;\n    [2] Sequential Neural Posterior and Likelihood Approximation, Samuel Wiqvist, Jes\n    Frellsen, Umberto Picchini, 2021, https://arxiv.org/abs/2102.06522\n    \"\"\"\n\n    def __init__(\n        self,\n        potential_fn: Union[Callable, BasePotential],\n        prior: Optional[TorchDistribution] = None,\n        q: Union[str, PyroTransformedDistribution, \"VIPosterior\", Callable] = \"maf\",\n        theta_transform: Optional[TorchTransform] = None,\n        vi_method: str = \"rKL\",\n        device: str = \"cpu\",\n        x_shape: Optional[torch.Size] = None,\n        parameters: Iterable = [],\n        modules: Iterable = [],\n    ):\n        \"\"\"\n        Args:\n            potential_fn: The potential function from which to draw samples. Must be a\n                `BasePotential` or a `Callable` which takes `theta` and `x_o` as inputs.\n            prior: This is the prior distribution. Note that this is only\n                used to check/construct the variational distribution or within some\n                quality metrics. Please make sure that this matches with the prior\n                within the potential_fn. If `None` is given, we will try to infer it\n                from potential_fn or q, if this fails we raise an Error.\n            q: Variational distribution, either string, `TransformedDistribution`, or a\n                `VIPosterior` object. This specifies a parametric class of distribution\n                over which the best possible posterior approximation is searched. For\n                string input, we currently support [nsf, scf, maf, mcf, gaussian,\n                gaussian_diag]. You can also specify your own variational family by\n                passing a pyro `TransformedDistribution`.\n                Additionally, we allow a `Callable`, which allows you the pass a\n                `builder` function, which if called returns a distribution. This may be\n                useful for setting the hyperparameters e.g. `num_transfroms` within the\n                `get_flow_builder` method specifying the number of transformations\n                within a normalizing flow. If q is already a `VIPosterior`, then the\n                arguments will be copied from it (relevant for multi-round training).\n            theta_transform: Maps form prior support to unconstrained space. The\n                inverse is used here to ensure that the posterior support is equal to\n                that of the prior.\n            vi_method: This specifies the variational methods which are used to fit q to\n                the posterior. We currently support [rKL, fKL, IW, alpha]. Note that\n                some of the divergences are `mode seeking` i.e. they underestimate\n                variance and collapse on multimodal targets (`rKL`, `alpha` for alpha &gt;\n                1) and some are `mass covering` i.e. they overestimate variance but\n                typically cover all modes (`fKL`, `IW`, `alpha` for alpha &lt; 1).\n            device: Training device, e.g., `cpu`, `cuda` or `cuda:0`. We will ensure\n                that all other objects are also on this device.\n            x_shape: Deprecated, should not be passed.\n            parameters: List of parameters of the variational posterior. This is only\n                required for user-defined q i.e. if q does not have a `parameters`\n                attribute.\n            modules: List of modules of the variational posterior. This is only\n                required for user-defined q i.e. if q does not have a `modules`\n                attribute.\n        \"\"\"\n        super().__init__(potential_fn, theta_transform, device, x_shape=x_shape)\n\n        # Especially the prior may be on another device -&gt; move it...\n        self._device = device\n        self.potential_fn.device = device\n        move_all_tensor_to_device(self.potential_fn, device)\n\n        # Get prior and previous builds\n        if prior is not None:\n            self._prior = prior\n        elif hasattr(self.potential_fn, \"prior\") and isinstance(\n            self.potential_fn.prior, Distribution\n        ):\n            self._prior = self.potential_fn.prior\n        elif isinstance(q, VIPosterior) and isinstance(q._prior, Distribution):\n            self._prior = q._prior\n        else:\n            raise ValueError(\n                \"We could not find a suitable prior distribution within `potential_fn` \"\n                \"or `q` (if a VIPosterior is given). Please explicitly specify a prior.\"\n            )\n        move_all_tensor_to_device(self._prior, device)\n        self._optimizer = None\n\n        # In contrast to MCMC we want to project into constrained space.\n        if theta_transform is None:\n            self.link_transform = mcmc_transform(self._prior).inv\n        else:\n            self.link_transform = theta_transform.inv\n\n        # This will set the variational distribution and VI method\n        self.set_q(q, parameters=parameters, modules=modules)\n        self.set_vi_method(vi_method)\n\n        self._purpose = (\n            \"It provides Variational inference to .sample() from the posterior and \"\n            \"can evaluate the _normalized_ posterior density with .log_prob().\"\n        )\n\n    @property\n    def q(self) -&gt; Distribution:\n        \"\"\"Returns the variational posterior.\"\"\"\n        return self._q\n\n    @q.setter\n    def q(\n        self,\n        q: Union[str, Distribution, \"VIPosterior\", Callable],\n    ) -&gt; None:\n        \"\"\"Sets the variational distribution. If the distribution does not admit access\n        through `parameters` and `modules` function, please use `set_q` if you want to\n        explicitly specify the parameters and modules.\n\n\n        Args:\n            q: Variational distribution, either string, distribution, or a VIPosterior\n                object. This specifies a parametric class of distribution over which\n                the best possible posterior approximation is searched. For string input,\n                we currently support [nsf, scf, maf, mcf, gaussian, gaussian_diag]. Of\n                course, you can also specify your own variational family by passing a\n                `parameterized` distribution object i.e. a torch.distributions\n                Distribution with methods `parameters` returning an iterable of all\n                parameters (you can pass them within the paramters/modules attribute).\n                Additionally, we allow a `Callable`, which allows you the pass a\n                `builder` function, which if called returns an distribution. This may be\n                useful for setting the hyperparameters e.g. `num_transfroms:int` by\n                using the `get_flow_builder` method specifying the hyperparameters. If q\n                is already a `VIPosterior`, then the arguments will be copied from it\n                (relevant for multi-round training).\n\n\n        \"\"\"\n        self.set_q(q)\n\n    def set_q(\n        self,\n        q: Union[str, PyroTransformedDistribution, \"VIPosterior\", Callable],\n        parameters: Iterable = [],\n        modules: Iterable = [],\n    ) -&gt; None:\n        \"\"\"Defines the variational family.\n\n        You can specify over which parameters/modules we optimize. This is required for\n        custom distributions which e.g. do not inherit nn.Modules or has the function\n        `parameters` or `modules` to give direct access to trainable parameters.\n        Further, you can pass a function, which constructs a variational distribution\n        if called.\n\n        Args:\n            q: Variational distribution, either string, distribution, or a VIPosterior\n                object. This specifies a parametric class of distribution over which\n                the best possible posterior approximation is searched. For string input,\n                we currently support [nsf, scf, maf, mcf, gaussian, gaussian_diag]. Of\n                course, you can also specify your own variational family by passing a\n                `parameterized` distribution object i.e. a torch.distributions\n                Distribution with methods `parameters` returning an iterable of all\n                parameters (you can pass them within the paramters/modules attribute).\n                Additionally, we allow a `Callable`, which allows you the pass a\n                `builder` function, which if called returns an distribution. This may be\n                useful for setting the hyperparameters e.g. `num_transfroms:int` by\n                using the `get_flow_builder` method specifying the hyperparameters. If q\n                is already a `VIPosterior`, then the arguments will be copied from it\n                (relevant for multi-round training).\n            parameters: List of parameters associated with the distribution object.\n            modules: List of modules associated with the distribution object.\n\n        \"\"\"\n        self._q_arg = (q, parameters, modules)\n        if isinstance(q, Distribution):\n            q = adapt_variational_distribution(\n                q,\n                self._prior,\n                self.link_transform,\n                parameters=parameters,\n                modules=modules,\n            )\n            make_object_deepcopy_compatible(q)\n            self_custom_q_init_cache = deepcopy(q)\n            self._q_build_fn = lambda *args, **kwargs: self_custom_q_init_cache\n            self._trained_on = None\n        elif isinstance(q, (str, Callable)):\n            if isinstance(q, str):\n                self._q_build_fn = get_flow_builder(q)\n            else:\n                self._q_build_fn = q\n\n            q = self._q_build_fn(\n                self._prior.event_shape,\n                self.link_transform,\n                device=self._device,\n            )\n            make_object_deepcopy_compatible(q)\n            self._trained_on = None\n        elif isinstance(q, VIPosterior):\n            self._q_build_fn = q._q_build_fn\n            self._trained_on = q._trained_on\n            self.vi_method = q.vi_method  # type: ignore\n            self._device = q._device\n            self._prior = q._prior\n            self._x = q._x\n            self._q_arg = q._q_arg\n            make_object_deepcopy_compatible(q.q)\n            q = deepcopy(q.q)\n        move_all_tensor_to_device(q, self._device)\n        assert isinstance(\n            q, Distribution\n        ), \"\"\"Something went wrong when initializing the variational distribution.\n            Please create an issue on github https://github.com/mackelab/sbi/issues\"\"\"\n        check_variational_distribution(q, self._prior)\n        self._q = q\n\n    @property\n    def vi_method(self) -&gt; str:\n        \"\"\"Variational inference method e.g. one of [rKL, fKL, IW, alpha].\"\"\"\n        return self._vi_method\n\n    @vi_method.setter\n    def vi_method(self, method: str) -&gt; None:\n        \"\"\"See `set_vi_method`.\"\"\"\n        self.set_vi_method(method)\n\n    def set_vi_method(self, method: str) -&gt; \"VIPosterior\":\n        \"\"\"Sets variational inference method.\n\n        Args:\n            method: One of [rKL, fKL, IW, alpha].\n\n        Returns:\n            `VIPosterior` for chainable calls.\n        \"\"\"\n        self._vi_method = method\n        self._optimizer_builder = get_VI_method(method)\n        return self\n\n    def sample(\n        self,\n        sample_shape: Shape = torch.Size(),\n        x: Optional[Tensor] = None,\n        **kwargs,\n    ) -&gt; Tensor:\n        \"\"\"Samples from the variational posterior distribution.\n\n        Args:\n            sample_shape: Shape of samples\n\n        Returns:\n            Samples from posterior.\n        \"\"\"\n        x = self._x_else_default_x(x)\n        if self._trained_on is None or (x != self._trained_on).all():\n            raise AttributeError(\n                f\"The variational posterior was not fit on the specified `default_x` \"\n                f\"{x}. Please train using `posterior.train()`.\"\n            )\n        samples = self.q.sample(torch.Size(sample_shape))\n        return samples.reshape((*sample_shape, samples.shape[-1]))\n\n    def sample_batched(\n        self,\n        sample_shape: Shape,\n        x: Tensor,\n        max_sampling_batch_size: int = 10000,\n        show_progress_bars: bool = True,\n    ) -&gt; Tensor:\n        raise NotImplementedError(\n            \"Batched sampling is not implemented for VIPosterior. \\\n            Alternatively you can use `sample` in a loop \\\n            [posterior.sample(theta, x_o) for x_o in x].\"\n        )\n\n    def log_prob(\n        self,\n        theta: Tensor,\n        x: Optional[Tensor] = None,\n        track_gradients: bool = False,\n    ) -&gt; Tensor:\n        r\"\"\"Returns the log-probability of theta under the variational posterior.\n\n        Args:\n            theta: Parameters\n            track_gradients: Whether the returned tensor supports tracking gradients.\n                This can be helpful for e.g. sensitivity analysis but increases memory\n                consumption.\n\n        Returns:\n            `len($\\theta$)`-shaped log-probability.\n        \"\"\"\n        x = self._x_else_default_x(x)\n        if self._trained_on is None or (x != self._trained_on).all():\n            raise AttributeError(\n                f\"The variational posterior was not fit using observation {x}.\\\n                     Please train.\"\n            )\n        with torch.set_grad_enabled(track_gradients):\n            theta = ensure_theta_batched(torch.as_tensor(theta))\n            return self.q.log_prob(theta)\n\n    def train(\n        self,\n        x: Optional[TorchTensor] = None,\n        n_particles: int = 256,\n        learning_rate: float = 1e-3,\n        gamma: float = 0.999,\n        max_num_iters: int = 2000,\n        min_num_iters: int = 10,\n        clip_value: float = 10.0,\n        warm_up_rounds: int = 100,\n        retrain_from_scratch: bool = False,\n        reset_optimizer: bool = False,\n        show_progress_bar: bool = True,\n        check_for_convergence: bool = True,\n        quality_control: bool = True,\n        quality_control_metric: str = \"psis\",\n        **kwargs,\n    ) -&gt; \"VIPosterior\":\n        \"\"\"This method trains the variational posterior.\n\n        Args:\n            x: The observation.\n            n_particles: Number of samples to approximate expectations within the\n                variational bounds. The larger the more accurate are gradient\n                estimates, but the computational cost per iteration increases.\n            learning_rate: Learning rate of the optimizer.\n            gamma: Learning rate decay per iteration. We use an exponential decay\n                scheduler.\n            max_num_iters: Maximum number of iterations.\n            min_num_iters: Minimum number of iterations.\n            clip_value: Gradient clipping value, decreasing may help if you see invalid\n                values.\n            warm_up_rounds: Initialize the posterior as the prior.\n            retrain_from_scratch: Retrain the variational distributions from scratch.\n            reset_optimizer: Reset the divergence optimizer\n            show_progress_bar: If any progress report should be displayed.\n            quality_control: If False quality control is skipped.\n            quality_control_metric: Which metric to use for evaluating the quality.\n            kwargs: Hyperparameters check corresponding `DivergenceOptimizer` for detail\n                eps: Determines sensitivity of convergence check.\n                retain_graph: Boolean which decides whether to retain the computation\n                    graph. This may be required for some `exotic` user-specified q's.\n                optimizer: A PyTorch Optimizer class e.g. Adam or SGD. See\n                    `DivergenceOptimizer` for details.\n                scheduler: A PyTorch learning rate scheduler. See\n                    `DivergenceOptimizer` for details.\n                alpha: Only used if vi_method=`alpha`. Determines the alpha divergence.\n                K: Only used if vi_method=`IW`. Determines the number of importance\n                    weighted particles.\n                stick_the_landing: If one should use the STL estimator (only for rKL,\n                    IW, alpha).\n                dreg: If one should use the DREG estimator (only for rKL, IW, alpha).\n                weight_transform: Callable applied to importance weights (only for fKL)\n        Returns:\n            VIPosterior: `VIPosterior` (can be used to chain calls).\n        \"\"\"\n        # Update optimizer with current arguments.\n        if self._optimizer is not None:\n            self._optimizer.update({**locals(), **kwargs})\n\n        # Init q and the optimizer if necessary\n        if retrain_from_scratch:\n            self.q = self._q_build_fn()  # type: ignore\n            self._optimizer = self._optimizer_builder(\n                self.potential_fn,\n                self.q,\n                lr=learning_rate,\n                clip_value=clip_value,\n                gamma=gamma,\n                n_particles=n_particles,\n                prior=self._prior,\n                **kwargs,\n            )\n\n        if (\n            reset_optimizer\n            or self._optimizer is None\n            or not isinstance(self._optimizer, self._optimizer_builder)\n        ):\n            self._optimizer = self._optimizer_builder(\n                self.potential_fn,\n                self.q,\n                lr=learning_rate,\n                clip_value=clip_value,\n                gamma=gamma,\n                n_particles=n_particles,\n                prior=self._prior,\n                **kwargs,\n            )\n\n        # Check context\n        x = atleast_2d_float32_tensor(self._x_else_default_x(x)).to(  # type: ignore\n            self._device\n        )\n\n        already_trained = self._trained_on is not None and (x == self._trained_on).all()\n\n        # Optimize\n        optimizer = self._optimizer\n        optimizer.to(self._device)\n        optimizer.reset_loss_stats()\n\n        if show_progress_bar:\n            iters = tqdm(range(max_num_iters))\n        else:\n            iters = range(max_num_iters)\n\n        # Warmup before training\n        if reset_optimizer or (not optimizer.warm_up_was_done and not already_trained):\n            if show_progress_bar:\n                iters.set_description(  # type: ignore\n                    \"Warmup phase, this may take a few seconds...\"\n                )\n            optimizer.warm_up(warm_up_rounds)\n\n        for i in iters:\n            optimizer.step(x)\n            mean_loss, std_loss = optimizer.get_loss_stats()\n            # Update progress bar\n            if show_progress_bar:\n                assert isinstance(iters, tqdm)\n                iters.set_description(  # type: ignore\n                    f\"Loss: {np.round(float(mean_loss), 2)}\"\n                    f\"Std: {np.round(float(std_loss), 2)}\"\n                )\n            # Check for convergence\n            if check_for_convergence and i &gt; min_num_iters and optimizer.converged():\n                if show_progress_bar:\n                    print(f\"\\nConverged with loss: {np.round(float(mean_loss), 2)}\")\n                break\n        # Training finished:\n        self._trained_on = x\n\n        # Evaluate quality\n        if quality_control:\n            try:\n                self.evaluate(quality_control_metric=quality_control_metric)\n            except Exception as e:\n                print(\n                    f\"Quality control showed a low quality of the variational \"\n                    f\"posterior. We are automatically retraining the variational \"\n                    f\"posterior from scratch with a smaller learning rate. \"\n                    f\"Alternatively, if you want to skip quality control, please \"\n                    f\"retrain with `VIPosterior.train(..., quality_control=False)`. \"\n                    f\"\\nThe error that occured is: {e}\"\n                )\n                self.train(\n                    learning_rate=learning_rate * 0.1,\n                    retrain_from_scratch=True,\n                    reset_optimizer=True,\n                )\n\n        return self\n\n    def evaluate(self, quality_control_metric: str = \"psis\", N: int = int(5e4)) -&gt; None:\n        \"\"\"This function will evaluate the quality of the variational posterior\n        distribution. We currently support two different metrics of type `psis`, which\n        checks the quality based on the tails of importance weights (there should not be\n        much with a large one), or `prop` which checks the proportionality between q\n        and potential_fn.\n\n        NOTE: In our experience `prop` is sensitive to distinguish ``good`` from ``ok``\n        whereas `psis` is more sensitive in distinguishing `very bad` from `ok`.\n\n        Args:\n            quality_control_metric: The metric of choice, we currently support [psis,\n                prop, prop_prior].\n            N: Number of samples which is used to evaluate the metric.\n        \"\"\"\n        quality_control_fn, quality_control_msg = get_quality_metric(\n            quality_control_metric\n        )\n        metric = round(float(quality_control_fn(self, N=N)), 3)\n        print(f\"Quality Score: {metric} \" + quality_control_msg)\n\n    def map(\n        self,\n        x: Optional[TorchTensor] = None,\n        num_iter: int = 1_000,\n        num_to_optimize: int = 100,\n        learning_rate: float = 0.01,\n        init_method: Union[str, TorchTensor] = \"proposal\",\n        num_init_samples: int = 10_000,\n        save_best_every: int = 10,\n        show_progress_bars: bool = False,\n        force_update: bool = False,\n    ) -&gt; Tensor:\n        r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n        The method can be interrupted (Ctrl-C) when the user sees that the\n        log-probability converges. The best estimate will be saved in `self._map` and\n        can be accessed with `self.map()`. The MAP is obtained by running gradient\n        ascent from a given number of starting positions (samples from the posterior\n        with the highest log-probability). After the optimization is done, we select the\n        parameter set that has the highest log-probability after the optimization.\n\n        Warning: The default values used by this function are not well-tested. They\n        might require hand-tuning for the problem at hand.\n\n        For developers: if the prior is a `BoxUniform`, we carry out the optimization\n        in unbounded space and transform the result back into bounded space.\n\n        Args:\n            x: Deprecated - use `.set_default_x()` prior to `.map()`.\n            num_iter: Number of optimization steps that the algorithm takes\n                to find the MAP.\n            learning_rate: Learning rate of the optimizer.\n            init_method: How to select the starting parameters for the optimization. If\n                it is a string, it can be either [`posterior`, `prior`], which samples\n                the respective distribution `num_init_samples` times. If it is a\n                tensor, the tensor will be used as init locations.\n            num_init_samples: Draw this number of samples from the posterior and\n                evaluate the log-probability of all of them.\n            num_to_optimize: From the drawn `num_init_samples`, use the\n                `num_to_optimize` with highest log-probability as the initial points\n                for the optimization.\n            save_best_every: The best log-probability is computed, saved in the\n                `map`-attribute, and printed every `save_best_every`-th iteration.\n                Computing the best log-probability creates a significant overhead\n                (thus, the default is `10`.)\n            show_progress_bars: Whether to show a progressbar during sampling from\n                the posterior.\n            force_update: Whether to re-calculate the MAP when x is unchanged and\n                have a cached value.\n            log_prob_kwargs: Will be empty for SNLE and SNRE. Will contain\n                {'norm_posterior': True} for SNPE.\n\n        Returns:\n            The MAP estimate.\n        \"\"\"\n        self.proposal = self.q\n        return super().map(\n            x=x,\n            num_iter=num_iter,\n            num_to_optimize=num_to_optimize,\n            learning_rate=learning_rate,\n            init_method=init_method,\n            num_init_samples=num_init_samples,\n            save_best_every=save_best_every,\n            show_progress_bars=show_progress_bars,\n            force_update=force_update,\n        )\n\n    def __deepcopy__(self, memo: Optional[Dict] = None) -&gt; \"VIPosterior\":\n        \"\"\"This method is called when using `copy.deepcopy` on the object.\n\n        It defines how the object is copied. We need to overwrite this method, since the\n        default implementation does use __getstate__ and __setstate__ which we overwrite\n        to enable pickling (and in particular the necessary modifications are\n        incompatible deep copying).\n\n        Args:\n            memo (Optional[Dict], optional): Deep copy internal memo. Defaults to None.\n\n        Returns:\n            VIPosterior: Deep copy of the VIPosterior.\n        \"\"\"\n        if memo is None:\n            memo = {}\n        # Create a new instance of the class\n        cls = self.__class__\n        result = cls.__new__(cls)\n        # Add to memo\n        memo[id(self)] = result\n        # Copy attributes\n        for k, v in self.__dict__.items():\n            setattr(result, k, copy.deepcopy(v, memo))\n        return result\n\n    def __getstate__(self) -&gt; Dict:\n        \"\"\"This method is called when pickling the object.\n\n        It defines what is pickled. We need to overwrite this method, since some parts\n        due not support pickle protocols (e.g. due to local functions, etc.).\n\n        Returns:\n            Dict: All attributes of the VIPosterior.\n        \"\"\"\n        self._optimizer = None\n        self.__deepcopy__ = None  # type: ignore\n        self._q_build_fn = None\n        self._q.__deepcopy__ = None  # type: ignore\n        return self.__dict__\n\n    def __setstate__(self, state_dict: Dict):\n        \"\"\"This method is called when unpickling the object.\n\n        Especially, we need to restore the removed attributes and ensure that the object\n        e.g. remains deep copy compatible.\n\n        Args:\n            state_dict: Given state dictionary, we will restore the object from it.\n        \"\"\"\n        self.__dict__ = state_dict\n        q = deepcopy(self._q)\n        # Restore removed attributes\n        self.set_q(*self._q_arg)\n        self._q = q\n        make_object_deepcopy_compatible(self)\n        make_object_deepcopy_compatible(self.q)\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.q","title":"<code>q: Distribution</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the variational posterior.</p>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.vi_method","title":"<code>vi_method: str</code>  <code>property</code> <code>writable</code>","text":"<p>Variational inference method e.g. one of [rKL, fKL, IW, alpha].</p>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.__deepcopy__","title":"<code>__deepcopy__(memo=None)</code>","text":"<p>This method is called when using <code>copy.deepcopy</code> on the object.</p> <p>It defines how the object is copied. We need to overwrite this method, since the default implementation does use getstate and setstate which we overwrite to enable pickling (and in particular the necessary modifications are incompatible deep copying).</p> <p>Parameters:</p> Name Type Description Default <code>memo</code> <code>Optional[Dict]</code> <p>Deep copy internal memo. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>VIPosterior</code> <code>VIPosterior</code> <p>Deep copy of the VIPosterior.</p> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def __deepcopy__(self, memo: Optional[Dict] = None) -&gt; \"VIPosterior\":\n    \"\"\"This method is called when using `copy.deepcopy` on the object.\n\n    It defines how the object is copied. We need to overwrite this method, since the\n    default implementation does use __getstate__ and __setstate__ which we overwrite\n    to enable pickling (and in particular the necessary modifications are\n    incompatible deep copying).\n\n    Args:\n        memo (Optional[Dict], optional): Deep copy internal memo. Defaults to None.\n\n    Returns:\n        VIPosterior: Deep copy of the VIPosterior.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    # Create a new instance of the class\n    cls = self.__class__\n    result = cls.__new__(cls)\n    # Add to memo\n    memo[id(self)] = result\n    # Copy attributes\n    for k, v in self.__dict__.items():\n        setattr(result, k, copy.deepcopy(v, memo))\n    return result\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.__getstate__","title":"<code>__getstate__()</code>","text":"<p>This method is called when pickling the object.</p> <p>It defines what is pickled. We need to overwrite this method, since some parts due not support pickle protocols (e.g. due to local functions, etc.).</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>All attributes of the VIPosterior.</p> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def __getstate__(self) -&gt; Dict:\n    \"\"\"This method is called when pickling the object.\n\n    It defines what is pickled. We need to overwrite this method, since some parts\n    due not support pickle protocols (e.g. due to local functions, etc.).\n\n    Returns:\n        Dict: All attributes of the VIPosterior.\n    \"\"\"\n    self._optimizer = None\n    self.__deepcopy__ = None  # type: ignore\n    self._q_build_fn = None\n    self._q.__deepcopy__ = None  # type: ignore\n    return self.__dict__\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.__init__","title":"<code>__init__(potential_fn, prior=None, q='maf', theta_transform=None, vi_method='rKL', device='cpu', x_shape=None, parameters=[], modules=[])</code>","text":"<p>Parameters:</p> Name Type Description Default <code>potential_fn</code> <code>Union[Callable, BasePotential]</code> <p>The potential function from which to draw samples. Must be a <code>BasePotential</code> or a <code>Callable</code> which takes <code>theta</code> and <code>x_o</code> as inputs.</p> required <code>prior</code> <code>Optional[TorchDistribution]</code> <p>This is the prior distribution. Note that this is only used to check/construct the variational distribution or within some quality metrics. Please make sure that this matches with the prior within the potential_fn. If <code>None</code> is given, we will try to infer it from potential_fn or q, if this fails we raise an Error.</p> <code>None</code> <code>q</code> <code>Union[str, PyroTransformedDistribution, VIPosterior, Callable]</code> <p>Variational distribution, either string, <code>TransformedDistribution</code>, or a <code>VIPosterior</code> object. This specifies a parametric class of distribution over which the best possible posterior approximation is searched. For string input, we currently support [nsf, scf, maf, mcf, gaussian, gaussian_diag]. You can also specify your own variational family by passing a pyro <code>TransformedDistribution</code>. Additionally, we allow a <code>Callable</code>, which allows you the pass a <code>builder</code> function, which if called returns a distribution. This may be useful for setting the hyperparameters e.g. <code>num_transfroms</code> within the <code>get_flow_builder</code> method specifying the number of transformations within a normalizing flow. If q is already a <code>VIPosterior</code>, then the arguments will be copied from it (relevant for multi-round training).</p> <code>'maf'</code> <code>theta_transform</code> <code>Optional[TorchTransform]</code> <p>Maps form prior support to unconstrained space. The inverse is used here to ensure that the posterior support is equal to that of the prior.</p> <code>None</code> <code>vi_method</code> <code>str</code> <p>This specifies the variational methods which are used to fit q to the posterior. We currently support [rKL, fKL, IW, alpha]. Note that some of the divergences are <code>mode seeking</code> i.e. they underestimate variance and collapse on multimodal targets (<code>rKL</code>, <code>alpha</code> for alpha &gt; 1) and some are <code>mass covering</code> i.e. they overestimate variance but typically cover all modes (<code>fKL</code>, <code>IW</code>, <code>alpha</code> for alpha &lt; 1).</p> <code>'rKL'</code> <code>device</code> <code>str</code> <p>Training device, e.g., <code>cpu</code>, <code>cuda</code> or <code>cuda:0</code>. We will ensure that all other objects are also on this device.</p> <code>'cpu'</code> <code>x_shape</code> <code>Optional[Size]</code> <p>Deprecated, should not be passed.</p> <code>None</code> <code>parameters</code> <code>Iterable</code> <p>List of parameters of the variational posterior. This is only required for user-defined q i.e. if q does not have a <code>parameters</code> attribute.</p> <code>[]</code> <code>modules</code> <code>Iterable</code> <p>List of modules of the variational posterior. This is only required for user-defined q i.e. if q does not have a <code>modules</code> attribute.</p> <code>[]</code> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def __init__(\n    self,\n    potential_fn: Union[Callable, BasePotential],\n    prior: Optional[TorchDistribution] = None,\n    q: Union[str, PyroTransformedDistribution, \"VIPosterior\", Callable] = \"maf\",\n    theta_transform: Optional[TorchTransform] = None,\n    vi_method: str = \"rKL\",\n    device: str = \"cpu\",\n    x_shape: Optional[torch.Size] = None,\n    parameters: Iterable = [],\n    modules: Iterable = [],\n):\n    \"\"\"\n    Args:\n        potential_fn: The potential function from which to draw samples. Must be a\n            `BasePotential` or a `Callable` which takes `theta` and `x_o` as inputs.\n        prior: This is the prior distribution. Note that this is only\n            used to check/construct the variational distribution or within some\n            quality metrics. Please make sure that this matches with the prior\n            within the potential_fn. If `None` is given, we will try to infer it\n            from potential_fn or q, if this fails we raise an Error.\n        q: Variational distribution, either string, `TransformedDistribution`, or a\n            `VIPosterior` object. This specifies a parametric class of distribution\n            over which the best possible posterior approximation is searched. For\n            string input, we currently support [nsf, scf, maf, mcf, gaussian,\n            gaussian_diag]. You can also specify your own variational family by\n            passing a pyro `TransformedDistribution`.\n            Additionally, we allow a `Callable`, which allows you the pass a\n            `builder` function, which if called returns a distribution. This may be\n            useful for setting the hyperparameters e.g. `num_transfroms` within the\n            `get_flow_builder` method specifying the number of transformations\n            within a normalizing flow. If q is already a `VIPosterior`, then the\n            arguments will be copied from it (relevant for multi-round training).\n        theta_transform: Maps form prior support to unconstrained space. The\n            inverse is used here to ensure that the posterior support is equal to\n            that of the prior.\n        vi_method: This specifies the variational methods which are used to fit q to\n            the posterior. We currently support [rKL, fKL, IW, alpha]. Note that\n            some of the divergences are `mode seeking` i.e. they underestimate\n            variance and collapse on multimodal targets (`rKL`, `alpha` for alpha &gt;\n            1) and some are `mass covering` i.e. they overestimate variance but\n            typically cover all modes (`fKL`, `IW`, `alpha` for alpha &lt; 1).\n        device: Training device, e.g., `cpu`, `cuda` or `cuda:0`. We will ensure\n            that all other objects are also on this device.\n        x_shape: Deprecated, should not be passed.\n        parameters: List of parameters of the variational posterior. This is only\n            required for user-defined q i.e. if q does not have a `parameters`\n            attribute.\n        modules: List of modules of the variational posterior. This is only\n            required for user-defined q i.e. if q does not have a `modules`\n            attribute.\n    \"\"\"\n    super().__init__(potential_fn, theta_transform, device, x_shape=x_shape)\n\n    # Especially the prior may be on another device -&gt; move it...\n    self._device = device\n    self.potential_fn.device = device\n    move_all_tensor_to_device(self.potential_fn, device)\n\n    # Get prior and previous builds\n    if prior is not None:\n        self._prior = prior\n    elif hasattr(self.potential_fn, \"prior\") and isinstance(\n        self.potential_fn.prior, Distribution\n    ):\n        self._prior = self.potential_fn.prior\n    elif isinstance(q, VIPosterior) and isinstance(q._prior, Distribution):\n        self._prior = q._prior\n    else:\n        raise ValueError(\n            \"We could not find a suitable prior distribution within `potential_fn` \"\n            \"or `q` (if a VIPosterior is given). Please explicitly specify a prior.\"\n        )\n    move_all_tensor_to_device(self._prior, device)\n    self._optimizer = None\n\n    # In contrast to MCMC we want to project into constrained space.\n    if theta_transform is None:\n        self.link_transform = mcmc_transform(self._prior).inv\n    else:\n        self.link_transform = theta_transform.inv\n\n    # This will set the variational distribution and VI method\n    self.set_q(q, parameters=parameters, modules=modules)\n    self.set_vi_method(vi_method)\n\n    self._purpose = (\n        \"It provides Variational inference to .sample() from the posterior and \"\n        \"can evaluate the _normalized_ posterior density with .log_prob().\"\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.__setstate__","title":"<code>__setstate__(state_dict)</code>","text":"<p>This method is called when unpickling the object.</p> <p>Especially, we need to restore the removed attributes and ensure that the object e.g. remains deep copy compatible.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>Dict</code> <p>Given state dictionary, we will restore the object from it.</p> required Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def __setstate__(self, state_dict: Dict):\n    \"\"\"This method is called when unpickling the object.\n\n    Especially, we need to restore the removed attributes and ensure that the object\n    e.g. remains deep copy compatible.\n\n    Args:\n        state_dict: Given state dictionary, we will restore the object from it.\n    \"\"\"\n    self.__dict__ = state_dict\n    q = deepcopy(self._q)\n    # Restore removed attributes\n    self.set_q(*self._q_arg)\n    self._q = q\n    make_object_deepcopy_compatible(self)\n    make_object_deepcopy_compatible(self.q)\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.evaluate","title":"<code>evaluate(quality_control_metric='psis', N=int(50000.0))</code>","text":"<p>This function will evaluate the quality of the variational posterior distribution. We currently support two different metrics of type <code>psis</code>, which checks the quality based on the tails of importance weights (there should not be much with a large one), or <code>prop</code> which checks the proportionality between q and potential_fn.</p> <p>NOTE: In our experience <code>prop</code> is sensitive to distinguish <code>good</code> from <code>ok</code> whereas <code>psis</code> is more sensitive in distinguishing <code>very bad</code> from <code>ok</code>.</p> <p>Parameters:</p> Name Type Description Default <code>quality_control_metric</code> <code>str</code> <p>The metric of choice, we currently support [psis, prop, prop_prior].</p> <code>'psis'</code> <code>N</code> <code>int</code> <p>Number of samples which is used to evaluate the metric.</p> <code>int(50000.0)</code> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def evaluate(self, quality_control_metric: str = \"psis\", N: int = int(5e4)) -&gt; None:\n    \"\"\"This function will evaluate the quality of the variational posterior\n    distribution. We currently support two different metrics of type `psis`, which\n    checks the quality based on the tails of importance weights (there should not be\n    much with a large one), or `prop` which checks the proportionality between q\n    and potential_fn.\n\n    NOTE: In our experience `prop` is sensitive to distinguish ``good`` from ``ok``\n    whereas `psis` is more sensitive in distinguishing `very bad` from `ok`.\n\n    Args:\n        quality_control_metric: The metric of choice, we currently support [psis,\n            prop, prop_prior].\n        N: Number of samples which is used to evaluate the metric.\n    \"\"\"\n    quality_control_fn, quality_control_msg = get_quality_metric(\n        quality_control_metric\n    )\n    metric = round(float(quality_control_fn(self, N=N)), 3)\n    print(f\"Quality Score: {metric} \" + quality_control_msg)\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.log_prob","title":"<code>log_prob(theta, x=None, track_gradients=False)</code>","text":"<p>Returns the log-probability of theta under the variational posterior.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>Tensor</code> <p>Parameters</p> required <code>track_gradients</code> <code>bool</code> <p>Whether the returned tensor supports tracking gradients. This can be helpful for e.g. sensitivity analysis but increases memory consumption.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tensor</code> <p><code>len($\\theta$)</code>-shaped log-probability.</p> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def log_prob(\n    self,\n    theta: Tensor,\n    x: Optional[Tensor] = None,\n    track_gradients: bool = False,\n) -&gt; Tensor:\n    r\"\"\"Returns the log-probability of theta under the variational posterior.\n\n    Args:\n        theta: Parameters\n        track_gradients: Whether the returned tensor supports tracking gradients.\n            This can be helpful for e.g. sensitivity analysis but increases memory\n            consumption.\n\n    Returns:\n        `len($\\theta$)`-shaped log-probability.\n    \"\"\"\n    x = self._x_else_default_x(x)\n    if self._trained_on is None or (x != self._trained_on).all():\n        raise AttributeError(\n            f\"The variational posterior was not fit using observation {x}.\\\n                 Please train.\"\n        )\n    with torch.set_grad_enabled(track_gradients):\n        theta = ensure_theta_batched(torch.as_tensor(theta))\n        return self.q.log_prob(theta)\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.map","title":"<code>map(x=None, num_iter=1000, num_to_optimize=100, learning_rate=0.01, init_method='proposal', num_init_samples=10000, save_best_every=10, show_progress_bars=False, force_update=False)</code>","text":"<p>Returns the maximum-a-posteriori estimate (MAP).</p> <p>The method can be interrupted (Ctrl-C) when the user sees that the log-probability converges. The best estimate will be saved in <code>self._map</code> and can be accessed with <code>self.map()</code>. The MAP is obtained by running gradient ascent from a given number of starting positions (samples from the posterior with the highest log-probability). After the optimization is done, we select the parameter set that has the highest log-probability after the optimization.</p> <p>Warning: The default values used by this function are not well-tested. They might require hand-tuning for the problem at hand.</p> <p>For developers: if the prior is a <code>BoxUniform</code>, we carry out the optimization in unbounded space and transform the result back into bounded space.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Optional[TorchTensor]</code> <p>Deprecated - use <code>.set_default_x()</code> prior to <code>.map()</code>.</p> <code>None</code> <code>num_iter</code> <code>int</code> <p>Number of optimization steps that the algorithm takes to find the MAP.</p> <code>1000</code> <code>learning_rate</code> <code>float</code> <p>Learning rate of the optimizer.</p> <code>0.01</code> <code>init_method</code> <code>Union[str, TorchTensor]</code> <p>How to select the starting parameters for the optimization. If it is a string, it can be either [<code>posterior</code>, <code>prior</code>], which samples the respective distribution <code>num_init_samples</code> times. If it is a tensor, the tensor will be used as init locations.</p> <code>'proposal'</code> <code>num_init_samples</code> <code>int</code> <p>Draw this number of samples from the posterior and evaluate the log-probability of all of them.</p> <code>10000</code> <code>num_to_optimize</code> <code>int</code> <p>From the drawn <code>num_init_samples</code>, use the <code>num_to_optimize</code> with highest log-probability as the initial points for the optimization.</p> <code>100</code> <code>save_best_every</code> <code>int</code> <p>The best log-probability is computed, saved in the <code>map</code>-attribute, and printed every <code>save_best_every</code>-th iteration. Computing the best log-probability creates a significant overhead (thus, the default is <code>10</code>.)</p> <code>10</code> <code>show_progress_bars</code> <code>bool</code> <p>Whether to show a progressbar during sampling from the posterior.</p> <code>False</code> <code>force_update</code> <code>bool</code> <p>Whether to re-calculate the MAP when x is unchanged and have a cached value.</p> <code>False</code> <code>log_prob_kwargs</code> <p>Will be empty for SNLE and SNRE. Will contain {\u2018norm_posterior\u2019: True} for SNPE.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>The MAP estimate.</p> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def map(\n    self,\n    x: Optional[TorchTensor] = None,\n    num_iter: int = 1_000,\n    num_to_optimize: int = 100,\n    learning_rate: float = 0.01,\n    init_method: Union[str, TorchTensor] = \"proposal\",\n    num_init_samples: int = 10_000,\n    save_best_every: int = 10,\n    show_progress_bars: bool = False,\n    force_update: bool = False,\n) -&gt; Tensor:\n    r\"\"\"Returns the maximum-a-posteriori estimate (MAP).\n\n    The method can be interrupted (Ctrl-C) when the user sees that the\n    log-probability converges. The best estimate will be saved in `self._map` and\n    can be accessed with `self.map()`. The MAP is obtained by running gradient\n    ascent from a given number of starting positions (samples from the posterior\n    with the highest log-probability). After the optimization is done, we select the\n    parameter set that has the highest log-probability after the optimization.\n\n    Warning: The default values used by this function are not well-tested. They\n    might require hand-tuning for the problem at hand.\n\n    For developers: if the prior is a `BoxUniform`, we carry out the optimization\n    in unbounded space and transform the result back into bounded space.\n\n    Args:\n        x: Deprecated - use `.set_default_x()` prior to `.map()`.\n        num_iter: Number of optimization steps that the algorithm takes\n            to find the MAP.\n        learning_rate: Learning rate of the optimizer.\n        init_method: How to select the starting parameters for the optimization. If\n            it is a string, it can be either [`posterior`, `prior`], which samples\n            the respective distribution `num_init_samples` times. If it is a\n            tensor, the tensor will be used as init locations.\n        num_init_samples: Draw this number of samples from the posterior and\n            evaluate the log-probability of all of them.\n        num_to_optimize: From the drawn `num_init_samples`, use the\n            `num_to_optimize` with highest log-probability as the initial points\n            for the optimization.\n        save_best_every: The best log-probability is computed, saved in the\n            `map`-attribute, and printed every `save_best_every`-th iteration.\n            Computing the best log-probability creates a significant overhead\n            (thus, the default is `10`.)\n        show_progress_bars: Whether to show a progressbar during sampling from\n            the posterior.\n        force_update: Whether to re-calculate the MAP when x is unchanged and\n            have a cached value.\n        log_prob_kwargs: Will be empty for SNLE and SNRE. Will contain\n            {'norm_posterior': True} for SNPE.\n\n    Returns:\n        The MAP estimate.\n    \"\"\"\n    self.proposal = self.q\n    return super().map(\n        x=x,\n        num_iter=num_iter,\n        num_to_optimize=num_to_optimize,\n        learning_rate=learning_rate,\n        init_method=init_method,\n        num_init_samples=num_init_samples,\n        save_best_every=save_best_every,\n        show_progress_bars=show_progress_bars,\n        force_update=force_update,\n    )\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.sample","title":"<code>sample(sample_shape=torch.Size(), x=None, **kwargs)</code>","text":"<p>Samples from the variational posterior distribution.</p> <p>Parameters:</p> Name Type Description Default <code>sample_shape</code> <code>Shape</code> <p>Shape of samples</p> <code>Size()</code> <p>Returns:</p> Type Description <code>Tensor</code> <p>Samples from posterior.</p> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def sample(\n    self,\n    sample_shape: Shape = torch.Size(),\n    x: Optional[Tensor] = None,\n    **kwargs,\n) -&gt; Tensor:\n    \"\"\"Samples from the variational posterior distribution.\n\n    Args:\n        sample_shape: Shape of samples\n\n    Returns:\n        Samples from posterior.\n    \"\"\"\n    x = self._x_else_default_x(x)\n    if self._trained_on is None or (x != self._trained_on).all():\n        raise AttributeError(\n            f\"The variational posterior was not fit on the specified `default_x` \"\n            f\"{x}. Please train using `posterior.train()`.\"\n        )\n    samples = self.q.sample(torch.Size(sample_shape))\n    return samples.reshape((*sample_shape, samples.shape[-1]))\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.set_q","title":"<code>set_q(q, parameters=[], modules=[])</code>","text":"<p>Defines the variational family.</p> <p>You can specify over which parameters/modules we optimize. This is required for custom distributions which e.g. do not inherit nn.Modules or has the function <code>parameters</code> or <code>modules</code> to give direct access to trainable parameters. Further, you can pass a function, which constructs a variational distribution if called.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Union[str, PyroTransformedDistribution, VIPosterior, Callable]</code> <p>Variational distribution, either string, distribution, or a VIPosterior object. This specifies a parametric class of distribution over which the best possible posterior approximation is searched. For string input, we currently support [nsf, scf, maf, mcf, gaussian, gaussian_diag]. Of course, you can also specify your own variational family by passing a <code>parameterized</code> distribution object i.e. a torch.distributions Distribution with methods <code>parameters</code> returning an iterable of all parameters (you can pass them within the paramters/modules attribute). Additionally, we allow a <code>Callable</code>, which allows you the pass a <code>builder</code> function, which if called returns an distribution. This may be useful for setting the hyperparameters e.g. <code>num_transfroms:int</code> by using the <code>get_flow_builder</code> method specifying the hyperparameters. If q is already a <code>VIPosterior</code>, then the arguments will be copied from it (relevant for multi-round training).</p> required <code>parameters</code> <code>Iterable</code> <p>List of parameters associated with the distribution object.</p> <code>[]</code> <code>modules</code> <code>Iterable</code> <p>List of modules associated with the distribution object.</p> <code>[]</code> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def set_q(\n    self,\n    q: Union[str, PyroTransformedDistribution, \"VIPosterior\", Callable],\n    parameters: Iterable = [],\n    modules: Iterable = [],\n) -&gt; None:\n    \"\"\"Defines the variational family.\n\n    You can specify over which parameters/modules we optimize. This is required for\n    custom distributions which e.g. do not inherit nn.Modules or has the function\n    `parameters` or `modules` to give direct access to trainable parameters.\n    Further, you can pass a function, which constructs a variational distribution\n    if called.\n\n    Args:\n        q: Variational distribution, either string, distribution, or a VIPosterior\n            object. This specifies a parametric class of distribution over which\n            the best possible posterior approximation is searched. For string input,\n            we currently support [nsf, scf, maf, mcf, gaussian, gaussian_diag]. Of\n            course, you can also specify your own variational family by passing a\n            `parameterized` distribution object i.e. a torch.distributions\n            Distribution with methods `parameters` returning an iterable of all\n            parameters (you can pass them within the paramters/modules attribute).\n            Additionally, we allow a `Callable`, which allows you the pass a\n            `builder` function, which if called returns an distribution. This may be\n            useful for setting the hyperparameters e.g. `num_transfroms:int` by\n            using the `get_flow_builder` method specifying the hyperparameters. If q\n            is already a `VIPosterior`, then the arguments will be copied from it\n            (relevant for multi-round training).\n        parameters: List of parameters associated with the distribution object.\n        modules: List of modules associated with the distribution object.\n\n    \"\"\"\n    self._q_arg = (q, parameters, modules)\n    if isinstance(q, Distribution):\n        q = adapt_variational_distribution(\n            q,\n            self._prior,\n            self.link_transform,\n            parameters=parameters,\n            modules=modules,\n        )\n        make_object_deepcopy_compatible(q)\n        self_custom_q_init_cache = deepcopy(q)\n        self._q_build_fn = lambda *args, **kwargs: self_custom_q_init_cache\n        self._trained_on = None\n    elif isinstance(q, (str, Callable)):\n        if isinstance(q, str):\n            self._q_build_fn = get_flow_builder(q)\n        else:\n            self._q_build_fn = q\n\n        q = self._q_build_fn(\n            self._prior.event_shape,\n            self.link_transform,\n            device=self._device,\n        )\n        make_object_deepcopy_compatible(q)\n        self._trained_on = None\n    elif isinstance(q, VIPosterior):\n        self._q_build_fn = q._q_build_fn\n        self._trained_on = q._trained_on\n        self.vi_method = q.vi_method  # type: ignore\n        self._device = q._device\n        self._prior = q._prior\n        self._x = q._x\n        self._q_arg = q._q_arg\n        make_object_deepcopy_compatible(q.q)\n        q = deepcopy(q.q)\n    move_all_tensor_to_device(q, self._device)\n    assert isinstance(\n        q, Distribution\n    ), \"\"\"Something went wrong when initializing the variational distribution.\n        Please create an issue on github https://github.com/mackelab/sbi/issues\"\"\"\n    check_variational_distribution(q, self._prior)\n    self._q = q\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.set_vi_method","title":"<code>set_vi_method(method)</code>","text":"<p>Sets variational inference method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>One of [rKL, fKL, IW, alpha].</p> required <p>Returns:</p> Type Description <code>VIPosterior</code> <p><code>VIPosterior</code> for chainable calls.</p> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def set_vi_method(self, method: str) -&gt; \"VIPosterior\":\n    \"\"\"Sets variational inference method.\n\n    Args:\n        method: One of [rKL, fKL, IW, alpha].\n\n    Returns:\n        `VIPosterior` for chainable calls.\n    \"\"\"\n    self._vi_method = method\n    self._optimizer_builder = get_VI_method(method)\n    return self\n</code></pre>"},{"location":"reference/posteriors/#sbi.inference.posteriors.vi_posterior.VIPosterior.train","title":"<code>train(x=None, n_particles=256, learning_rate=0.001, gamma=0.999, max_num_iters=2000, min_num_iters=10, clip_value=10.0, warm_up_rounds=100, retrain_from_scratch=False, reset_optimizer=False, show_progress_bar=True, check_for_convergence=True, quality_control=True, quality_control_metric='psis', **kwargs)</code>","text":"<p>This method trains the variational posterior.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Optional[TorchTensor]</code> <p>The observation.</p> <code>None</code> <code>n_particles</code> <code>int</code> <p>Number of samples to approximate expectations within the variational bounds. The larger the more accurate are gradient estimates, but the computational cost per iteration increases.</p> <code>256</code> <code>learning_rate</code> <code>float</code> <p>Learning rate of the optimizer.</p> <code>0.001</code> <code>gamma</code> <code>float</code> <p>Learning rate decay per iteration. We use an exponential decay scheduler.</p> <code>0.999</code> <code>max_num_iters</code> <code>int</code> <p>Maximum number of iterations.</p> <code>2000</code> <code>min_num_iters</code> <code>int</code> <p>Minimum number of iterations.</p> <code>10</code> <code>clip_value</code> <code>float</code> <p>Gradient clipping value, decreasing may help if you see invalid values.</p> <code>10.0</code> <code>warm_up_rounds</code> <code>int</code> <p>Initialize the posterior as the prior.</p> <code>100</code> <code>retrain_from_scratch</code> <code>bool</code> <p>Retrain the variational distributions from scratch.</p> <code>False</code> <code>reset_optimizer</code> <code>bool</code> <p>Reset the divergence optimizer</p> <code>False</code> <code>show_progress_bar</code> <code>bool</code> <p>If any progress report should be displayed.</p> <code>True</code> <code>quality_control</code> <code>bool</code> <p>If False quality control is skipped.</p> <code>True</code> <code>quality_control_metric</code> <code>str</code> <p>Which metric to use for evaluating the quality.</p> <code>'psis'</code> <code>kwargs</code> <p>Hyperparameters check corresponding <code>DivergenceOptimizer</code> for detail eps: Determines sensitivity of convergence check. retain_graph: Boolean which decides whether to retain the computation     graph. This may be required for some <code>exotic</code> user-specified q\u2019s. optimizer: A PyTorch Optimizer class e.g. Adam or SGD. See     <code>DivergenceOptimizer</code> for details. scheduler: A PyTorch learning rate scheduler. See     <code>DivergenceOptimizer</code> for details. alpha: Only used if vi_method=<code>alpha</code>. Determines the alpha divergence. K: Only used if vi_method=<code>IW</code>. Determines the number of importance     weighted particles. stick_the_landing: If one should use the STL estimator (only for rKL,     IW, alpha). dreg: If one should use the DREG estimator (only for rKL, IW, alpha). weight_transform: Callable applied to importance weights (only for fKL)</p> <code>{}</code> <p>Returns:     VIPosterior: <code>VIPosterior</code> (can be used to chain calls).</p> Source code in <code>sbi/inference/posteriors/vi_posterior.py</code> <pre><code>def train(\n    self,\n    x: Optional[TorchTensor] = None,\n    n_particles: int = 256,\n    learning_rate: float = 1e-3,\n    gamma: float = 0.999,\n    max_num_iters: int = 2000,\n    min_num_iters: int = 10,\n    clip_value: float = 10.0,\n    warm_up_rounds: int = 100,\n    retrain_from_scratch: bool = False,\n    reset_optimizer: bool = False,\n    show_progress_bar: bool = True,\n    check_for_convergence: bool = True,\n    quality_control: bool = True,\n    quality_control_metric: str = \"psis\",\n    **kwargs,\n) -&gt; \"VIPosterior\":\n    \"\"\"This method trains the variational posterior.\n\n    Args:\n        x: The observation.\n        n_particles: Number of samples to approximate expectations within the\n            variational bounds. The larger the more accurate are gradient\n            estimates, but the computational cost per iteration increases.\n        learning_rate: Learning rate of the optimizer.\n        gamma: Learning rate decay per iteration. We use an exponential decay\n            scheduler.\n        max_num_iters: Maximum number of iterations.\n        min_num_iters: Minimum number of iterations.\n        clip_value: Gradient clipping value, decreasing may help if you see invalid\n            values.\n        warm_up_rounds: Initialize the posterior as the prior.\n        retrain_from_scratch: Retrain the variational distributions from scratch.\n        reset_optimizer: Reset the divergence optimizer\n        show_progress_bar: If any progress report should be displayed.\n        quality_control: If False quality control is skipped.\n        quality_control_metric: Which metric to use for evaluating the quality.\n        kwargs: Hyperparameters check corresponding `DivergenceOptimizer` for detail\n            eps: Determines sensitivity of convergence check.\n            retain_graph: Boolean which decides whether to retain the computation\n                graph. This may be required for some `exotic` user-specified q's.\n            optimizer: A PyTorch Optimizer class e.g. Adam or SGD. See\n                `DivergenceOptimizer` for details.\n            scheduler: A PyTorch learning rate scheduler. See\n                `DivergenceOptimizer` for details.\n            alpha: Only used if vi_method=`alpha`. Determines the alpha divergence.\n            K: Only used if vi_method=`IW`. Determines the number of importance\n                weighted particles.\n            stick_the_landing: If one should use the STL estimator (only for rKL,\n                IW, alpha).\n            dreg: If one should use the DREG estimator (only for rKL, IW, alpha).\n            weight_transform: Callable applied to importance weights (only for fKL)\n    Returns:\n        VIPosterior: `VIPosterior` (can be used to chain calls).\n    \"\"\"\n    # Update optimizer with current arguments.\n    if self._optimizer is not None:\n        self._optimizer.update({**locals(), **kwargs})\n\n    # Init q and the optimizer if necessary\n    if retrain_from_scratch:\n        self.q = self._q_build_fn()  # type: ignore\n        self._optimizer = self._optimizer_builder(\n            self.potential_fn,\n            self.q,\n            lr=learning_rate,\n            clip_value=clip_value,\n            gamma=gamma,\n            n_particles=n_particles,\n            prior=self._prior,\n            **kwargs,\n        )\n\n    if (\n        reset_optimizer\n        or self._optimizer is None\n        or not isinstance(self._optimizer, self._optimizer_builder)\n    ):\n        self._optimizer = self._optimizer_builder(\n            self.potential_fn,\n            self.q,\n            lr=learning_rate,\n            clip_value=clip_value,\n            gamma=gamma,\n            n_particles=n_particles,\n            prior=self._prior,\n            **kwargs,\n        )\n\n    # Check context\n    x = atleast_2d_float32_tensor(self._x_else_default_x(x)).to(  # type: ignore\n        self._device\n    )\n\n    already_trained = self._trained_on is not None and (x == self._trained_on).all()\n\n    # Optimize\n    optimizer = self._optimizer\n    optimizer.to(self._device)\n    optimizer.reset_loss_stats()\n\n    if show_progress_bar:\n        iters = tqdm(range(max_num_iters))\n    else:\n        iters = range(max_num_iters)\n\n    # Warmup before training\n    if reset_optimizer or (not optimizer.warm_up_was_done and not already_trained):\n        if show_progress_bar:\n            iters.set_description(  # type: ignore\n                \"Warmup phase, this may take a few seconds...\"\n            )\n        optimizer.warm_up(warm_up_rounds)\n\n    for i in iters:\n        optimizer.step(x)\n        mean_loss, std_loss = optimizer.get_loss_stats()\n        # Update progress bar\n        if show_progress_bar:\n            assert isinstance(iters, tqdm)\n            iters.set_description(  # type: ignore\n                f\"Loss: {np.round(float(mean_loss), 2)}\"\n                f\"Std: {np.round(float(std_loss), 2)}\"\n            )\n        # Check for convergence\n        if check_for_convergence and i &gt; min_num_iters and optimizer.converged():\n            if show_progress_bar:\n                print(f\"\\nConverged with loss: {np.round(float(mean_loss), 2)}\")\n            break\n    # Training finished:\n    self._trained_on = x\n\n    # Evaluate quality\n    if quality_control:\n        try:\n            self.evaluate(quality_control_metric=quality_control_metric)\n        except Exception as e:\n            print(\n                f\"Quality control showed a low quality of the variational \"\n                f\"posterior. We are automatically retraining the variational \"\n                f\"posterior from scratch with a smaller learning rate. \"\n                f\"Alternatively, if you want to skip quality control, please \"\n                f\"retrain with `VIPosterior.train(..., quality_control=False)`. \"\n                f\"\\nThe error that occured is: {e}\"\n            )\n            self.train(\n                learning_rate=learning_rate * 0.1,\n                retrain_from_scratch=True,\n                reset_optimizer=True,\n            )\n\n    return self\n</code></pre>"},{"location":"reference/potentials/","title":"Potentials","text":""},{"location":"reference/potentials/#sbi.inference.potentials.posterior_based_potential.posterior_estimator_based_potential","title":"<code>posterior_estimator_based_potential(posterior_estimator, prior, x_o, enable_transform=True)</code>","text":"<p>Returns the potential for posterior-based methods.</p> <p>It also returns a transformation that can be used to transform the potential into unconstrained space.</p> <p>The potential is the same as the log-probability of the <code>posterior_estimator</code>, but it is set to \\(-\\inf\\) outside of the prior bounds.</p> <p>Parameters:</p> Name Type Description Default <code>posterior_estimator</code> <code>ConditionalDensityEstimator</code> <p>The neural network modelling the posterior.</p> required <code>prior</code> <code>Distribution</code> <p>The prior distribution.</p> required <code>x_o</code> <code>Optional[Tensor]</code> <p>The observed data at which to evaluate the posterior.</p> required <code>enable_transform</code> <code>bool</code> <p>Whether to transform parameters to unconstrained space. When False, an identity transform will be returned for <code>theta_transform</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>PosteriorBasedPotential</code> <p>The potential function and a transformation that maps</p> <code>TorchTransform</code> <p>to unconstrained space.</p> Source code in <code>sbi/inference/potentials/posterior_based_potential.py</code> <pre><code>def posterior_estimator_based_potential(\n    posterior_estimator: ConditionalDensityEstimator,\n    prior: Distribution,\n    x_o: Optional[Tensor],\n    enable_transform: bool = True,\n) -&gt; Tuple[PosteriorBasedPotential, TorchTransform]:\n    r\"\"\"Returns the potential for posterior-based methods.\n\n    It also returns a transformation that can be used to transform the potential into\n    unconstrained space.\n\n    The potential is the same as the log-probability of the `posterior_estimator`, but\n    it is set to $-\\inf$ outside of the prior bounds.\n\n    Args:\n        posterior_estimator: The neural network modelling the posterior.\n        prior: The prior distribution.\n        x_o: The observed data at which to evaluate the posterior.\n        enable_transform: Whether to transform parameters to unconstrained space.\n            When False, an identity transform will be returned for `theta_transform`.\n\n    Returns:\n        The potential function and a transformation that maps\n        to unconstrained space.\n    \"\"\"\n\n    device = str(next(posterior_estimator.parameters()).device)\n\n    potential_fn = PosteriorBasedPotential(\n        posterior_estimator, prior, x_o, device=device\n    )\n\n    theta_transform = mcmc_transform(\n        prior, device=device, enable_transform=enable_transform\n    )\n\n    return potential_fn, theta_transform\n</code></pre>"},{"location":"reference/potentials/#sbi.inference.potentials.likelihood_based_potential.likelihood_estimator_based_potential","title":"<code>likelihood_estimator_based_potential(likelihood_estimator, prior, x_o, enable_transform=True)</code>","text":"<p>Returns potential \\(\\log(p(x_o|\\theta)p(\\theta))\\) for likelihood-based methods.</p> <p>It also returns a transformation that can be used to transform the potential into unconstrained space.</p> <p>Parameters:</p> Name Type Description Default <code>likelihood_estimator</code> <code>ConditionalDensityEstimator</code> <p>The density estimator modelling the likelihood.</p> required <code>prior</code> <code>Distribution</code> <p>The prior distribution.</p> required <code>x_o</code> <code>Optional[Tensor]</code> <p>The observed data at which to evaluate the likelihood.</p> required <code>enable_transform</code> <code>bool</code> <p>Whether to transform parameters to unconstrained space.  When False, an identity transform will be returned for <code>theta_transform</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The potential function \\(p(x_o|\\theta)p(\\theta)\\) and a transformation that maps</p> <code>TorchTransform</code> <p>to unconstrained space.</p> Source code in <code>sbi/inference/potentials/likelihood_based_potential.py</code> <pre><code>def likelihood_estimator_based_potential(\n    likelihood_estimator: ConditionalDensityEstimator,\n    prior: Distribution,\n    x_o: Optional[Tensor],\n    enable_transform: bool = True,\n) -&gt; Tuple[Callable, TorchTransform]:\n    r\"\"\"Returns potential $\\log(p(x_o|\\theta)p(\\theta))$ for likelihood-based methods.\n\n    It also returns a transformation that can be used to transform the potential into\n    unconstrained space.\n\n    Args:\n        likelihood_estimator: The density estimator modelling the likelihood.\n        prior: The prior distribution.\n        x_o: The observed data at which to evaluate the likelihood.\n        enable_transform: Whether to transform parameters to unconstrained space.\n             When False, an identity transform will be returned for `theta_transform`.\n\n    Returns:\n        The potential function $p(x_o|\\theta)p(\\theta)$ and a transformation that maps\n        to unconstrained space.\n    \"\"\"\n\n    device = str(next(likelihood_estimator.parameters()).device)\n\n    potential_fn = LikelihoodBasedPotential(\n        likelihood_estimator, prior, x_o, device=device\n    )\n    theta_transform = mcmc_transform(\n        prior, device=device, enable_transform=enable_transform\n    )\n\n    return potential_fn, theta_transform\n</code></pre>"},{"location":"reference/potentials/#sbi.inference.potentials.ratio_based_potential.ratio_estimator_based_potential","title":"<code>ratio_estimator_based_potential(ratio_estimator, prior, x_o, enable_transform=True)</code>","text":"<p>Returns the potential for ratio-based methods.</p> <p>It also returns a transformation that can be used to transform the potential into unconstrained space.</p> <p>Parameters:</p> Name Type Description Default <code>ratio_estimator</code> <code>Module</code> <p>The neural network modelling likelihood-to-evidence ratio.</p> required <code>prior</code> <code>Distribution</code> <p>The prior distribution.</p> required <code>x_o</code> <code>Optional[Tensor]</code> <p>The observed data at which to evaluate the likelihood-to-evidence ratio.</p> required <code>enable_transform</code> <code>bool</code> <p>Whether to transform parameters to unconstrained space. When False, an identity transform will be returned for <code>theta_transform</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The potential function and a transformation that maps</p> <code>TorchTransform</code> <p>to unconstrained space.</p> Source code in <code>sbi/inference/potentials/ratio_based_potential.py</code> <pre><code>def ratio_estimator_based_potential(\n    ratio_estimator: nn.Module,\n    prior: Distribution,\n    x_o: Optional[Tensor],\n    enable_transform: bool = True,\n) -&gt; Tuple[Callable, TorchTransform]:\n    r\"\"\"Returns the potential for ratio-based methods.\n\n    It also returns a transformation that can be used to transform the potential into\n    unconstrained space.\n\n    Args:\n        ratio_estimator: The neural network modelling likelihood-to-evidence ratio.\n        prior: The prior distribution.\n        x_o: The observed data at which to evaluate the likelihood-to-evidence ratio.\n        enable_transform: Whether to transform parameters to unconstrained space.\n            When False, an identity transform will be returned for `theta_transform`.\n\n    Returns:\n        The potential function and a transformation that maps\n        to unconstrained space.\n    \"\"\"\n\n    device = str(next(ratio_estimator.parameters()).device)\n\n    potential_fn = RatioBasedPotential(ratio_estimator, prior, x_o, device=device)\n    theta_transform = mcmc_transform(\n        prior, device=device, enable_transform=enable_transform\n    )\n\n    return potential_fn, theta_transform\n</code></pre>"},{"location":"reference/potentials/#sbi.inference.potentials.score_based_potential.score_estimator_based_potential","title":"<code>score_estimator_based_potential(score_estimator, prior, x_o, enable_transform=False)</code>","text":"<p>Returns the potential function gradient for score estimators.</p> <p>Parameters:</p> Name Type Description Default <code>score_estimator</code> <code>ConditionalScoreEstimator</code> <p>The neural network modelling the score.</p> required <code>prior</code> <code>Optional[Distribution]</code> <p>The prior distribution.</p> required <code>x_o</code> <code>Optional[Tensor]</code> <p>The observed data at which to evaluate the score.</p> required <code>enable_transform</code> <code>bool</code> <p>Whether to enable transforms. Not supported yet.</p> <code>False</code> Source code in <code>sbi/inference/potentials/score_based_potential.py</code> <pre><code>def score_estimator_based_potential(\n    score_estimator: ConditionalScoreEstimator,\n    prior: Optional[Distribution],\n    x_o: Optional[Tensor],\n    enable_transform: bool = False,\n) -&gt; Tuple[\"PosteriorScoreBasedPotential\", TorchTransform]:\n    r\"\"\"Returns the potential function gradient for score estimators.\n\n    Args:\n        score_estimator: The neural network modelling the score.\n        prior: The prior distribution.\n        x_o: The observed data at which to evaluate the score.\n        enable_transform: Whether to enable transforms. Not supported yet.\n    \"\"\"\n    device = str(next(score_estimator.parameters()).device)\n\n    potential_fn = PosteriorScoreBasedPotential(\n        score_estimator, prior, x_o, device=device\n    )\n\n    assert (\n        enable_transform is False\n    ), \"Transforms are not yet supported for score estimators.\"\n\n    if prior is not None:\n        theta_transform = mcmc_transform(\n            prior, device=device, enable_transform=enable_transform\n        )\n    else:\n        theta_transform = torch.distributions.transforms.identity_transform\n\n    return potential_fn, theta_transform\n</code></pre>"},{"location":"tutorials/","title":"Tutorials for using the <code>sbi</code> toolbox","text":"<p>Before running the notebooks, follow our instructions to install sbi. Alternatively, you can also open a codespace on GitHub and work through the tutorials in the browser. The numbers of the notebooks are not informative of the order, please follow this structure depending on which group you identify with.</p> <p>Once you have familiarised yourself with the methods and identified how to apply SBI to your use case, ensure you work through the Diagnostics tutorials linked below, to identify failure cases and assess the quality of your inference.</p>"},{"location":"tutorials/#introduction","title":"Introduction","text":"<ul> <li>Getting started</li> <li>Amortized inference</li> <li>More flexibility for training and sampling</li> <li>Implemented algorithms</li> </ul>"},{"location":"tutorials/#advanced","title":"Advanced","text":"<ul> <li>Multi-round inference</li> <li>Sampling algorithms in sbi</li> <li>Custom density estimators</li> <li>Embedding nets for observations</li> <li>SBI with trial-based data</li> <li>Handling invalid simulations</li> <li>Crafting summary statistics</li> <li>Importance sampling posteriors</li> </ul>"},{"location":"tutorials/#diagnostics","title":"Diagnostics","text":"<ul> <li>Posterior predictive checks</li> <li>Simulation-based calibration</li> <li>Local-C2ST coverage checks</li> <li>Density plots and MCMC diagnostics with ArviZ</li> </ul>"},{"location":"tutorials/#analysis","title":"Analysis","text":"<ul> <li>Conditional distributions</li> <li>Posterior sensitivity analysis</li> <li>Plotting functionality</li> </ul>"},{"location":"tutorials/#examples","title":"Examples","text":"<ul> <li>Hodgkin-Huxley model</li> <li>Decision-making model</li> </ul>"},{"location":"tutorials/00_getting_started/","title":"Getting started with <code>sbi</code>","text":"<p>Note, you can find the original version of this notebook at /tutorials/00_getting_started.ipynb in the <code>sbi</code> repository.</p> <p><code>sbi</code> provides a simple interface to run state-of-the-art algorithms for simulation-based inference.</p> <p>The overall goal of simulation-based inference is to algorithmically identify model parameters which are consistent with data.</p> <p>In this tutorial we demonstrate how to get started with the <code>sbi</code> toolbox and how to perform parameter inference on a simple model.</p> <pre><code>import torch\n\nfrom sbi.analysis import pairplot\nfrom sbi.inference import NPE\nfrom sbi.utils import BoxUniform\nfrom sbi.utils.user_input_checks import (\n    check_sbi_inputs,\n    process_prior,\n    process_simulator,\n)\n</code></pre>"},{"location":"tutorials/00_getting_started/#parameter-inference-in-a-linear-gaussian-example","title":"Parameter inference in a linear Gaussian example","text":"<p>Each of the implemented inference methods takes three inputs: 1. observational data (or summary statistics thereof) - the observations 2. a candidate (mechanistic) model - the simulator 3. prior knowledge or constraints on model parameters - the prior</p> <p>If you are new to simulation-based inference, please first read the information on the homepage of the website to familiarise with the motivation and relevant terms.</p> <p>For this illustrative example we consider a model simulator that takes in 3 parameters (\\(\\theta\\)). For simplicity, the simulator outputs simulations of the same dimensionality and adds 1.0 and some Gaussian noise to the parameter set. </p> <p>Note: This is where you instead would use your specific  simulator with its parameters.</p> <p>For the 3-dimensional parameter space we consider a uniform prior between [-2,2].</p> <p>Note: This is where you would incorporate prior knowlegde about the parameters you want to infer, e.g., ranges known from literature. </p> <pre><code>num_dim = 3\n\ndef simulator(theta):\n    # linear gaussian\n    return theta + 1.0 + torch.randn_like(theta) * 0.1\n\nprior = BoxUniform(low=-2 * torch.ones(num_dim), high=2 * torch.ones(num_dim))\n</code></pre> <p>Here, we are using this simple toy simulator. In practice, the simulator can be anything that takes parameters and returns simulated data. The data simulation process is decoupled from the algorithms implemented in the <code>sbi</code> package. That is, you can simulate your data beforehand, e.g., on a cluster or using a different programming language or environment. All that <code>sbi</code> needs is a <code>Tensor</code> of parameters <code>theta</code> and corresponding simulated data <code>x</code>. And, of course, observed data <code>x_o</code>. </p> <p>However, <code>sbi</code> also offers a function to run your simulations in parallel. To that end, we have to ensure that your simulator and prior adhere to the requirements of <code>sbi</code> such as returning <code>torch.Tensor</code>s in a standardised shape. </p> <p>You can do so with the <code>process_simulator()</code> and <code>process_prior()</code> functions, which prepare them appropriately. Finally, you can call <code>check_sbi_input()</code> to make sure they are consistent which each other.</p> <pre><code># Check prior, return PyTorch prior.\nprior, num_parameters, prior_returns_numpy = process_prior(prior)\n\n# Check simulator, returns PyTorch simulator able to simulate batches.\nsimulator = process_simulator(simulator, prior, prior_returns_numpy)\n\n# Consistency check after making ready for sbi.\ncheck_sbi_inputs(simulator, prior)\n</code></pre> <p>Next, we instantiate the inference object. In this example, we will use neural perform posterior estimation (NPE):</p> <p>Note: In <code>sbi</code> version 0.23.0, we renamed all inference classes from, e.g., <code>SNPE</code>, to <code>NPE</code> (i.e., we removed the <code>S</code> prefix). The functionality of the classes remains the same. The <code>NPE</code> class handles both the amortized (as shown in this tutorial) and sequential (as shown here) versions of neural posterior estimation. An alias for <code>SNPE</code> still exists for backwards compatibility.</p> <p>Note: This is where you could specify an alternative inference object such as NRE for ratio estimation or NLE for likelihood estimation. Here, you can see all implemented methods.</p> <pre><code>inference = NPE(prior=prior)\n</code></pre> <p>Next, we need simulations, or more specifically, pairs of parameters \\(\\theta\\) which we sample from the prior and corresponding simulations \\(x = \\mathrm{simulator} (\\theta)\\). The <code>sbi</code> helper function called <code>simulate_for_sbi</code> allows to parallelize your code with <code>joblib</code>.</p> <p>Note: If you already have your own parameters, simulation pairs which were generated elsewhere (e.g., on a compute cluster), you would add them here.  </p> <pre><code>num_simulations = 2000\ntheta = prior.sample((num_simulations,))\nx = simulator(theta)\nprint(\"theta.shape\", theta.shape)\nprint(\"x.shape\", x.shape)\n</code></pre> <pre><code>theta.shape torch.Size([2000, 3])\nx.shape torch.Size([2000, 3])\n</code></pre> <p>We then pass the simulated data to the inference object. Both <code>theta</code> and <code>x</code> should be a <code>torch.Tensor</code> of type <code>float32</code>.</p> <pre><code>inference = inference.append_simulations(theta, x)\n</code></pre> <p>Next, we train the neural density estimator to learn the association between the simulated data (or data features) and the underlying parameters:</p> <pre><code>density_estimator = inference.train()\n</code></pre> <pre><code> Neural network successfully converged after 255 epochs.\n</code></pre> <p>Finally, we use this density estimator to build the posterior distribution \\(p(\\theta|x)\\), i.e., the distributions over paramters \\(\\theta\\) given observation \\(x\\). </p> <p>The <code>posterior</code> can then be used to (among other features which go beyond the scope of this introductory tutorial) sample parameters \\(\\theta\\) from the posterior via <code>.sample()</code>, i.e., parameters that are likely given the observation \\(x\\). </p> <p>We can also get log-probabilities under the posterior via <code>.log_prob()</code>, i.e., we can evaluate the likelihood of parameters \\(\\theta\\) given the observation \\(x\\). </p> <pre><code>posterior = inference.build_posterior(density_estimator)\n\nprint(posterior) # prints how the posterior was trained\n</code></pre> <pre><code>Posterior p(\u03b8|x) of type DirectPosterior. It samples the posterior network and rejects samples that\n            lie outside of the prior bounds.\n</code></pre>"},{"location":"tutorials/00_getting_started/#visualisations-of-the-inferred-posterior-for-a-new-observation","title":"Visualisations of the inferred posterior for a new observation","text":"<p>Let\u2019s say we have made some observation \\(x_{obs}\\) for which we now want to infer the posterior:</p> <p>Note: this is where your experimental observation would come in. For real observations, of course, you would not have access to the ground truth \\(\\theta\\). </p> <pre><code>theta_true = prior.sample((1,))\n# generate our observation\nx_obs = simulator(theta_true)\n</code></pre> <p>Given this observation, we can sample from the posterior \\(p(\\theta|x_{obs})\\) and visualise the posterior. Visualizing a three-dimensional distributions is challenging. Therefore, we use <code>sbi</code>\u2019s <code>pairplot</code> function that generates a upper triangular grid of plots, showing the univariate marginals on the diagnonal and every combination of pairwise marginals for the three parameters on the upper offdiagonal:</p> <pre><code>samples = posterior.sample((10000,), x=x_obs)\n_ = pairplot(samples,\n             limits=[[-2, 2], [-2, 2], [-2, 2]],\n             figsize=(6, 6),\n             labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"])\n</code></pre> <p></p>"},{"location":"tutorials/00_getting_started/#assessing-the-posterior-for-the-known-theta-x-pair","title":"Assessing the posterior for the known (\\(\\theta, x\\)) - pair","text":"<p>For this special case, we have access to the ground-truth parameters that generated the observation. We can thus assess if the inferred distributions over the parameters match the parameters \\(\\theta_{true}\\) we used to generate our test observation \\(x_{obs}\\).</p> <p>Note that in general, the inferred posterior distribution is not neccessarily centered on the underlying \u201cground-truth\u201d parameters \\(\\theta\\) because there is noise in simulator and limited data. However, it should lie \u201cwithin\u201d the posterior.</p> <pre><code>samples = posterior.sample((10000,), x=x_obs)\npairplot(samples,\n         points=theta_true,\n         limits=[[-2, 2], [-2, 2], [-2, 2]], figsize=(6, 6),\n         labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"]);\n</code></pre> <p></p>"},{"location":"tutorials/00_getting_started/#assessing-the-predictive-performance-of-the-posterior","title":"Assessing the predictive performance of the posterior","text":"<p>Another way to assess the quality of the posterior is checking whether parameters sampled from the posterior \\(p(\\theta \\mid x_{obs})\\) can reproduce the observation \\(x_{obs}\\) when we simulate data with them. This posterior predictive distribution should contain on the \\(x_{obs}\\). We can again use the <code>pairplot</code> function to visualize it. </p> <p>As you can see below, in this Gaussian toy example, the posterior predictive distribution is nicely centered on the data it was conditioned on.</p> <pre><code>theta_posterior = posterior.sample((10000,), x=x_obs)  # sample from posterior\nx_predictive = simulator(theta_posterior)  # simulate data from posterior\npairplot(x_predictive,\n         points=x_obs,  # plot with x_obs as a point\n         figsize=(6, 6),\n         labels=[r\"$x_1$\", r\"$x_2$\", r\"$x_3$\"]);\n</code></pre> <p></p> <p>Finally, we can also compare the probabilities of different parameters under the posterior. The log-probability should ideally indicate that the true parameters, given the corresponding observation, are more likely than a different set of randomly chosen parameters from the prior distribution. </p> <p>Relative to the obtained log-probabilities, we can investigate the range of log-probabilities of the parameters sampled from the posterior.</p> <pre><code># first sample an alternative parameter set from the prior\ntheta_diff = prior.sample((1,))\n</code></pre> <pre><code>log_probability_true_theta = posterior.log_prob(theta_true, x=x_obs)\nlog_probability_diff_theta = posterior.log_prob(theta_diff, x=x_obs)\nlog_probability_samples = posterior.log_prob(samples, x=x_obs)\n\nprint( r'high for true theta :', log_probability_true_theta)\nprint( r'low for different theta :', log_probability_diff_theta)\nprint( r'range of posterior samples: min:', torch.min(log_probability_samples),' max :', torch.max(log_probability_samples))\n</code></pre> <pre><code>high for true theta : tensor([3.4911])\nlow for different theta : tensor([-351.0345])\nrange of posterior samples: min: tensor(-8.8757)  max : tensor(3.9791)\n</code></pre>"},{"location":"tutorials/00_getting_started/#next-steps","title":"Next steps","text":"<p>To learn more about the capabilities of <code>sbi</code>, you can head over to the tutorial 01_gaussian_amortized, for inferring parameters for multiple observations without retraining.</p> <p>Alternatively, for an example with an actual simulator, you can read our example for a scientific simulator from neuroscience under Example_00_HodgkinHuxleyModel.</p>"},{"location":"tutorials/01_gaussian_amortized/","title":"Amortized posterior inference on Gaussian example","text":"<p>Note, you can find the original version of this notebook at tutorials/01_gaussian_amortized.ipynb in the <code>sbi</code> repository.</p> <p>In this tutorial, we introduce amortization that is the capability to evaluate the posterior for different observations without having to re-run inference.</p> <p>We will demonstrate how <code>sbi</code> can infer an amortized posterior for the illustrative linear Gaussian example introduced in Getting Started, that takes in 3 parameters (\\(\\theta\\)). </p> <pre><code>import torch\n\nfrom sbi import analysis as analysis\nfrom sbi import utils as utils\nfrom sbi.inference import NPE, simulate_for_sbi\nfrom sbi.utils.user_input_checks import (\n    check_sbi_inputs,\n    process_prior,\n    process_simulator,\n)\n</code></pre>"},{"location":"tutorials/01_gaussian_amortized/#defining-simulator-prior-and-running-inference","title":"Defining simulator, prior, and running inference","text":"<p>Our  simulator (model) takes in 3 parameters (\\(\\theta\\)) and outputs simulations of the same dimensionality. It adds 1.0 and some Gaussian noise to the parameter set. For each dimension of \\(\\theta\\), we consider a uniform prior between [-2,2].</p> <pre><code>num_dim = 3\nprior = utils.BoxUniform(low=-2 * torch.ones(num_dim), high=2 * torch.ones(num_dim))\n\ndef simulator(theta):\n    # linear gaussian\n    return theta + 1.0 + torch.randn_like(theta) * 0.1\n\n# Check prior, simulator, consistency\nprior, num_parameters, prior_returns_numpy = process_prior(prior)\nsimulator = process_simulator(simulator, prior, prior_returns_numpy)\ncheck_sbi_inputs(simulator, prior)\n</code></pre> <pre><code># Create inference object. Here, NPE is used.\ninference = NPE(prior=prior)\n\n# generate simulations and pass to the inference object\ntheta, x = simulate_for_sbi(simulator, proposal=prior, num_simulations=2000)\ninference = inference.append_simulations(theta, x)\n\n# train the density estimator and build the posterior\ndensity_estimator = inference.train()\nposterior = inference.build_posterior(density_estimator)\n</code></pre> <pre><code> Neural network successfully converged after 68 epochs.\n</code></pre>"},{"location":"tutorials/01_gaussian_amortized/#amortized-inference","title":"Amortized inference","text":"<p>Note that we have not yet provided an observation to the inference procedure. In fact, we can evaluate the posterior for different observations without having to re-run inference. This is called amortization. An amortized posterior is one that is not focused on any particular observation. Naturally, if the diversity of observations is large, any of the inference methods will need to run a sufficient number of simulations for the resulting posterior to perform well across these diverse observations.</p> <p>Let\u2019s say we have not just one but two observations \\(x_{obs~1}\\) and \\(x_{obs~2}\\) for which we aim to do parameter inference. </p> <p>Note: For real observations, of course, you would not have access to the ground truth \\(\\theta\\).</p> <pre><code># generate the first observation\ntheta_1 = prior.sample((1,))\nx_obs_1 = simulator(theta_1)\n# now generate a second observation\ntheta_2 = prior.sample((1,))\nx_obs_2 = simulator(theta_2)\n</code></pre> <p>We can draw samples from the posterior given \\(x_{obs~1}\\) and then plot them:</p> <pre><code>posterior_samples_1 = posterior.sample((10000,), x=x_obs_1)\n\n# plot posterior samples\n_ = analysis.pairplot(\n    posterior_samples_1, limits=[[-2, 2], [-2, 2], [-2, 2]], figsize=(5, 5),\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n    points=theta_1 # add ground truth thetas\n)\n</code></pre> <p></p> <p>The inferred distirbutions over the parameters given the first observation \\(x_{obs~1}\\) match the parameters \\(\\theta_{1}\\) (shown in orange), we used to generate our first observation \\(x_{obs~1}\\).</p> <p>Since the learned posterior is amortized, we can also draw samples from the posterior given the second observation \\(x_{obs~2}\\) without having to re-run inference:</p> <pre><code>posterior_samples_2 = posterior.sample((10000,), x=x_obs_2)\n\n# plot posterior samples\n_ = analysis.pairplot(\n    posterior_samples_2, limits=[[-2, 2], [-2, 2], [-2, 2]], figsize=(5, 5),\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n    points=theta_2 # add ground truth thetas\n)\n</code></pre> <p></p> <p>The inferred distirbutions over the parameters given the second observation  \\(x_{obs~2}\\) also match the ground truth parameters \\(\\theta_{2}\\) we used to generate our second test observation  \\(x_{obs~2}\\).</p> <p>This in a nutshell demonstrates the benefit of amortized methods. </p>"},{"location":"tutorials/01_gaussian_amortized/#next-steps","title":"Next steps","text":"<p>Now that you got familiar with amortization and are probably good to go and have a first shot at applying <code>sbi</code> to your own inference problem. If you want to learn more, we recommend checking out our tutorial 02_multiround_inference which aims to make inference for a single observation more sampling efficient.</p>"},{"location":"tutorials/02_multiround_inference/","title":"Multi-round inference","text":"<p>In the previous tutorials, we have inferred the posterior using single-round inference. In single-round inference, we draw parameters from the prior, simulate the corresponding data, and then train a neural network to obtain the posterior. However, if one is interested in only one particular observation <code>x_o</code> sampling from the prior can be inefficient in the number of simulations because one is effectively learning a posterior estimate for all observations in the prior space. In this tutorial, we show how one can alleviate this issue by performing multi-round inference with <code>sbi</code>.</p> <p>Multi-round inference also starts by drawing parameters from the prior, simulating them, and training a neural network to estimate the posterior distribution. Afterwards, however, it continues inference in multiple rounds, focusing on a particular observation <code>x_o</code>. In each new round of inference, it draws samples from the obtained posterior distribution conditioned at <code>x_o</code> (instead of from the prior), simulates these, and trains the network again. This process can be repeated arbitrarily often to get increasingly good approximations to the true posterior distribution at <code>x_o</code>.</p> <p>Running multi-round inference can be more efficient in the number of simulations, but it will lead to the posterior no longer being amortized (i.e. it will be accurate only for a specific observation <code>x_o</code>, not for any <code>x</code>).</p> <p>Note, you can find the original version of this notebook at tutorials/02_multiround_inference.ipynb in the <code>sbi</code> repository.</p>"},{"location":"tutorials/02_multiround_inference/#main-syntax","title":"Main syntax","text":"<pre><code>import torch\n\nfrom sbi.analysis import pairplot\nfrom sbi.inference import NPE, simulate_for_sbi\nfrom sbi.utils import BoxUniform\nfrom sbi.utils.user_input_checks import (\n    check_sbi_inputs,\n    process_prior,\n    process_simulator,\n)\n</code></pre> <pre><code># 2 rounds: first round simulates from the prior, second round simulates parameter set\n# that were sampled from the obtained posterior.\nnum_rounds = 2\nnum_dim = 3\n# The specific observation we want to focus the inference on.\nx_o = torch.zeros(num_dim,)\nprior = BoxUniform(low=-2 * torch.ones(num_dim), high=2 * torch.ones(num_dim))\nsimulator = lambda theta: theta + torch.randn_like(theta) * 0.1\n\n# Ensure compliance with sbi's requirements.\nprior, num_parameters, prior_returns_numpy = process_prior(prior)\nsimulator = process_simulator(simulator, prior, prior_returns_numpy)\ncheck_sbi_inputs(simulator, prior)\n\ninference = NPE(prior)\n\nposteriors = []\nproposal = prior\n\nfor _ in range(num_rounds):\n    theta, x = simulate_for_sbi(simulator, proposal, num_simulations=500)\n\n    # In `SNLE` and `SNRE`, you should not pass the `proposal` to\n    # `.append_simulations()`\n    density_estimator = inference.append_simulations(\n        theta, x, proposal=proposal\n    ).train()\n    posterior = inference.build_posterior(density_estimator)\n    posteriors.append(posterior)\n    proposal = posterior.set_default_x(x_o)\n</code></pre> <pre><code> Neural network successfully converged after 196 epochs.\n\nUsing SNPE-C with atomic loss\n Neural network successfully converged after 37 epochs.\n</code></pre>"},{"location":"tutorials/02_multiround_inference/#linear-gaussian-example","title":"Linear Gaussian example","text":"<p>Below, we give a full example of inferring the posterior distribution over multiple rounds.</p> <p>First, we define a simple prior and simulator and ensure that they comply with <code>sbi</code> by using <code>process_simulator()</code>, <code>process_prior()</code> and <code>check_sbi_inputs()</code>:</p> <pre><code>def linear_gaussian(theta):\n    return theta + 1.0 + torch.randn_like(theta) * 0.1\n</code></pre> <pre><code># Check prior, return PyTorch prior.\nprior, num_parameters, prior_returns_numpy = process_prior(prior)\n\n# Check simulator, returns PyTorch simulator able to simulate batches.\nsimulator = process_simulator(linear_gaussian, prior, prior_returns_numpy)\n\n# Consistency check after making ready for sbi.\ncheck_sbi_inputs(simulator, prior)\n</code></pre> <p>Then, we instantiate the inference object:</p> <pre><code>inference = NPE(prior=prior)\n</code></pre> <p>And we can run inference. In this example, we will run inference over <code>2</code> rounds, potentially leading to a more focused posterior around the observation <code>x_o</code>.</p> <pre><code>num_rounds = 2\nx_o = torch.zeros(\n    3,\n)\n\nposteriors = []\nproposal = prior\n\nfor _ in range(num_rounds):\n    theta, x = simulate_for_sbi(simulator, proposal, num_simulations=500)\n    density_estimator = inference.append_simulations(\n        theta, x, proposal=proposal\n    ).train()\n    posterior = inference.build_posterior(density_estimator)\n    posteriors.append(posterior)\n    proposal = posterior.set_default_x(x_o)\n</code></pre> <pre><code> Neural network successfully converged after 277 epochs.\n\nUsing SNPE-C with atomic loss\n Neural network successfully converged after 35 epochs.\n</code></pre> <p>Note that, for <code>num_rounds&gt;1</code>, the posterior is no longer amortized: it will give good results when sampled around <code>x=observation</code>, but possibly bad results for other <code>x</code>.</p> <p>Once we have obtained the posterior, we can <code>.sample()</code>, <code>.log_prob()</code>, or <code>.pairplot()</code> in the same way as for the simple interface.</p> <pre><code>posterior_samples = posterior.sample((10000,), x=x_o)\n\n# plot posterior samples\nfig, ax = pairplot(\n    posterior_samples, limits=[[-2, 2], [-2, 2], [-2, 2]], figsize=(5, 5)\n)\n</code></pre> <p></p>"},{"location":"tutorials/03_density_estimators/","title":"Customizing the density estimator","text":"<p><code>sbi</code> allows to specify a custom density estimator for each of the implemented methods. For all options, check the API reference here.</p>"},{"location":"tutorials/03_density_estimators/#changing-the-type-of-density-estimator","title":"Changing the type of density estimator","text":"<p>One option is to use one of set of preconfigured density estimators by passing a string in the <code>density_estimator</code> keyword argument to the inference object (<code>NPE</code> or <code>NLE</code>), e.g., \u201cmaf\u201d to use a Masked Autoregressive Flow, of \u201cnsf\u201d to use a Neural Spline Flow with default hyperparameters.</p> <pre><code>import torch\n\nfrom sbi.inference import NPE, NRE\nfrom sbi.utils import BoxUniform\n</code></pre> <pre><code>prior = BoxUniform(torch.zeros(2), torch.ones(2))\ninference = NPE(prior=prior, density_estimator=\"maf\")\n</code></pre> <p>In the case of <code>NRE</code>, the argument is called <code>classifier</code>:</p> <pre><code>inference = NRE(prior=prior, classifier=\"resnet\")\n</code></pre>"},{"location":"tutorials/03_density_estimators/#changing-hyperparameters-of-density-estimators","title":"Changing hyperparameters of density estimators","text":"<p>Alternatively, you can use a set of utils functions to configure a density estimator yourself, e.g., use a MAF with hyperparameters chosen for your problem at hand.</p> <p>Here, because we want to use N*P*E, we specifiy a neural network targeting the posterior (using the utils function <code>posterior_nn</code>). In this example, we will create a neural spline flow (<code>'nsf'</code>) with <code>60</code> hidden units and <code>3</code> transform layers:</p> <pre><code># For SNLE: likelihood_nn(). For SNRE: classifier_nn()\nfrom sbi.neural_nets import posterior_nn\n\ndensity_estimator_build_fun = posterior_nn(\n    model=\"nsf\", hidden_features=60, num_transforms=3\n)\ninference = NPE(prior=prior, density_estimator=density_estimator_build_fun)\n</code></pre> <p>It is also possible to pass an <code>embedding_net</code> to <code>posterior_nn()</code> which learn summary statistics from high-dimensional simulation outputs. You can find a more detailed tutorial on this in 04_embedding_networks.</p>"},{"location":"tutorials/03_density_estimators/#building-new-density-estimators-from-scratch","title":"Building new density estimators from scratch","text":"<p>Finally, it is also possible to implement your own density estimator from scratch, e.g., including embedding nets to preprocess data, or to a density estimator architecture of your choice.</p> <p>For this, the <code>density_estimator</code> argument needs to be a function that takes <code>theta</code> and <code>x</code> batches as arguments to then construct the density estimator after the first set of simulations was generated. Our factory functions in <code>sbi/neural_nets/factory.py</code> return such a function.</p> <p>The returned <code>density_estimator</code> object needs to be a subclass of <code>DensityEstimator</code>, which requires to implement three methods:</p> <ul> <li><code>log_prob(input, condition, **kwargs)</code>: Return the log probabilities of the inputs given a condition or multiple i.e. batched conditions.</li> <li><code>loss(input, condition, **kwargs)</code>: Return the loss for training the density estimator.</li> <li><code>sample(sample_shape, condition, **kwargs)</code>: Return samples from the density estimator.</li> </ul> <p>See more information on the Reference API page.</p> <pre><code>\n</code></pre>"},{"location":"tutorials/04_embedding_networks/","title":"Embedding nets for observations","text":"<p>Note</p> <p>You can find the original version of this notebook at tutorials/04_embedding_networks.ipynb in the <code>sbi</code> repository.</p>"},{"location":"tutorials/04_embedding_networks/#introduction","title":"Introduction","text":"<p>When engaging in simulation-based inference, the selection of appropriate summary statistics for observations holds significant importance. These statistics serve to succinctly describe the data generated by simulators, often leveraging domain-specific knowledge. However, in certain scenarios, particularly when dealing with highly complex raw data where domain knowledge may be limited or non-existent, it becomes necessary to learn directly from the data the appropriate summary statistics to employ. <code>sbi</code> offers functionality to learn summary statistics from simulation outputs with an embedding neural network, referred to as <code>embedding_net</code>. </p> <p>When an embedding network is used, the posterior approximation for a given observation \\(x_o\\) can be denoted as \\(q_\\phi\\big(\\theta \\mid f_\\lambda(x_o)\\big)\\) where \\(\\phi\\) are the parameters of the conditional density estimator and \\(\\lambda\\) the parameters of the embedding neural network. Note that the simulation outputs pass through the <code>embedding_net</code> before reaching the density estimator and that \\(\\phi\\) and \\(\\lambda\\) are jointly learned during training. <code>sbi</code> provides pre-configured embedding networks (MLP, CNN, and permutation-invariant networks) or allows to pass custom-written embedding networks.</p> <p>It is worth noting that only <code>NPE</code> and <code>NRE</code> methods can use an <code>embedding_net</code> to learn summary statistics from simulation outputs. <code>NLE</code> does not offer such functionality because the simulation outputs are also the output of the neural density estimator. </p>"},{"location":"tutorials/04_embedding_networks/#main-syntax","title":"Main syntax","text":"<pre><code># import required modules\nfrom sbi.neural_nets import posterior_nn\n\n# import the different choices of pre-configured embedding networks\nfrom sbi.neural_nets.embedding_nets import (\n    FCEmbedding,\n    CNNEmbedding,\n    PermutationInvariantEmbedding\n)\n\n# choose which type of pre-configured embedding net to use (e.g. CNN)\nembedding_net = CNNEmbedding(input_shape=(32, 32))\n\n# instantiate the conditional neural density estimator\nneural_posterior = posterior_nn(model=\"maf\", embedding_net=embedding_net)\n\n# setup the inference procedure with NPE\ninferer = NPE(prior=prior, density_estimator=neural_posterior)\n\n# train the density estimator\ndensity_estimator = inference.append_simulations(theta, x).train()\n\n# build the posterior\nposterior = inference.build_posterior(density_estimator)\n</code></pre>"},{"location":"tutorials/04_embedding_networks/#inferring-parameters-from-images","title":"Inferring parameters from images","text":"<p>In the example that follows, we consider a simple setup where the data points generated by the simulator model are high-dimensional (32x32 grayscale images) and we use a convolutional neural network as summary statistics extractor.</p> <p>First of all, we import all the packages required for running the tutorial</p> <pre><code>import matplotlib.pyplot as plt\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nfrom sbi import analysis, utils\nfrom sbi.inference import NPE, simulate_for_sbi\nfrom sbi.utils.user_input_checks import (\n    check_sbi_inputs,\n    process_prior,\n    process_simulator,\n)\n\nseed = 0\ntorch.manual_seed(seed);\n</code></pre>"},{"location":"tutorials/04_embedding_networks/#the-simulator-model","title":"The simulator model","text":"<p>The simulator model that we consider has two parameters: \\(r\\) and \\(\\theta\\). On each run, it generates 100 two-dimensional points centered around \\((r \\cos(\\theta), r \\sin(\\theta))\\) and perturbed by a Gaussian noise with variance 0.01. Instead of simply outputting the \\((x,y)\\) coordinates of each data point, the model generates a grayscale image of the scattered points with dimensions 32 by 32. This image is further perturbed by an uniform noise with values betweeen 0 and 0.2. The code below defines such model.</p> <pre><code>def simulator_model(parameter, return_points=False):\n    \"\"\"Simulator model with two-dimensional input parameter and 1024-D output\n\n    This simulator serves as a basic example for using a neural net for learning\n    summary features. It has only two input parameters but generates\n    high-dimensional output vectors. The data is generated as follows:\n        (-) Input:  parameter = [r, phi] (1) Generate 100 two-dimensional\n        points centered around (r cos(phi),r sin(phi))\n            and perturbed by a Gaussian noise with variance 0.01\n        (2) Create a grayscale image I of the scattered points with dimensions\n            32 by 32\n        (3) Perturb I with an uniform noise with values betweeen 0 and 0.2\n        (-) Output: I\n\n    Parameters\n    ----------\n    parameter : array-like, shape (2)\n        The two input parameters of the model, ordered as [r, phi]\n    return_points : bool (default: False)\n        Whether the simulator should return the coordinates of the simulated\n        data points as well\n\n    Returns\n    -------\n    I: torch tensor, shape (1, 1024)\n        Output flattened image\n    (optional) points: array-like, shape (100, 2)\n        Coordinates of the 2D simulated data points\n\n    \"\"\"\n    r = parameter[0]\n    phi = parameter[1]\n\n    sigma_points = 0.10\n    npoints = 100\n    points = []\n    for _ in range(npoints):\n        x = r * torch.cos(phi) + sigma_points * torch.randn(1)\n        y = r * torch.sin(phi) + sigma_points * torch.randn(1)\n        points.append([x, y])\n    points = torch.as_tensor(points)\n\n    nx = 32\n    ny = 32\n    sigma_image = 0.20\n    im = torch.zeros(nx, ny)\n    for point in points:\n        pi = int((point[0] - (-1)) / ((+1) - (-1)) * nx)\n        pj = int((point[1] - (-1)) / ((+1) - (-1)) * ny)\n        if (pi &lt; nx) and (pj &lt; ny):\n            im[pi, pj] = 1\n    im = im + sigma_image * torch.rand(nx, ny)\n    im = im.T\n    im = im.reshape(1, -1)\n\n    if return_points:\n        return im, points\n    else:\n        return im\n</code></pre> <p>The figure below shows an example of the output of the simulator when \\(r = 0.70\\) and \\(\\theta = \\pi/4\\)</p> <pre><code># simulate samples\ntrue_parameter = torch.tensor([0.70, torch.pi / 4])\nx_observed, x_points = simulator_model(true_parameter, return_points=True)\n\n# plot the observation\nfig, ax = plt.subplots(\n    facecolor=\"white\", figsize=(11.15, 5.61), ncols=2, constrained_layout=True\n)\ncircle = plt.Circle((0, 0), 1.0, color=\"k\", ls=\"--\", lw=0.8, fill=False)\nax[0].add_artist(circle)\nax[0].scatter(x_points[:, 0], x_points[:, 1], s=20)\nax[0].set_xlabel(\"x\")\nax[0].set_ylabel(\"y\")\nax[0].set_xlim(-1, +1)\nax[0].set_xticks([-1, 0.0, +1.0])\nax[0].set_ylim(-1, +1)\nax[0].set_yticks([-1, 0.0, +1.0])\nax[0].set_title(r\"original simulated points with $r = 0.70$ and $\\phi = \\pi/4$\")\nax[1].imshow(x_observed.view(32, 32), origin=\"lower\", cmap=\"gray\")\nax[1].set_xticks([])\nax[1].set_yticks([])\nax[1].set_title(\"noisy observed data (gray image with 32 x 32 pixels)\")\n</code></pre> <p></p>"},{"location":"tutorials/04_embedding_networks/#choosing-an-embedding_net","title":"Choosing an <code>embedding_net</code>","text":"<p>The outputs \\(x\\) from the simulator are defined in a 1024 dimensional space (32 x 32 = 1024). To avoid having to setup a conditional neural density estimator to work directly on such high-dimensional vectors, one could use an <code>embedding_net</code> that would take the images as input and encode them into smaller vectors.</p> <p><code>sbi</code> provides pre-configured embedding networks of the following types:</p> <ul> <li>Fully-connected multi-layer perceptron</li> <li>Convolutional neural network (1D and 2D convolutions)</li> <li>Permutation-invariant neural network (for trial-based data, see here)</li> </ul> <p>In the example considered here, the most appropriate <code>embedding_net</code> would be a CNN for two-dimensional images. We can setup it as per:</p> <pre><code>from sbi.neural_nets.embedding_nets import CNNEmbedding\n\nembedding_net = CNNEmbedding(\n    input_shape=(32, 32),\n    in_channels=1,\n    out_channels_per_layer=[6],\n    num_conv_layers=1,\n    num_linear_layers=1,\n    output_dim=8,\n    kernel_size=5,\n    pool_kernel_size=8\n)\n</code></pre> <p>Note</p> <p>See here for details on all hyperparametes for each available embedding net in <code>sbi</code></p>"},{"location":"tutorials/04_embedding_networks/#the-inference-procedure","title":"The inference procedure","text":"<p>With the <code>embedding_net</code> defined and instantiated, we can follow the usual workflow of an inference procedure in <code>sbi</code>. The <code>embedding_net</code> object appears as an input argument when instantiating the neural density estimator with <code>sbi.neural_nets.posterior_nn</code>.</p> <pre><code># set prior distribution for the parameters\nprior = utils.BoxUniform(\n    low=torch.tensor([0.0, 0.0]), high=torch.tensor([1.0, 2 * torch.pi])\n)\n\n# make a SBI-wrapper on the simulator object for compatibility\nprior, num_parameters, prior_returns_numpy = process_prior(prior)\nsimulator_wrapper = process_simulator(simulator_model, prior, prior_returns_numpy)\ncheck_sbi_inputs(simulator_wrapper, prior)\n</code></pre> <pre><code>from sbi.neural_nets import posterior_nn\n\n# instantiate the neural density estimator\nneural_posterior = posterior_nn(model=\"maf\", embedding_net=embedding_net)\n\n# setup the inference procedure with NPE\ninferer = NPE(prior=prior, density_estimator=neural_posterior)\n</code></pre> <pre><code># run the inference procedure on one round and 10000 simulated data points\ntheta, x = simulate_for_sbi(simulator_wrapper, prior, num_simulations=10_000)\n</code></pre> <pre><code>density_estimator = inferer.append_simulations(theta, x).train(training_batch_size=256)\nposterior = inferer.build_posterior(density_estimator)\n</code></pre> <pre><code> Neural network successfully converged after 96 epochs.\n</code></pre>"},{"location":"tutorials/04_embedding_networks/#visualizing-the-results","title":"Visualizing the results","text":"<p>We now generate 50000 samples of the posterior distribution of \\(r\\) and \\(\\theta\\) when observing an input data point \\(x\\) generated from the <code>simulator model</code> with \\(r = 0.70\\) and \\(\\theta = \\pi/4\\).</p> <pre><code># generate posterior samples\ntrue_parameter = torch.tensor([0.50, torch.pi / 4])\nx_observed = simulator_model(true_parameter)\nsamples = posterior.set_default_x(x_observed).sample((50000,))\n</code></pre> <p>The figure below shows the statistics of the generated samples.</p> <pre><code># create the figure\nfig, ax = analysis.pairplot(\n    samples,\n    points=true_parameter,\n    labels=[\"r\", r\"$\\phi$\"],\n    limits=[[0, 1], [0, 2 * torch.pi]],\n    fig_kwargs=dict(\n        points_colors=\"r\",\n        points_offdiag={\"markersize\": 6},\n    ),\n    figsize=(5, 5),\n)\n</code></pre> <p></p>"},{"location":"tutorials/04_embedding_networks/#defining-custom-embedding-networks","title":"Defining custom embedding networks","text":"<p>It is also possible to define custom embedding networks and pass those to neural density estimator. For example, we could have defined our own architecture for the CNN as per</p> <pre><code>class SummaryNet(nn.Module):\n    def __init__(self):\n        super().__init__()\n        # 2D convolutional layer\n        self.conv1 = nn.Conv2d(in_channels=1, out_channels=6, kernel_size=5, padding=2)\n        # Maxpool layer that reduces 32x32 image to 4x4\n        self.pool = nn.MaxPool2d(kernel_size=8, stride=8)\n        # Fully connected layer taking as input the 6 flattened output arrays\n        # from the maxpooling layer\n        self.fc = nn.Linear(in_features=6 * 4 * 4, out_features=8)\n\n    def forward(self, x):\n        x = x.view(-1, 1, 32, 32)\n        x = self.pool(F.relu(self.conv1(x)))\n        x = x.view(-1, 6 * 4 * 4)\n        x = F.relu(self.fc(x))\n        return x\n\n# instantiate the custom embedding_net\nembedding_net_custom = SummaryNet()\n</code></pre>"},{"location":"tutorials/05_conditional_distributions/","title":"Analysing variability and compensation mechansims with conditional distributions","text":"<p>A central advantage of <code>sbi</code> over parameter search methods such as genetic algorithms is that the posterior captures all models that can reproduce experimental data. This allows us to analyse whether parameters can be variable or have to be narrowly tuned, and to analyse compensation mechanisms between different parameters. See also Marder and Taylor, 2011 for further motivation to identify all models that capture experimental data.</p> <p>In this tutorial, we will show how one can use the posterior distribution to identify whether parameters can be variable or have to be finely tuned, and how we can use the posterior to find potential compensation mechanisms between model parameters. To investigate this, we will extract conditional distributions from the posterior inferred with <code>sbi</code>.</p> <p>Note, you can find the original version of this notebook at tutorials/05_conditional_distributions.ipynb in the <code>sbi</code> repository.</p>"},{"location":"tutorials/05_conditional_distributions/#main-syntax","title":"Main syntax","text":"<p>Asssuming you have already obtained <code>posterior</code>.</p> <pre><code>from sbi.analysis import conditional_corrcoeff, conditional_pairplot\n\n# Plot slices through posterior, i.e. conditionals.\n_ = conditional_pairplot(\n    density=posterior,\n    condition=posterior.sample((1,)),\n    limits=torch.tensor([[-2.0, 2.0], [-2.0, 2.0]]),\n)\n\n# Compute the matrix of correlation coefficients of the slices.\ncond_coeff_mat = conditional_corrcoeff(\n    density=posterior,\n    condition=posterior.sample((1,)),\n    limits=torch.tensor([[-2.0, 2.0], [-2.0, 2.0]]),\n)\nplt.imshow(cond_coeff_mat, clim=[-1, 1])\n</code></pre>"},{"location":"tutorials/05_conditional_distributions/#analysing-variability-and-compensation-mechanisms-in-a-toy-example","title":"Analysing variability and compensation mechanisms in a toy example","text":"<p>Below, we use a simple toy example to demonstrate the above described features. For an application of these features to a neuroscience problem, see figure 6 in Gon\u00e7alves, Lueckmann, Deistler et al., 2019.</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom IPython.display import HTML\nfrom matplotlib import animation, rc\n\nfrom sbi.analysis import (\n    conditional_corrcoeff,\n    conditional_pairplot,\n    conditional_potential,\n    pairplot,\n)\n\n_ = torch.manual_seed(0)\n</code></pre> <p>Let\u2019s say we have used SNPE to obtain a posterior distribution over three parameters. In this tutorial, we just load the posterior from a file:</p> <pre><code>from toy_posterior_for_07_cc import ExamplePosterior\n\nposterior = ExamplePosterior()\n</code></pre> <p>First, we specify the experimental observation \\(x_o\\) at which we want to evaluate and sample the posterior \\(p(\\theta|x_o)\\):</p> <pre><code>x_o = torch.ones(1, 20)  # simulator output was 20-dimensional\nposterior.set_default_x(x_o)\n</code></pre> <p>As always, we can inspect the posterior marginals with the <code>pairplot()</code> function:</p> <pre><code>posterior_samples = posterior.sample((5000,))\n\nfig, ax = pairplot(\n    samples=posterior_samples,\n    limits=torch.tensor([[-2.0, 2.0]] * 3),\n    upper=[\"kde\"],\n    diag=[\"kde\"],\n    figsize=(5, 5),\n)\n</code></pre> <p></p> <p>The 1D and 2D marginals of the posterior fill almost the entire parameter space! Also, the Pearson correlation coefficient matrix of the marginal shows rather weak interactions (low correlations):</p> <pre><code>corr_matrix_marginal = np.corrcoef(posterior_samples.T)\nfig, ax = plt.subplots(1, 1, figsize=(4, 4))\nim = plt.imshow(corr_matrix_marginal, clim=[-1, 1], cmap=\"PiYG\")\n_ = fig.colorbar(im)\n</code></pre> <p></p> <p>It might be tempting to conclude that the experimental data barely constrains our parameters and that almost all parameter combinations can reproduce the experimental data. As we will show below, this is not the case.</p> <p>Because our toy posterior has only three parameters, we can plot posterior samples in a 3D plot:</p> <pre><code>rc(\"animation\", html=\"html5\")\n\n# First set up the figure, the axis, and the plot element we want to animate\nfig = plt.figure(figsize=(6, 6))\nax = fig.add_subplot(111, projection=\"3d\")\n\nax.set_xlim((-2, 2))\nax.set_ylim((-2, 2))\n\n\ndef init():\n    (line,) = ax.plot([], [], lw=2)\n    line.set_data([], [])\n    return (line,)\n\n\ndef animate(angle):\n    num_samples_vis = 1000\n    line = ax.scatter(\n        posterior_samples[:num_samples_vis, 0],\n        posterior_samples[:num_samples_vis, 1],\n        posterior_samples[:num_samples_vis, 2],\n        zdir=\"z\",\n        s=15,\n        c=\"#2171b5\",\n        depthshade=False,\n    )\n    ax.view_init(20, angle)\n    return (line,)\n\n\nanim = animation.FuncAnimation(\n    fig, animate, init_func=init, frames=range(0, 360, 5), interval=150, blit=True\n)\n\nplt.close()\n</code></pre> <pre><code>HTML(anim.to_html5_video())\n</code></pre> <p>Clearly, the range of admissible parameters is constrained to a narrow region in parameter space, which had not been evident from the marginals.</p> <p>If the posterior has more than three dimensions, inspecting all dimensions at once will not be possible anymore. One way to still reveal structures in high-dimensional posteriors is to inspect 2D-slices through the posterior. In <code>sbi</code>, this can be done with the <code>conditional_pairplot()</code> function, which computes the conditional distributions within the posterior. We can slice (i.e. condition) the posterior at any location, given by the <code>condition</code>. In the plot below, for all upper diagonal plots, we keep all but two parameters constant at values sampled from the posterior, and inspect what combinations of the remaining two parameters can reproduce experimental data. For the plots on the diagonal (the 1D conditionals), we keep all but one parameter constant.</p> <pre><code>condition = posterior.sample((1,))\n\n_ = conditional_pairplot(\n    density=posterior,\n    condition=condition,\n    limits=torch.tensor([[-2.0, 2.0]] * 3),\n    figsize=(5, 5),\n)\n</code></pre> <p></p> <p>This plot looks completely different from the marginals obtained with <code>pairplot()</code>. As it can be seen on the diagonal plots, if all parameters but one are kept constant, the remaining parameter has to be tuned to a narrow region in parameter space. In addition, the upper diagonal plots show strong correlations: deviations in one parameter can be compensated through changes in another parameter.</p> <p>We can summarize these correlations in a conditional correlation matrix, which computes the Pearson correlation coefficient of each of these pairwise plots. This matrix (below) shows strong correlations between many parameters, which can be interpreted as potential compensation mechansims:</p> <pre><code>cond_coeff_mat = conditional_corrcoeff(\n    density=posterior,\n    condition=condition,\n    limits=torch.tensor([[-2.0, 2.0]] * 3),\n)\nfig, ax = plt.subplots(1, 1, figsize=(4, 4))\nim = plt.imshow(cond_coeff_mat, clim=[-1, 1], cmap=\"PiYG\")\n_ = fig.colorbar(im)\n</code></pre> <p>So far, we have investigated the conditional distribution only at a specific <code>condition</code> sampled from the posterior. In many applications, it makes sense to repeat the above analyses with a different <code>condition</code> (another sample from the posterior), which can be interpreted as slicing the posterior at a different location. Note that <code>conditional_corrcoeff()</code> can directly compute the matrix for several <code>conditions</code> and then outputs the average over them. This can be done by passing a batch of \\(N\\) conditions as the <code>condition</code> argument.</p>"},{"location":"tutorials/05_conditional_distributions/#sampling-conditional-distributions","title":"Sampling conditional distributions","text":"<p>So far, we have demonstrated how one can plot 2D conditional distributions with <code>conditional_pairplot()</code> and how one can compute the pairwise conditional correlation coefficient with <code>conditional_corrcoeff()</code>. In some cases, it can be useful to keep a subset of parameters fixed and to vary more than two parameters. This can be done by sampling the conditonal posterior \\(p(\\theta_i | \\theta_{j \\neq i}, x_o)\\). As of <code>sbi</code> <code>v0.18.0</code>, this functionality requires using the sampler interface. In this tutorial, we demonstrate this functionality on a linear gaussian simulator with four parameters. We would like to fix the forth parameter to \\(\\theta_4=0.2\\) and sample the first three parameters given that value, i.e. we want to sample \\(p(\\theta_1, \\theta_2, \\theta_3 | \\theta_4 = 0.2, x_o)\\). For an application in neuroscience, see Deistler, Gon\u00e7alves, Macke, 2021.</p> <p>In this tutorial, we will use NPE, but the same also works for NLE and NRE. First, we define the prior and the simulator and train the deep neural density estimator:</p> <pre><code>import torch\n\nfrom sbi.inference import (\n    NPE,\n    MCMCPosterior,\n    posterior_estimator_based_potential,\n    simulate_for_sbi,\n)\nfrom sbi.utils import BoxUniform\nfrom sbi.utils.user_input_checks import (\n    check_sbi_inputs,\n    process_prior,\n    process_simulator,\n)\n\nnum_dim = 4\nprior = BoxUniform(low=-2 * torch.ones(num_dim), high=2 * torch.ones(num_dim))\n\n\ndef linear_gaussian(theta):\n    return theta + 1.0 + torch.randn_like(theta) * 0.1\n\nnum_simulations = 1000\ntheta = prior.sample((num_simulations,))\nx = linear_gaussian(theta)\n\ninference = NPE()\nposterior_estimator = inference.append_simulations(theta, x).train()\n</code></pre> <pre><code> Neural network successfully converged after 135 epochs.\n</code></pre> <p>Next, we follow the sampler interface and create a potential_function. The observation in this example is <code>x_o=[1, 1, 1, 1]</code>.</p> <pre><code>x_o = torch.ones(1, 4)\npotential_fn, theta_transform = posterior_estimator_based_potential(\n    posterior_estimator, prior=prior, x_o=x_o\n)\n</code></pre> <p>Now we want to build the conditional potential (please read through the tutorial 09_sampler_interface for an explanation of potential functions). For this, we have to pass a <code>condition</code>. In our case, we want to condition the forth parameter on \\(\\theta_4=0.2\\). Regardless of how many parameters one wants to condition on, in <code>sbi</code>, one has to pass a <code>condition</code> value for all parameters. The first three values will simply be ignored. We can tell the algorithm which parameters should be kept fixed and which ones should be sampled with the argument <code>dims_to_sample</code>.</p> <pre><code>conditioned_potential_fn, restricted_tf, restricted_prior = conditional_potential(\n    potential_fn=potential_fn,\n    theta_transform=theta_transform,\n    prior=prior,\n    condition=torch.as_tensor(\n        [0.0, 0.0, 0.0, 0.2]\n    ),  # the first three values are arbitrary and are ignored internally\n    dims_to_sample=[0, 1, 2],\n)\n</code></pre> <p>Finally, we have to build a sampler for the <code>conditioned_potential_fn</code>. E.g., we can sample the conditional posterior with MCMC:</p> <pre><code>mcmc_posterior = MCMCPosterior(\n    potential_fn=conditioned_potential_fn,\n    theta_transform=restricted_tf,\n    proposal=restricted_prior,\n    method=\"slice_np_vectorized\",\n    num_chains=20,\n).set_default_x(x_o)\ncond_samples = mcmc_posterior.sample((100,))\n</code></pre> <p>The resulting samples are 3-dimensional, corresponding to \\([\\theta_1, \\theta_2, \\theta_3]\\), sampled from \\(p(\\theta_1, \\theta_2, \\theta_3 | \\theta_4=0.2, x_o)\\).</p> <pre><code>print(cond_samples.shape)\n</code></pre> <pre><code>torch.Size([100, 3])\n</code></pre> <p>We can also plot them with <code>pairplot</code>:</p> <pre><code>pairplot(cond_samples, limits=[[-2, 2], [-2, 2], [-2, 2], [-2, 2]], figsize=(8, 8),\n         diag_kwargs=dict(bins=\"auto\"));\n</code></pre> <p></p>"},{"location":"tutorials/06_restriction_estimator/","title":"Efficient handling of invalid simulation outputs","text":"<p>For many simulators, the output of the simulator can be ill-defined or it can have non-sensical values. For example, in neuroscience models, if a specific parameter set does not produce a spike, features such as the spike shape can not be computed. When using <code>sbi</code>, such simulations that have <code>NaN</code> or <code>inf</code> in their output are discarded during neural network training. This can lead to inefficetive use of simulation budget: we carry out many simulations, but a potentially large fraction of them is discarded.</p> <p>In this tutorial, we show how we can use <code>sbi</code> to learn regions in parameter space that produce <code>valid</code> simulation outputs, and thereby improve the sampling efficiency. The key idea of the method is to use a classifier to distinguish parameters that lead to <code>valid</code> simulations from regions that lead to <code>invalid</code> simulations. After we have obtained the region in parameter space that produes <code>valid</code> simulation outputs, we train the deep neural density estimator used in <code>NPE</code>. The method was originally proposed in Lueckmann, Goncalves et al. 2017 and later used in Deistler et al. 2021.</p>"},{"location":"tutorials/06_restriction_estimator/#main-syntax","title":"Main syntax","text":"<pre><code>from sbi.inference import NPE\nfrom sbi.utils import RestrictionEstimator\n\nrestriction_estimator = RestrictionEstimator(prior=prior)\nproposals = [prior]\n\nfor r in range(num_rounds):\n    theta, x = simulate_for_sbi(simulator, proposals[-1], 1000)\n    restriction_estimator.append_simulations(theta, x)\n    if (\n        r &lt; num_rounds - 1\n    ):  # training not needed in last round because classifier will not be used anymore.\n        classifier = restriction_estimator.train()\n    proposals.append(restriction_estimator.restrict_prior())\n\nall_theta, all_x, _ = restriction_estimator.get_simulations()\n\ninference = NPE(prior=prior)\ndensity_estimator = inference.append_simulations(all_theta, all_x).train()\nposterior = inference.build_posterior()\n</code></pre>"},{"location":"tutorials/06_restriction_estimator/#further-explanation-in-a-toy-example","title":"Further explanation in a toy example","text":"<pre><code>import torch\n\nfrom sbi.analysis import pairplot\nfrom sbi.inference import NPE, simulate_for_sbi\nfrom sbi.utils import BoxUniform, RestrictionEstimator\n\n_ = torch.manual_seed(2)\n</code></pre> <p>We will define a simulator with two parameters and two simulation outputs. The simulator produces <code>NaN</code> whenever the first parameter is below <code>0.0</code>. If it is above <code>0.0</code> the simulator simply perturbs the parameter set with Gaussian noise:</p> <pre><code>def simulator(theta):\n    perturbed_theta = theta + 0.5 * torch.randn(2)\n    perturbed_theta[theta[:, 0] &lt; 0.0] = torch.as_tensor([float(\"nan\"), float(\"nan\")])\n    return perturbed_theta\n</code></pre> <p>The prior is a uniform distribution in [-2, 2]:</p> <pre><code>prior = BoxUniform(-2 * torch.ones(2), 2 * torch.ones(2))\n</code></pre> <p>We then begin by drawing samples from the prior and simulating them. Looking at the simulation outputs, half of them contain <code>NaN</code>:</p> <pre><code>theta, x = simulate_for_sbi(simulator, prior, 1000)\nprint(\"Simulation outputs: \", x)\n</code></pre> <pre><code>Simulation outputs:  tensor([[ 0.3107, -0.1859],\n        [    nan,     nan],\n        [ 1.0307, -0.4300],\n        ...,\n        [ 1.5587,  2.2561],\n        [    nan,     nan],\n        [ 1.2903,  0.2849]])\n</code></pre> <p>The simulations that contain <code>NaN</code> are wasted, and we want to learn to \u201crestrict\u201d the prior such that it produces only <code>valid</code> simulation outputs. To do so, we set up the <code>RestrictionEstimator</code>:</p> <pre><code>restriction_estimator = RestrictionEstimator(prior=prior)\n</code></pre> <p>The <code>RestrictionEstimator</code> trains a classifier to distinguish parameters that lead to <code>valid</code> simulation outputs from parameters that lead to <code>invalid</code> simulation outputs</p> <pre><code>restriction_estimator.append_simulations(theta, x)\nclassifier = restriction_estimator.train()\n</code></pre> <pre><code>Training neural network. Epochs trained:  83\n</code></pre> <p>We can inspect the <code>restricted_prior</code>, i.e. the parameters that the classifier believes will lead to <code>valid</code> simulation outputs, with:</p> <pre><code>restricted_prior = restriction_estimator.restrict_prior()\nsamples = restricted_prior.sample((10_000,))\n_ = pairplot(samples, limits=[[-2, 2], [-2, 2]], figsize=(4, 4))\n</code></pre> <pre><code>The `RestrictedPrior` rejected 52.2%\n                of prior samples. You will get a speed-up of\n                109.4%.\n</code></pre> <p></p> <p>Indeed, parameter sets sampled from the <code>restricted_prior</code> always have a first parameter larger than <code>0.0</code>. These are the ones that produce <code>valid</code> simulation outputs (see our definition of the simulator above). We can then use the <code>restricted_prior</code> to generate more simulations. Almost all of them will have <code>valid</code> simulation outputs:</p> <pre><code>new_theta, new_x = simulate_for_sbi(simulator, restricted_prior, 1000)\nprint(\"Simulation outputs: \", new_x)\n</code></pre> <pre><code>The `RestrictedPrior` rejected 53.2%\n                of prior samples. You will get a speed-up of\n                113.8%.\n\n\nSimulation outputs:  tensor([[ 1.7930,  1.5322],\n        [ 1.6024,  1.6551],\n        [ 0.0756,  2.4023],\n        ...,\n        [ 0.4156,  1.5186],\n        [ 0.1857, -1.3267],\n        [ 0.3905, -0.3836]])\n</code></pre> <p>We can now use all simulations and run <code>NPE</code> as always:</p> <pre><code>restriction_estimator.append_simulations(\n    new_theta, new_x\n)  # Gather the new simulations in the `restriction_estimator`.\n(\n    all_theta,\n    all_x,\n    _,\n) = restriction_estimator.get_simulations()  # Get all simulations run so far.\n\ninference = NPE(prior=prior)\ndensity_estimator = inference.append_simulations(all_theta, all_x).train()\nposterior = inference.build_posterior()\n\nposterior_samples = posterior.sample((10_000,), x=torch.ones(2))\n_ = pairplot(posterior_samples, limits=[[-2, 2], [-2, 2]], figsize=(3, 3))\n</code></pre> <pre><code> Neural network successfully converged after 45 epochs.\n</code></pre> <p></p>"},{"location":"tutorials/06_restriction_estimator/#further-options-for-tuning-the-algorithm","title":"Further options for tuning the algorithm","text":"<ul> <li>the whole procedure can be repeated many times (see the loop shown in \u201cMain syntax\u201d in this tutorial)</li> <li>the classifier is trained to be relatively conservative, i.e. it will try to be very sure that a specific parameter set can indeed not produce <code>valid</code> simulation outputs. If you are ok with the restricted prior potentially ignoring a small fraction of parameter sets that might have produced <code>valid</code> data, you can use <code>restriction_estimator.restrict_prior(allowed_false_negatives=...)</code>. The argument <code>allowed_false_negatives</code> sets the fraction of potentially ignored parameter sets. A higher value will lead to more <code>valid</code> simulations.</li> <li>By default, the algorithm considers simulations that have at least one <code>NaN</code> of <code>inf</code> as <code>invalid</code>. You can specify custom criterions with <code>RestrictionEstimator(decision_criterion=...)</code></li> </ul>"},{"location":"tutorials/07_sensitivity_analysis/","title":"Active subspaces for sensitivity analysis","text":"<p>A standard method to analyse dynamical systems such as models of neural dynamics is to use a sensitivity analysis. We can use the posterior obtained with <code>sbi</code>, to perform such analyses.</p>"},{"location":"tutorials/07_sensitivity_analysis/#main-syntax","title":"Main syntax","text":"<pre><code>from sbi.analysis import ActiveSubspace\n\nsensitivity = ActiveSubspace(posterior.set_default_x(x_o))\ne_vals, e_vecs = sensitivity.find_directions(posterior_log_prob_as_property=True)\nprojected_data = sensitivity.project(theta_project, num_dimensions=1)\n</code></pre>"},{"location":"tutorials/07_sensitivity_analysis/#example-and-further-explanation","title":"Example and further explanation","text":"<pre><code>import torch\nfrom torch.distributions import MultivariateNormal\n\nfrom sbi.inference import NPE\nfrom sbi.analysis import ActiveSubspace, pairplot\nfrom sbi.simulators import linear_gaussian\n\n_ = torch.manual_seed(0)\n</code></pre> <p>Let\u2019s define a simple Gaussian toy example:</p> <pre><code>prior = MultivariateNormal(0.0 * torch.ones(2), 2 * torch.eye(2))\n\n\ndef simulator(theta):\n    return linear_gaussian(\n        theta, -0.8 * torch.ones(2), torch.tensor([[1.0, 0.98], [0.98, 1.0]])\n    )\n\nnum_simulations = 2000\ntheta = prior.sample((num_simulations,))\nx = simulator(theta)\ninference = NPE(prior)\n_ = inference.append_simulations(theta, x).train()\nposterior = inference.build_posterior().set_default_x(torch.zeros(2))\n</code></pre> <pre><code> Neural network successfully converged after 185 epochs.\n</code></pre> <pre><code>posterior_samples = posterior.sample((2000,))\n</code></pre> <pre><code>_ = pairplot(posterior_samples, limits=[[-3, 3], [-3, 3]], figsize=(4, 4))\n</code></pre> <p></p> <p>When performing a sensitivity analysis on this model, we would expect that there is one direction that is less sensitive (from bottom left to top right, along the vector [1, 1]) and one direction that is more sensitive (from top left to bottom right, along [1, -1]). We can recover these directions with the <code>ActiveSubspace</code> module in <code>sbi</code>.</p> <pre><code>sensitivity = ActiveSubspace(posterior)\ne_vals, e_vecs = sensitivity.find_directions(posterior_log_prob_as_property=True)\n</code></pre> <p>The method <code>.find_active()</code> returns eigenvalues and the corresponding eigenvectors. It does so by computing the matrix:</p> <p>\\(M = \\mathbb{E}_{p(\\theta|x_o)}[\\nabla_{\\theta}p(\\theta|x_o)^T \\nabla_{\\theta}p(\\theta|x_o)\\)]</p> <p>It then does an eigendecomposition: \\(M = Q \\Lambda Q^{-1}\\)</p> <p>A strong eigenvalue indicates that the gradient of the posterior density is large, i.e. the system output is sensitive to changes along the direction of the corresponding eigenvector (or <code>active</code>). The eigenvalue corresponding to the vector <code>[0.68, -0.73]</code> is much larger than the eigenvalue of <code>[0.73, 0.67]</code>. This matches the intuition we developed above.</p> <pre><code>print(\"Eigenvalues: \\n\", e_vals, \"\\n\")\nprint(\"Eigenvectors: \\n\", e_vecs)\n</code></pre> <pre><code>Eigenvalues: \n tensor([5.2963e-07, 8.0295e-05])\n\nEigenvectors: \n tensor([[ 0.7201,  0.6939],\n        [ 0.6939, -0.7201]])\n</code></pre> <p>Lastly, we can project the data into the active dimensions. In this case, we will just use one active dimension:</p> <pre><code>projected_data = sensitivity.project(posterior_samples, num_dimensions=1)\n</code></pre>"},{"location":"tutorials/07_sensitivity_analysis/#some-technical-details","title":"Some technical details","text":"<ul> <li>The gradients and thus the eigenvectors are computed in z-scored space. The mean and standard deviation are computed w.r.t. the prior distribution. Thus, the gradients (and thus the eigenvales) reflect changes on the scale of the prior.</li> <li>The expected value used to compute the matrix \\(M\\) is estimated using <code>1000</code> posterior samples. This value can be set with the <code>.find_active(num_monte_carlo_samples=...)</code> variable.</li> <li>How does this relate to Principal Component Analysis (PCA)? In the example above, the results of PCA would be very similar. However, there are two main differences to PCA: First, PCA ignores local changes in the posterior, whereas the active subspace can change a lot (since it computes the gradient, which is a local quantity). Second, active subspaces can be used characterize the sensitivity of any other quantity w.r.t. circuit parameters. This is outlined below:</li> </ul>"},{"location":"tutorials/07_sensitivity_analysis/#computing-the-sensitivity-of-a-specific-summary-statistic","title":"Computing the sensitivity of a specific summary statistic","text":"<p>Above, we have shown how to identify directions along which the posterior probability changes rapidly. Notably, the posterior probability reflects how consistent a specific parameter set is with all summary statistics, i.e. the entire \\(x_o\\). Sometimes, we might be interested in investigating how a specific features is influenced by the parameters. This feature could be one of the values of \\(x_o\\), but it could also be a different property.</p> <p>As a neuroscience example, in Deistler et al. 2021, we obtained the posterior distribution given burst durations and delays between bursts. After having obtained the posterior, we then wanted to analyse the sensitivity of metabolic cost w.r.t. circuit parameters. The framework we presented above can easily be extended to study such questions.</p> <pre><code>prior = MultivariateNormal(0.0 * torch.ones(2), 2 * torch.eye(2))\n\ndef simulator(theta):\n    return linear_gaussian(theta, -0.8 * torch.ones(2), torch.eye(2))\n\ntheta = prior.sample((2000,))\nx = simulator(x)\ninference = NPE(prior)\n_ = inference.append_simulations(theta, x).train()\nposterior = inference.build_posterior().set_default_x(torch.zeros(2))\n</code></pre> <pre><code> Neural network successfully converged after 75 epochs.\n</code></pre> <pre><code>_ = pairplot(posterior.sample((10_000,)), limits=[[-3, 3], [-3, 3]], figsize=(4, 4))\n</code></pre> <p></p> <pre><code>sensitivity = ActiveSubspace(posterior)\n</code></pre> <p>This time, we begin by drawing samples from the posterior and then computing the desired property for each of the samples (i.e. you will probably have to run simulations for each theta and extract the property from the simulation output). As an example, we assume that the property is just the cube of the first dimension of the simulation output:</p> <pre><code>theta = posterior.sample((5000,))\nx = simulator(theta)\nproperty_ = x[:, :1] ** 3  # E.g. metabolic cost.\n</code></pre> <p>To investigate the sensitivity of a given parameter, we train a neural network to predict the <code>property_</code> from the parameters and then analyse the neural network as above:</p> <p>\\(M = \\mathbb{E}_{p(\\theta|x_o)}[\\nabla_{\\theta}f(\\theta)^T \\nabla_{\\theta}f(\\theta)\\)]</p> <p>where \\(f(\\cdot)\\) is the trained neural network.</p> <pre><code>_ = sensitivity.add_property(theta, property_).train()\ne_vals, e_vecs = sensitivity.find_directions()\n</code></pre> <pre><code> Training neural network. Epochs trained:  29\n</code></pre> <pre><code>print(\"Eigenvalues: \\n\", e_vals, \"\\n\")\nprint(\"Eigenvectors: \\n\", e_vecs)\n</code></pre> <pre><code>Eigenvalues: \n tensor([2.2571e-06, 2.3152e-04])\n\nEigenvectors: \n tensor([[ 0.0278,  0.9996],\n        [ 0.9996, -0.0278]])\n</code></pre> <p>As we can see, one of the eigenvalues is much smaller than the other one. The larger eigenvalue represents (approximately) the vector <code>[1.0, 0.0]</code>. This makes sense, because only the <code>property_</code> is influenced only by the first output which, in turn, is influenced only by the first parameter.</p>"},{"location":"tutorials/08_crafting_summary_statistics/","title":"Crafting summary statistics","text":"<p>Many simulators produce outputs that are high-dimesional. For example, a simulator might generate a time series or an image. In the tutorial on 04_embedding_networks, we discussed how a neural networks can be used to learn summary statistics from such data. In this notebook, we will instead focus on hand-crafting summary statistics. We demonstrate that the choice of summary statistics can be crucial for the performance of the inference algorithm.</p> <pre><code>import matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\n\nfrom sbi.inference import NPE\nfrom sbi.analysis import pairplot\nfrom sbi.utils import BoxUniform\n</code></pre> <pre><code># remove top and right axis from plots\nmpl.rcParams[\"axes.spines.right\"] = False\nmpl.rcParams[\"axes.spines.top\"] = False\n</code></pre> <p>This notebook is not intended to provide a one-fits-all approach. In fact it argues against this: it argues for the user to carefully construct their summary statistics to (i) further help the user understand his observed data, (ii) help them understand exactly what they want the model to recover from the observation and (iii) help the inference framework itself.</p>"},{"location":"tutorials/08_crafting_summary_statistics/#example-1-the-quadratic-function","title":"Example 1: The quadratic function","text":"<p>Assume we have a simulator that is given by a quadratic function:</p> <p>\\(x(t) = a\\cdot t^2 + b\\cdot t + c + \\epsilon\\),</p> <p>where \\(\\epsilon\\) is Gaussian observation noise and \\(\\theta = \\{a, b, c\\}\\) are the parameters. Given an observed quadratic function \\(x_o\\), we would like to recover the posterior over parameters \\(a_o\\), \\(b_o\\) and \\(c_o\\).</p>"},{"location":"tutorials/08_crafting_summary_statistics/#11-prior-over-parameters","title":"1.1 Prior over parameters","text":"<p>First we define a prior distribution over parameters \\(a\\), \\(b\\) and \\(c\\). Here, we use a uniform prior for \\(a\\), \\(b\\) and \\(c\\) to go from \\(-1\\) to \\(1\\).</p> <pre><code>prior_min = [-1, -1, -1]\nprior_max = [1, 1, 1]\nprior = BoxUniform(\n    low=torch.as_tensor(prior_min), high=torch.as_tensor(prior_max)\n)\n</code></pre>"},{"location":"tutorials/08_crafting_summary_statistics/#12-simulator","title":"1.2 Simulator","text":"<p>Defining some helper functions first:</p> <pre><code>def create_t_x(theta, seed=None):\n    \"\"\"Return an t, x array for plotting based on params\"\"\"\n    if theta.ndim == 1:\n        theta = theta[np.newaxis, :]\n\n    rng = np.random.RandomState(seed) if seed is not None else np.random.RandomState()\n\n    t = np.linspace(-1, 1, 200)\n    ts = np.repeat(t[:, np.newaxis], theta.shape[0], axis=1)\n    x = (\n        theta[:, 0] * ts**2\n        + theta[:, 1] * ts\n        + theta[:, 2]\n        + 0.01 * rng.randn(ts.shape[0], theta.shape[0])\n    )\n    return t, x\n\n\ndef eval(theta, t, seed=None):\n    \"\"\"Evaluate the quadratic function at `t`\"\"\"\n\n    if theta.ndim == 1:\n        theta = theta[np.newaxis, :]\n\n    rng = np.random.RandomState(seed) if seed is not None else np.random.RandomState()\n\n    return theta[:, 0] * t**2 + theta[:, 1] * t + theta[:, 2] + 0.01 * rng.randn(1)\n</code></pre> <p>In this example, we generate the observation \\(x_o\\) from parameters \\(\\theta_o=(a_o, b_o, c_o)=(0.3, -0.2, -0.1)\\). The observation as follows.</p> <pre><code>theta_o = np.array([0.3, -0.2, -0.1])\nt, x = create_t_x(theta_o)\nplt.plot(t, x, \"k\");\n</code></pre>"},{"location":"tutorials/08_crafting_summary_statistics/#13-summary-statistics","title":"1.3 Summary statistics","text":"<p>We will compare two methods for defining summary statistics. One method uses three summary statistics which are function evaluations at three points in time. The other method uses a single summary statistic: the mean squared error between the observed and the simulated trace. In the second case, one then tries to obtain the posterior \\(p(\\theta | 0)\\), i.e. the error being zero. These two methods are implemented below:  \\(\\textbf{get_3_values()}\\) returns 3 function evaluations at \\(x=-0.5, x=0\\) and \\(x=0.75\\).  \\(\\textbf{get_MSE()}\\) returns the mean squared error between true and a quadratic function corresponding to a prior distributions sample.</p> <pre><code>def get_3_values(theta, seed=None):\n    \"\"\"\n    Return 3 'x' values corresponding to t=-0.5,0,0.75 as summary statistic vector\n    \"\"\"\n    return np.array(\n        [\n            eval(theta, -0.5, seed=seed),\n            eval(theta, 0, seed=seed),\n            eval(theta, 0.75, seed=seed),\n        ]\n    ).T\n</code></pre> <pre><code>def get_MSE(theta, theta_o, seed=None):\n    \"\"\"\n    Return the mean-squared error (MSE) i.e. Euclidean distance from the\n    observation function\n    \"\"\"\n    _, x = create_t_x(theta_o, seed=seed)  # truth\n    _, x_ = create_t_x(theta, seed=seed)  # simulations\n    return np.mean(np.square(x_ - x), axis=0, keepdims=True).T  # MSE\n</code></pre> <p>Let\u2019s try a couple of samples from our prior and see their summary statistics. Notice that these indeed change in small amounts every time you rerun it due to the noise, except if you set the seed.</p>"},{"location":"tutorials/08_crafting_summary_statistics/#14-simulating-data","title":"1.4 Simulating data","text":"<p>Let us see various plots of prior samples and their summary statistics versus the truth, i.e. our artificial observation.</p> <pre><code>t, x_truth = create_t_x(theta_o)\nplt.plot(t, x_truth, \"k\", zorder=1, label=\"truth\")\nn_samples = 100\ntheta = prior.sample((n_samples,))\nt, x = create_t_x(theta.numpy())\nplt.plot(t, x, \"grey\", zorder=0)\nplt.legend()\n</code></pre> <p>In summary, we defined reasonable summary statistics and, a priori, there might be an apparent reason why one method would be better than another. When we do inference, we\u2019d like our posterior to focus around parameter samples that have their simulated MSE very close to 0 (i.e. the truth MSE summary statistic) or their 3 extracted \\((t, x)\\) coordinates to be the truthful ones.</p>"},{"location":"tutorials/08_crafting_summary_statistics/#15-inference","title":"1.5 Inference","text":""},{"location":"tutorials/08_crafting_summary_statistics/#151-using-the-mse","title":"1.5.1 Using the MSE","text":"<p>Let\u2019s see if we can use the MSE to recover the true observation parameters \\(\\theta_o=(a_0,b_0,c_0)\\).</p> <pre><code>theta = prior.sample((1000,))\nx = get_MSE(theta.numpy(), theta_o)\n\ntheta = torch.as_tensor(theta, dtype=torch.float32)\nx = torch.as_tensor(x, dtype=torch.float32)\n</code></pre> <pre><code>inference = NPE(prior)\n_ = inference.append_simulations(theta, x).train()\nposterior = inference.build_posterior()\n</code></pre> <p>Now that we\u2019ve built the posterior as such, we can see how likely it finds certain parameters given that we tell it that we\u2019ve observed a certain summary statistic (in this case the MSE). We can then sample from it.</p> <pre><code>x_o = torch.as_tensor(\n    [\n        [\n            0.0,\n        ]\n    ]\n)\ntheta_p = posterior.sample((10000,), x=x_o)\n</code></pre> <pre><code>fig, axes = pairplot(\n    theta_p,\n    limits=list(zip(prior_min, prior_max)),\n    ticks=list(zip(prior_min, prior_max)),\n    figsize=(7, 7),\n    labels=[\"a\", \"b\", \"c\"],\n    fig_kwargs=dict(\n        points_offdiag={\"markersize\": 6},\n        points_colors=\"r\",\n    ),\n    points=theta_o,\n);\n</code></pre> <p>The posterior seems to pretty broad: i.e. it is not so certain about the \u2018true\u2019 parameters (here showcased in red).</p> <pre><code>x_o_t, x_o_x = create_t_x(theta_o)\nplt.plot(x_o_t, x_o_x, \"k\", zorder=1, label=\"truth\")\n\ntheta_p = posterior.sample((10,), x=x_o)\nx_t, x_x = create_t_x(theta_p.numpy())\nplt.plot(x_t, x_x, \"grey\", zorder=0)\nplt.legend();\n</code></pre> <p>The functions are a bit closer to the observation than prior samples, but many posterior samples generate activity that is very far off from the observation. We would expect <code>sbi</code> do better on such a simple example. So what\u2019s going on? Do we need more simulations? Feel free to try, but below we will show that one can use the same number of simulation samples with different summary statistics and do much better.</p>"},{"location":"tutorials/08_crafting_summary_statistics/#152-using-3-coordinates-as-summary-statistics","title":"1.5.2 Using 3 coordinates as summary statistics","text":"<pre><code>x = get_3_values(theta.numpy())\nx = torch.as_tensor(x, dtype=torch.float32)\n</code></pre> <pre><code>inference = NPE(prior)\n\n_ = inference.append_simulations(theta, x).train()\nposterior = inference.build_posterior()\n</code></pre> <p>The observation is now given by the values of the observed trace at three different coordinates:</p> <pre><code>x_o = torch.as_tensor(get_3_values(theta_o), dtype=float)\n</code></pre> <pre><code>theta_p = posterior.sample((10000,), x=x_o)\n\nfig, axes = pairplot(\n    theta_p,\n    limits=list(zip(prior_min, prior_max)),\n    ticks=list(zip(prior_min, prior_max)),\n    figsize=(7, 7),\n    labels=[\"a\", \"b\", \"c\"],\n    fig_kwargs=dict(\n        points_offdiag={\"markersize\": 6},\n        points_colors=\"r\",\n    ),\n    points=theta_o,\n);\n</code></pre> <pre><code>x_o_t, x_o_x = create_t_x(theta_o)\nplt.plot(x_o_t, x_o_x, \"k\", zorder=1, label=\"truth\")\ntheta_p = posterior.sample((100,), x=x_o)\nind_10_highest = np.argsort(np.array(posterior.log_prob(theta=theta_p, x=x_o)))[-10:]\ntheta_p_considered = theta_p[ind_10_highest, :]\nx_t, x_x = create_t_x(theta_p_considered.numpy())\nplt.plot(x_t, x_x, \"grey\", zorder=0)\nplt.legend()\n</code></pre> <p>Ok this definitely seems to work! The posterior correctly focuses on the true parameters with greater confidence. You can experiment yourself how this improves further with more training samples or you could try to see how many you\u2019d exactly need to keep having a satisfyingly looking posterior and high posterior sample simulations.</p> <p>So, what\u2019s up with the MSE? Why does it not seem so informative to constrain the posterior? In 1.6, we\u2019ll see both the power and pitfalls of summary statistics.</p>"},{"location":"tutorials/08_crafting_summary_statistics/#16-prior-simulations-summary-statistics-vs-observed-summary-statistics","title":"1.6 Prior simulations\u2019 summary statistics vs observed summary statistics","text":"<p>Let\u2019s try to understand this\u2026Let\u2019s look at a histogram of the four summary statistics we\u2019ve experimented with, and see how they compare to our observed truth summary statistic vector:</p> <pre><code>stats = np.concatenate(\n    (get_3_values(theta.numpy()), get_MSE(theta.numpy(), theta_o)), axis=1\n)\nx_o = np.concatenate((get_3_values(theta_o), np.asarray([[0.0]])), axis=1)\n\nfeatures = [\"x @ t=-0.5\", \"x @ t=0\", \"x @ t=0.7\", \"MSE\"]\nfig, axes = plt.subplots(1, 4, figsize=(10, 3))\nxlabelfontsize = 10\nfor i, ax in enumerate(axes.reshape(-1)):\n    ax.hist(\n        stats[:, i],\n        color=[\"grey\"],\n        alpha=0.5,\n        bins=30,\n        density=True,\n        histtype=\"stepfilled\",\n        label=[\"simulations\"],\n    )\n    ax.axvline(x_o[:, i], label=\"observation\", color='k')\n    ax.set_xlabel(features[i], fontsize=xlabelfontsize)\n    if i == 3:\n        ax.legend()\nplt.tight_layout()\n</code></pre> <p>We see that for the coordinates (three plots on the left), simulations cover the observation. That is: it covers it from the left and right side in each case. For the MSE, simulations never truly reach the observation \\(0.0\\).</p> <p>For the trained neural network, it is strongly preferable if the simulations cover the observation. In that case, the neural network can interpolate between simulated data. Contrary to that, for the MSE, the neural network has to extrapolate: it never observes a simulation that is to the left of the observation and has to extrapolate to the region of MSE=\\(0.0\\). This seems like a technical point but, as we saw above, it makes a huge difference in performance.</p>"},{"location":"tutorials/08_crafting_summary_statistics/#17-explicit-recommendations","title":"1.7 Explicit recommendations","text":"<p>We give some explicit recommendation when using summary statistics</p> <ul> <li> <p>Visualize the histogram of each summary statistic and plot the value of the observation. If, for some summary statistics, the observation is not covered (or is at the very border, e.g. the MSE above), the trained neural network will struggle.</p> </li> <li> <p>Do not use an \u201cerror\u201d as summary statistic. This is common in optimization (e.g. genetic algorithms), but it often leads to trouble in <code>sbi</code> due to the reason above.</p> </li> <li> <p>Only use summary statistics that are necessary. The less summary statistics you use, the less can go wrong with them. Of course, you have to ensure that the summary statistics describe the raw data sufficiently well.</p> </li> </ul>"},{"location":"tutorials/09_sampler_interface/","title":"Sampling algorithms in <code>sbi</code>","text":"<p><code>sbi</code> implements three methods: NPE, NLE, and NRE. When using NPE, the trained neural network directly approximates the posterior. Thus, sampling from the posterior can be done by sampling from the trained neural network. The neural networks trained in NLE and NRE approximate the likelihood(-ratio). Thus, in order to draw samples from the posterior, one has to perform additional sampling steps, e.g. Markov-chain Monte-Carlo (MCMC). In <code>sbi</code>, the implemented samplers are:</p> <ul> <li> <p>Markov-chain Monte-Carlo (MCMC)</p> </li> <li> <p>Rejection sampling</p> </li> <li> <p>Variational inference (VI)</p> </li> <li> <p>Importance sampling (IS)</p> </li> </ul> <p>Below, we will demonstrate how these samplers can be used in <code>sbi</code>. First, we train the neural network as always:</p> <pre><code>import torch\n\nfrom sbi.inference import NLE\n\n# dummy Gaussian simulator for demonstration\nnum_dim = 2\nprior = torch.distributions.MultivariateNormal(torch.zeros(num_dim), torch.eye(num_dim))\ntheta = prior.sample((1000,))\nx = theta + torch.randn((1000, num_dim))\nx_o = torch.randn((1, num_dim))\n\ninference = NLE(prior=prior, show_progress_bars=False)\nlikelihood_estimator = inference.append_simulations(theta, x).train()\n</code></pre> <p>Neural network successfully converged after 104 epochs.</p> <p>And then we pass the options for which sampling method to use to the <code>build_posterior()</code> method:</p> <pre><code># Sampling with MCMC\nsampling_algorithm = \"mcmc\"\nmcmc_method = \"slice_np\"  # or nuts, or hmc\nposterior = inference.build_posterior(sample_with=sampling_algorithm,\n                                      mcmc_method=mcmc_method)\n\n# Sampling with variational inference\nsampling_algorithm = \"vi\"\nvi_method = \"rKL\"  # or fKL\nposterior = inference.build_posterior(sample_with=sampling_algorithm,\n                                      vi_method=vi_method)\n# Unlike other methods, vi needs a training step for every observation.\nposterior = posterior.set_default_x(x_o).train()\n\n# Sampling with rejection sampling\nsampling_algorithm = \"rejection\"\nposterior = inference.build_posterior(sample_with=sampling_algorithm)\n</code></pre>"},{"location":"tutorials/09_sampler_interface/#more-flexibility-in-adjusting-the-sampler","title":"More flexibility in adjusting the sampler","text":"<p>With the above syntax, you can easily try out different sampling algorithms. However, in many cases, you might want to customize your sampler. Below, we demonstrate how you can change hyperparameters of the samplers (e.g. number of warm-up steps of MCMC) or how you can write your own sampler from scratch.</p>"},{"location":"tutorials/09_sampler_interface/#main-syntax-for-nle-and-nre","title":"Main syntax (for NLE and NRE)","text":"<p>As above, we begin by training the neural network as always:</p> <p>Then, for full flexibility on using the sampler, we do not use the <code>.build_posterior()</code> method, but instead we explicitly define the potential function and the sampling algorithm (see below for explanation):</p> <pre><code>from sbi.inference import MCMCPosterior, likelihood_estimator_based_potential\n\npotential_fn, parameter_transform = likelihood_estimator_based_potential(\n    likelihood_estimator, prior, x_o\n)\nposterior = MCMCPosterior(\n    potential_fn, proposal=prior, theta_transform=parameter_transform, warmup_steps=10\n)\n</code></pre> <p>If you want to use variational inference or rejection sampling, you have to replace the last line with <code>VIPosterior</code> or <code>RejectionPosterior</code>:</p> <pre><code>from sbi.inference import RejectionPosterior, VIPosterior\n\n# For VI, we have to train.\nposterior = VIPosterior(\n    potential_fn, prior=prior, theta_transform=parameter_transform\n).train()\n\nposterior = RejectionPosterior(\n    potential_fn, proposal=prior, theta_transform=parameter_transform\n)\n</code></pre> <pre><code>Converged with loss: 3.11\nQuality Score: -0.029    Good: Smaller than 0.5  Bad: Larger than 1.0            NOTE: Less sensitive to mode collapse.\n</code></pre> <p>At this point, you could also plug the <code>potential_fn</code> into any sampler of your choice and not rely on any of the in-built <code>sbi</code>-samplers.</p>"},{"location":"tutorials/09_sampler_interface/#further-explanation","title":"Further explanation","text":"<p>The first lines are the same as for the flexible interface:</p> <pre><code>inference = NLE()\nlikelihood_estimator = inference.append_simulations(theta, x).train()\n</code></pre> <pre><code> Neural network successfully converged after 72 epochs.\n</code></pre> <p>Next, we obtain the potential function. A potential function is a function of the parameter \\(f(\\theta)\\). The posterior is proportional to the product of likelihood and prior: \\(p(\\theta | x_o) \\propto p(x_o | \\theta)p(\\theta)\\). The potential function is the logarithm of the right-hand side of this equation: \\(f(\\theta) = \\log(p(x_o | \\theta)p(\\theta))\\)</p> <pre><code>potential_fn, parameter_transform = likelihood_estimator_based_potential(\n    likelihood_estimator, prior, x_o\n)\n</code></pre> <p>By calling the <code>potential_fn</code>, you can evaluate the potential:</p> <pre><code># Assuming that your parameters are 1D.\npotential = potential_fn(\n    torch.zeros(1, num_dim)\n)  # -&gt; returns f(0) = log( p(x_o|0) p(0) )\n</code></pre> <p>The other object that is returned by <code>likelihood_estimator_based_potential</code> is a <code>parameter_transform</code>. The <code>parameter_transform</code> is a pytorch transform. The <code>parameter_transform</code> is a fixed transform that is can be applied to parameter <code>theta</code>. It transforms the parameters into unconstrained space (if the prior is bounded, e.g. <code>BoxUniform</code>), and standardizes the parameters (i.e. zero mean, one std). Using <code>parameter_transform</code> during sampling is optional, but it usually improves the performance of MCMC.</p> <pre><code>theta_tf = parameter_transform(torch.zeros(1, num_dim))\ntheta_original = parameter_transform.inv(theta_tf)\nprint(theta_original)  # -&gt; tensor([[0.0]])\n</code></pre> <pre><code>tensor([[0., 0.]])\n</code></pre> <p>After having obtained the <code>potential_fn</code>, we can sample from the posterior with MCMC or rejection sampling:</p> <pre><code>posterior = MCMCPosterior(\n    potential_fn, proposal=prior, theta_transform=parameter_transform\n)\nposterior = RejectionPosterior(potential_fn, proposal=prior)\n</code></pre>"},{"location":"tutorials/09_sampler_interface/#main-syntax-for-npe","title":"Main syntax for NPE","text":"<p>NPE usually does not require MCMC or rejection sampling (if you still need it, you can use the same syntax as above with the <code>posterior_estimator_based_potential</code> function). Instead, NPE samples from the neural network. If the support of the prior is bounded, some samples can lie outside of the support of the prior. The <code>DirectPosterior</code> class automatically rejects these samples:</p> <pre><code>from sbi.inference import NPE, DirectPosterior\n\ninference = NPE()\nposterior_estimator = inference.append_simulations(theta, x).train()\n\nposterior = DirectPosterior(posterior_estimator, prior=prior)\n</code></pre> <pre><code> Neural network successfully converged after 98 epochs.\n</code></pre>"},{"location":"tutorials/10_diagnostics_posterior_predictive_checks/","title":"Posterior Predictive Checks (PPC) in SBI","text":"<p>A common safety check performed as part of inference are Posterior Predictive Checks (PPC). A PPC compares data \\(x_{\\text{pp}}\\) generated using the parameters \\(\\theta_{\\text{posterior}}\\) sampled from the posterior with the observed data \\(x_o\\). The general concept is that -if the inference is correct- the generated data \\(x_{\\text{pp}}\\) should \u201clook similar\u201d to the oberved data \\(x_0\\). Said differently, \\(x_o\\) should be within the support of \\(x_{\\text{pp}}\\).</p> <p>A PPC usually should not be used as a validation metric. Nonetheless a PPC is a good start for an inference diagnosis and can provide an intuition about any bias introduced in inference: does \\(x_{\\text{pp}}\\) systematically differ from \\(x_o\\)?</p>"},{"location":"tutorials/10_diagnostics_posterior_predictive_checks/#conceptual-code-for-ppc","title":"Conceptual Code for PPC","text":"<p>The following illustrates the main approach of PPCs. We have a trained neural posterior and want to check the correlation between the observation(s) \\(x_o\\) and the posterior sample(s) \\(x_{\\text{pp}}\\).</p> <pre><code>from sbi.analysis import pairplot\n\n# A PPC is performed after we trained a neural posterior `posterior`\nposterior.set_default_x(x_o) # x_o loaded from disk for example\n\n# We draw theta samples from the posterior. This part is not in the scope of SBI\nposterior_samples = posterior.sample((5_000,))\n\n# We use posterior theta samples to generate x data\nx_pp = simulator(posterior_samples)\n\n# We verify if the observed data falls within the support of the generated data\n_ = pairplot(\n    samples=x_pp,\n    points=x_o\n)\n</code></pre>"},{"location":"tutorials/10_diagnostics_posterior_predictive_checks/#performing-a-ppc-of-a-toy-example","title":"Performing a PPC of a toy example","text":"<p>Below we provide an example Posterior Predictive Check (PPC) of some toy example:</p> <pre><code>import torch\n\nfrom sbi.analysis import pairplot\n\n_ = torch.manual_seed(0)\n</code></pre> <p>We work on an inference problem over three parameters using any of the techniques implemented in <code>sbi</code>. In this tutorial, we load the dummy posterior (from a python module <code>toy_posterior_for_07_cc</code> alongside this notebook):</p> <pre><code>from toy_posterior_for_07_cc import ExamplePosterior\n\nposterior = ExamplePosterior()\n</code></pre> <p>Let us say that we are observing the data point \\(x_o\\):</p> <pre><code>D = 5  # simulator output was 5-dimensional\nx_o = torch.ones(1, D)\nposterior.set_default_x(x_o)\n</code></pre> <p>The posterior can be used to draw \\(\\theta_{\\text{posterior}}\\) samples:</p> <pre><code>posterior_samples = posterior.sample((5_000,))\n\nfig, ax = pairplot(\n    samples=posterior_samples,\n    limits=torch.tensor([[-2.5, 2.5]] * 3),\n    upper=[\"kde\"],\n    diag=[\"kde\"],\n    figsize=(5, 5),\n    labels=[rf\"$\\theta_{d}$\" for d in range(3)],\n)\n</code></pre> <p></p> <p>Now we can use our simulator to generate some data \\(x_{\\text{PP}}\\). We will use the poterior samples \\(\\theta_{\\text{posterior}}\\) as input parameters. Note that the simulation part is not in the <code>sbi</code> scope, so any simulator -including a non-Python one- can be used at this stage. In our case we\u2019ll use a dummy simulator for the sake of demonstration:</p> <pre><code>def dummy_simulator(theta: torch.Tensor, *args, **kwargs) -&gt; torch.Tensor:\n    \"\"\" a function performing a simulation emulating a real simulator outside sbi\n\n    Args:\n        theta: parameters to control the simulation (in this tutorial,\n            these are the posterior_samples $\\theta_{\\text{posterior}}$ obtained\n            from the trained posterior.\n        args: parameters\n        kwargs: keyword arguments\n    \"\"\"\n\n    sample_size = theta.shape[0] # number of posterior_samples\n    scale = 1.0\n\n    shift = torch.distributions.Gumbel(loc=torch.zeros(D), scale=scale / 2).sample()\n    return torch.distributions.Gumbel(loc=x_o[0] + shift, scale=scale).sample(\n        (sample_size,)\n    )\n\n\nx_pp = dummy_simulator(posterior_samples)\n</code></pre> <p>Plotting \\(x_o\\) against the \\(x_{\\text{pp}}\\), we perform a PPC that represents a sanity check. In this case, the check indicates that \\(x_o\\) falls right within the support of \\(x_{\\text{pp}}\\), which should make the experimenter rather confident about the estimated <code>posterior</code>:</p> <pre><code>_ = pairplot(\n    samples=x_pp,\n    points=x_o[0],\n    limits=torch.tensor([[-2.0, 5.0]] * 5),\n    figsize=(8, 8),\n    upper=\"scatter\",\n    upper_kwargs=dict(marker=\".\", s=5),\n    fig_kwargs=dict(\n        points_offdiag=dict(marker=\"+\", markersize=20),\n        points_colors=\"red\",\n    ),\n    labels=[rf\"$x_{d}$\" for d in range(D)],\n)\n</code></pre> <p></p> <p>In contrast, \\(x_o\\) falling well outside the support of \\(x_{\\text{pp}}\\) is indicative of a failure to estimate the correct posterior. Here we simulate such a failure mode (by introducing a constant shift to the observations, which the neural estimator was not trained on):</p> <pre><code>error_shift = -2.0 * torch.ones(1, 5)\n\n_ = pairplot(\n    samples=x_pp,\n    points=x_o[0] + error_shift, # shift the observations\n    limits=torch.tensor([[-2.0, 5.0]] * 5),\n    figsize=(8, 8),\n    upper=\"scatter\",\n    upper_kwargs=dict(marker=\".\", s=5),\n    fig_kwargs=dict(\n        points_offdiag=dict(marker=\"+\", markersize=20),\n        points_colors=\"red\",\n    ),\n    labels=[rf\"$x_{d}$\" for d in range(D)],\n)\n</code></pre> <p></p> <p>A typical way to investigate this issue would be to run a prior* predictive check, applying the same plotting strategy, but drawing \\(\\theta\\) from the prior instead of the posterior. **The support for \\(x_{\\text{pp}}\\) should be larger and should contain \\(x_o\\)*. If this check is successful, the \u201cblame\u201d can then be shifted to the inference (method used, convergence of density estimators, number of sequential rounds, etc\u2026).</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/","title":"Simulation-based Calibration in SBI","text":"<p>After a density estimator has been trained with simulated data to obtain a posterior, the estimator should be made subject to several diagnostic tests. This needs to be performed before being used for inference given the actual observed data. Posterior Predictive Checks (see 10_diagnostics_posterior_predictive_checks tutorial) provide one way to \u201ccritique\u201d a trained estimator based on its predictive performance. Another important approach to such diagnostics is simulation-based calibration as developed by Cook et al, 2006 and Talts et al, 2018. This tutorial will demonstrate and teach you this technique with sbi.</p> <p>Simulation-based calibration (SBC) provides a (qualitative) view and a quantitive measure to check, whether the variances of the posterior are balanced, i.e., neither over-confident nor under-confident. As such, SBC can be viewed as a necessary condition (but not sufficient) for a valid inference algorithm: If SBC checks fail, this tells you that your inference is invalid. If SBC checks pass, this is no guarantee that the posterior estimation is working.</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#in-a-nutshell","title":"In a nutshell","text":"<p>To run SBC,</p> <ol> <li>we sample <code>theta_o_i</code> values from the prior of the problem at hand</li> <li>we simulate \u201cobservations\u201d from these parameters: <code>x_o_i = simulator(theta_o_i)</code></li> <li>we perform inference given each observation <code>x_o_i</code>.</li> </ol> <p>This produces a separate posterior \\(p_i(\\theta | x_{o,i})\\) for each of <code>x_o_i</code>. The key step for SBC is to generate a set of posterior samples \\(\\{\\theta\\}_i\\) from each posterior. We call this <code>theta_i_s</code>, referring to <code>s</code> samples from posterior \\(p_i(\\theta | x_{o,i})\\)). Next, we rank the corresponding <code>theta_o_i</code> under this set of samples. A rank is computed by counting how many samples <code>theta_i_s</code> fall below their corresponding <code>theta_o_i</code> value (see section 4.1 in Talts et al.). These ranks are then used to perform the SBC check itself.</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#key-ideas-behind-sbc","title":"Key ideas behind SBC","text":"<p>The core idea behind SBC is two fold:</p> <ul> <li> <p>SBC ranks of ground truth parameters under the inferred posterior samples follow a uniform distribution.   (If the SBC ranks are not uniformly distributed, the posterior is not well calibrated.)</p> </li> <li> <p>samples from the data averaged posterior (ensemble of randomly chosen posterior samples given multiple distinct observations <code>x_o</code>) are distributed according to the prior</p> </li> </ul>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#what-can-sbc-diagnose","title":"What can SBC diagnose?","text":"<p>SBC can inform us whether we are not wrong. However, it cannot tell us whether we are right, i.e., SBC checks a necessary condition. For example, imagine you run SBC using the prior as a posterior. The ranks would be perfectly uniform. But the inference would be wrong as this scenario would only occur if the posterior is uninformative.</p> <p>Posterior Predictive Checks can be seen as the complementary sufficient check for the posterior (only as a methaphor, no theoretical guarantees here). Using the prior as a posterior and then doing predictive checks would clearly show that inference failed.</p> <p>To summarize, SBC can:</p> <ul> <li>tell us whether the SBI method applied to the problem at hand produces posteriors that have well-calibrated uncertainties,</li> <li>and if the posteriors have uncalibrated uncertainties, SBC surfaces what kind of systematic bias is present: negative or positive bias (shift in the mean of the predictions) or over- or underdispersion (too large or too small variance)</li> </ul>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#a-healthy-posterior","title":"A healthy posterior","text":"<p>Let\u2019s take the gaussian linear simulator from the previous tutorials and run inference with NPE on it.</p> <p>Note: SBC requires running inference several times. Using SBC with amortized methods like NPE is hence a justified endavour: repeated inference is cheap and SBC can be performed with little runtime penalty. This does not hold for sequential methods or anything relying on MCMC or VI. Should you require methods of MCMC or VI, consider exploiting parallelization and set <code>num_workers&gt;1</code> in the sbc functions.</p> <pre><code>import torch\nfrom torch import eye, ones\nfrom torch.distributions import MultivariateNormal\n\nfrom sbi.analysis.plot import sbc_rank_plot\nfrom sbi.diagnostics import check_sbc, check_tarp, run_sbc, run_tarp\nfrom sbi.inference import NPE, simulate_for_sbi\n</code></pre> <pre><code>num_dim = 2\nnum_simulations = 10_000\n\nprior_mean = ones(num_dim)\nprior_cov = 2 * eye(num_dim)\nprior = MultivariateNormal(\n    loc=prior_mean, covariance_matrix=prior_cov, validate_args=False\n)\n</code></pre>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#an-ideal-case","title":"An ideal case","text":"<p>To explore SBC, we make our life easy and assume that we deal with a problem where the likelihood is modelled by an identity mapping and a bit of smear. But to start, we only use an almost vanishing smear of <code>0.01</code>.</p> <pre><code>default_likelihood_loc = 0.0  # let's start with 0 shift\ndefault_likelihood_scale = 0.01  # let's smear theta only by a little bit\n\n\ndef simulator(theta, loc=default_likelihood_loc, scale=default_likelihood_scale):\n    \"\"\"linear gaussian inspired by sbibm\n    https://github.com/sbi-benchmark/sbibm/blob/15f068a08a938383116ffd92b92de50c580810a3/sbibm/tasks/gaussian_linear/task.py#L74\n    \"\"\"\n    num_dim = theta.shape[-1]\n    cov_ = scale * eye(num_dim)  # always positively semi-definite\n\n    # using validate_args=False disables sanity checks on `covariance_matrix`\n    # for the sake of speed\n    value = MultivariateNormal(\n        loc=(theta + loc), covariance_matrix=cov_, validate_args=False\n    ).sample()\n    return value\n\n\n_ = torch.manual_seed(3)\ntheta = prior.sample((num_simulations,))\nx = simulator(theta)\n</code></pre> <pre><code>_ = torch.manual_seed(1)\n\n# let's sample an observation from the parameters we\n# just produced\ntheta_o = prior.sample((1,))\nx_o = simulator(theta_o)\nprint(\"theta:\", theta_o.numpy())\nprint(\"x    :\", x_o.numpy())\n</code></pre> <pre><code>theta: [[1.9352932 1.3774877]]\nx    : [[1.941461  1.4396194]]\n</code></pre> <pre><code>_ = torch.manual_seed(2)\n\n# we use a mdn model to have a fast turnaround with training the NPE\ninferer = NPE(prior, density_estimator=\"nsf\")\n# append simulations and run training.\ninferer.append_simulations(theta, x).train(training_batch_size=200);\n</code></pre> <pre><code> Neural network successfully converged after 66 epochs.\n</code></pre> <pre><code>posterior = inferer.build_posterior()\nposterior_samples = posterior.sample((10_000,), x=x_o)\n# Generate predictive samples by simulating from posterior samples.\nposterior_predictive_samples = simulator(posterior_samples)\n</code></pre> <pre><code># let's do some posterior predictive checks to see if the\n# posterior predictive samples cluster aournd the observation `x_o`.\nfrom sbi.analysis import pairplot\n\nfig, ax = pairplot(\n    samples=posterior_predictive_samples,\n    points=x_o,\n    limits=list(zip(x_o.flatten() - 1.0, x_o.flatten() + 1.0)),\n    upper=\"kde\",\n    diag=\"kde\",\n    figsize=(5, 5),\n    labels=[rf\"$x_{d}$\" for d in range(3)],\n)\n</code></pre> <p></p> <p>The observation <code>x_o</code> falls into the support of the predicted posterior samples, i.e. it is within <code>simulator(posterior_samples)</code>. Given the simulator, this is indicative that our posterior estimates the data well.</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#running-sbc","title":"Running SBC","text":"<p>We have a working and trained posterior at this point! Hurray! Let\u2019s look at the SBC metrics now.</p> <pre><code>num_sbc_samples = 200  # choose a number of sbc runs, should be ~100s\n# generate ground truth parameters and corresponding simulated observations for SBC.\nthetas = prior.sample((num_sbc_samples,))\nxs = simulator(thetas)\n</code></pre> <p>SBC is implemented in <code>sbi</code> for your use on any <code>sbi</code> posterior. To run it, we only need to call <code>run_sbc</code> with appropriate parameters.</p> <p>Note: For amortized neural posteriors (like in this tutorial), execution of <code>sbc</code> is expected to be fast. For posteriors that conduct inference with MCMC and hence are slow, <code>run_sbc</code> exposes the use of multiple internal parallel workers to the user. To use this feature, add <code>num_workers = 2</code> to the parameters for use of two workers. See the API documentation for details.</p> <pre><code># run SBC: for each inference we draw 1000 posterior samples.\nnum_posterior_samples = 1_000\nnum_workers = 1\nranks, dap_samples = run_sbc(\n    thetas, xs, posterior, num_posterior_samples=num_posterior_samples, num_workers=num_workers\n)\n</code></pre> <p><code>sbi</code> establishes two methods to do simulation-based calibration:</p> <ul> <li>metrics to compare the sbc ranks with a uniform distribution</li> <li>control plots for visual inspections like fig. 1 or 2 in Talts et al, 2018</li> </ul> <p>The <code>ranks</code> count is performed per dimension of <code>theta</code>, i.e. on the 1-D marginal posterior estimates. According to theory, the distribution of these ranks (per dimension of <code>theta</code>) should turn out to be uniformly distributed.</p> <p>The data average posterior <code>dap</code> (see equation 1 of Talts et al, 2018) is yet another metric of interest. It is built from singular random samples of the estimated posterior samples for each <code>xs</code> above. The <code>dap</code> is expected to match the prior distribution used (see equation 1 in Talts et al, 2018 too).</p> <pre><code>check_stats = check_sbc(\n    ranks, thetas, dap_samples, num_posterior_samples=num_posterior_samples\n)\n</code></pre> <p>The <code>check_stats</code> variable created contains a dictionary with 3 metrics that help to judge our posterior. The \u201cfirst\u201d two compare the ranks to a uniform distribution.</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#ranks-versus-uniform-distribution","title":"Ranks versus Uniform distribution","text":"<pre><code>print(\n    f\"\"\"kolmogorov-smirnov p-values \\n\n    check_stats['ks_pvals'] = {check_stats['ks_pvals'].numpy()}\"\"\"\n)\n</code></pre> <pre><code>kolmogorov-smirnov p-values\n\n    check_stats['ks_pvals'] = [0.1201229 0.2126625]\n</code></pre> <p>The Kolmogorov-Smirnov (KS test, see also here) as used by <code>check_sbc</code> provides p-values <code>pvals</code> on the null hypothesis that the samples from <code>ranks</code> are drawn from a uniform distribution (in other words <code>H_0: PDF(ranks) == PDF(uniform)</code>). We are provided two values as our problem is two-dimensional - one p-value for each dimension.</p> <p>The null hypothesis (of both distributions being equal) is rejected if the p-values fall below a significance threshold (usually <code>&lt; 0.05</code>).  Therefore, the values we see here should ideally be much larger than <code>0.05</code> because the ranks should ideally be close to a uniform distribution. If they are below <code>0.05</code> then this indicates that the posterior is non well-calibrated. Note, however, that we can obtain arbitrarily small p-values if we use a large number of samples, (<code>num_sbc_samples</code>). Note also that this is only a neccessary check, i.e., we can only conclude that the posterior is not miscalibrated, not that it is accurate. </p> <pre><code>print(\n    f\"c2st accuracies \\ncheck_stats['c2st_ranks'] = {check_stats['c2st_ranks'].numpy()}\"\n)\n</code></pre> <pre><code>c2st accuracies \ncheck_stats['c2st_ranks'] = [0.475 0.53 ]\n</code></pre> <p>The second tier of metrics comparing <code>ranks</code> with a uniform distributions is a <code>c2st</code> test (see here for details). This is a nonparametric two sample test based on training a classifier to differentiate two ensembles. Here, these two ensembles are the observed <code>ranks</code> and samples from a uniform distribution. The values reported are the accuracies from n-fold cross-validation. If you see values around <code>0.5</code>, the classifier was unable to differentiate both ensembles, i.e. <code>ranks</code> are very uniform. If the values are high towards <code>1</code>, this matches the case where <code>ranks</code> is very unlike a uniform distribution.</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#data-averaged-posterior-dap-versus-prior","title":"Data averaged posterior (DAP) versus prior","text":"<pre><code>print(f\"- c2st accuracies check_stats['c2st_dap'] = {check_stats['c2st_dap'].numpy()}\")\n</code></pre> <pre><code>- c2st accuracies check_stats['c2st_dap'] = [0.45   0.4875]\n</code></pre> <p>The last metric reported is again based on <code>c2st</code> computed per dimension of <code>theta</code>. If you see values around <code>0.5</code>, the <code>c2st</code> classifier was unable to differentiate both ensembles for each dimension of <code>theta</code>, i.e. <code>dap</code> are much like (if not identical to) the prior. If the values are very high towards <code>1</code>, this represents the case where <code>dap</code> is very unlike the prior distribution.</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#visual-inspection","title":"Visual Inspection","text":"<pre><code>f, ax = sbc_rank_plot(\n    ranks=ranks,\n    num_posterior_samples=num_posterior_samples,\n    plot_type=\"hist\",\n    num_bins=None,  # by passing None we use a heuristic for the number of bins.\n)\n</code></pre> <p>The two plots visualize the distribution of <code>ranks</code> (here depicted in red) in each dimension. Highlighted in grey, you see the 99% confidence interval of a uniform distribution given the number of samples provided. In plain english: for a uniform distribution, we would expect 1 out of 100 (red) bars to lie outside the grey area.</p> <p>We also observe, that the entries fluctuate to some degree. This can be considered a hint that <code>sbc</code> should be conducted with a lot more samples than <code>1000</code>. A good rule of thumb is that given the number of bins <code>B</code> and the number of SBC samples <code>N</code> (chosed to be <code>1_000</code> here) should amount to <code>N / B ~ 20</code>.</p> <pre><code>f, ax = sbc_rank_plot(ranks, 1_000, plot_type=\"cdf\")\n</code></pre> <p></p> <p>The above provides a visual representation of the cumulative density function (CDF) of <code>ranks</code> (blue and orange for each dimension of <code>theta</code>) with respect to the 95% confidence interval of a uniform distribution (grey).</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#multi-dimensional-sbc","title":"multi dimensional SBC","text":"<p>So far, we have performed the SBC checks for each dimension of our parameters \\(\\theta\\) separately. SBI offers a way to perform this check for all dimensions at once.</p> <pre><code># use reduce_fns in order to map the test statistic to only one dimension\nranks, dap_samples = run_sbc(\n    thetas,\n    xs,\n    posterior,\n    num_posterior_samples=num_posterior_samples,\n    reduce_fns=posterior.log_prob,\n)\ncheck_stats = check_sbc(ranks, thetas, dap_samples, 1_000)\nprint(check_stats)\n</code></pre> <pre><code>{'ks_pvals': tensor([0.0468]), 'c2st_ranks': tensor([0.5025], dtype=torch.float64), 'c2st_dap': tensor([0.4500, 0.4850], dtype=torch.float64)}\n</code></pre> <p>In the code above, we depart from the default behavior of <code>run_sbc</code>. The standard behavior of <code>run_sbc</code> is to calculate the SBC ranks of parameters \\(\\theta\\) by comparing the marginal values of the predicted parameter \\(\\theta_i\\) to the reference value \\(\\theta_o\\), i.e. we are ranking each parameter only within its marginal dimension <code>idx</code> which evaluates <code>theta_i[idx] &lt; theta_o[idx]</code> to perform sbc ranking.  </p> <p>The <code>reduce_fns</code> parameter of <code>run_sbc</code> allows users to specify a <code>Callable</code> which is invoked on the tuple <code>(theta,x)</code> before the sbc ranking is performed. As an example, we specify <code>reduce_fns=posterior.log_prob</code> here to rank according to the log probability of theta (given x) under the posterior. This results in the ranking being performed across all dimensions of <code>theta</code> at once (instead of each marginal dimension separately) by reducing <code>theta</code> to the log probabilities under the posterior. Internally, <code>run_sbc</code> would then evaluate <code>posterior.log_prob(theta_i, x_o) &lt; posterior.log_prob(theta_o, x_o)</code> to perform the ranking.</p> <p>Note: The results of <code>check_sbc</code> using ranking <code>posterior.log_prob</code> values from above produce the same conclusion as those using the marginals from further above. <code>ks_pvals</code> is above <code>0.05</code> again and <code>c2st_ranks</code> is about <code>0.5</code> again.</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#when-things-go-haywire","title":"When things go haywire","text":"<p>Next, we would like to explore some pathologies visible in sbc plots which can hint at our estimated posterior being somewhat wrong or completely off.</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#a-shifted-posterior-mean","title":"A shifted posterior mean","text":"<p>In this scenario, we emulate the situation that our posterior estimates incorrectly with a constant shift. We reuse our trained NPE posterior from above and wrap it so that all samples returned expose a constant shift by <code>+0.1</code>.</p> <pre><code>from utils_13_diagnosis_sbc import BiasedPosterior\n\n# this posterior shifts the expected value of the prior by .1\nposterior_ = BiasedPosterior(posterior, shift=0.1)\n</code></pre> <pre><code>ranks, dap_samples = run_sbc(thetas, xs, posterior_)\ncheck_stats = check_sbc(ranks, thetas, dap_samples, 1_000)\nprint(check_stats)\n</code></pre> <pre><code>{'ks_pvals': tensor([1.7612e-37, 1.3333e-34]), 'c2st_ranks': tensor([0.5900, 0.5725], dtype=torch.float64), 'c2st_dap': tensor([0.4350, 0.4950], dtype=torch.float64)}\n</code></pre> <p>We can see that the Kolmogorov-Smirnov p-values vanish (<code>'ks_pvals': tensor([0., 0.])</code>). Thus, we can reject the hypothesis that the <code>ranks</code> PDF is a uniform PDF. The <code>c2st</code> accuracies show values higher than <code>0.5</code>. This is supports as well that the <code>ranks</code> distribution is not a uniform PDF.</p> <pre><code>f, ax = sbc_rank_plot(ranks, 1_000, plot_type=\"hist\", num_bins=30)\n</code></pre> <p></p> <p>Inspecting the histograms for both dimenions, the rank distribution is clearly tilted to low rank values for both dimensions. Because we have shifted the expected value of the posterior to higher values (by <code>0.1</code>), we see more entries at low rank values.</p> <p>Let\u2019s try to shift all posterior samples in the opposite direction. We shift the expectation value by <code>-0.1</code>:</p> <pre><code>posterior_ = BiasedPosterior(posterior, shift=-0.1)\n</code></pre> <pre><code>ranks, dap_samples = run_sbc(thetas, xs, posterior_)\ncheck_stats = check_sbc(ranks, thetas, dap_samples, 1_000)\nprint(check_stats)\nf, ax = sbc_rank_plot(ranks, 1_000, plot_type=\"hist\", num_bins=30)\n</code></pre> <pre><code>{'ks_pvals': tensor([1.6989e-28, 1.6361e-21]), 'c2st_ranks': tensor([0.6200, 0.5475], dtype=torch.float64), 'c2st_dap': tensor([0.4525, 0.4475], dtype=torch.float64)}\n</code></pre> <p></p> <p>A similar behavior is observed, but this time we see an upshot of ranks to higher values of posterior rank. Because we have shifted the expected value of the posterior to smaller values, we see an upshot in high rank counts.</p> <p>The historgams above provide convincing evidence that this is not a uniform distribution.</p> <p>To conlude at this point, the rank distribution is capable of identifying pathologies of the estimated posterior:</p> <ul> <li>a left-skewed rank distribution shows a systematic underestimation of the posterior mean   (we shifted the posterior by <code>0.1</code>)</li> <li>a rank-skewed rank distribution shows a systematic overestimation of the posterior mean   (we shifted the posterior by <code>-0.1</code>)</li> </ul>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#a-dispersed-posterior","title":"A dispersed posterior","text":"<p>In this scenario we emulate the situation if our posterior estimates incorrectly with a dispersion, i.e. the posterior is too wide or too thin. We reuse our trained NPE posterior from above and wrap it so that all samples return a dispersion by 100% more wide (<code>dispersion=2.0</code>), i.e. the variance is overestimated by a factor of 2.</p> <pre><code>from utils_13_diagnosis_sbc import DispersedPosterior\n\n# this posterior which disperses the expected posterior value of the prior by 2.\nposterior_ = DispersedPosterior(posterior, dispersion=2.0)\n</code></pre> <pre><code>ranks, dap_samples = run_sbc(thetas, xs, posterior_)\ncheck_stats = check_sbc(ranks, thetas, dap_samples, 1_000)\nprint(check_stats)\nf, ax = sbc_rank_plot(ranks, 1_000, plot_type=\"hist\", num_bins=30)\n</code></pre> <pre><code>{'ks_pvals': tensor([0.0006, 0.0003]), 'c2st_ranks': tensor([0.4800, 0.4900], dtype=torch.float64), 'c2st_dap': tensor([0.4375, 0.4850], dtype=torch.float64)}\n</code></pre> <p></p> <p>The rank histograms now look more like a very wide gaussian distribution centered in the middle. The KS p-values again vanish unsurprisingly (we must reject the hypothesis that both distributions are from the same uniform PDF) and the c2st_ranks indicate that the rank histogram is not uniform too. As our posterior samples are distributed too broad now, we obtain more \u201cmedium\u201d range ranks and hence produce the peak of ranks in the center of the histogram.</p> <p>We can repeat this exercise by making our posterior too thin, i.e. the variance of the posterior is too small. Let\u2019s cut it by half (<code>dispersion=0.5</code>).</p> <pre><code>posterior_ = DispersedPosterior(posterior, dispersion=0.5)\n</code></pre> <pre><code>ranks, dap_samples = run_sbc(thetas, xs, posterior_)\ncheck_stats = check_sbc(ranks, thetas, dap_samples, 1_000)\nprint(check_stats)\nf, ax = sbc_rank_plot(ranks, 1_000, plot_type=\"hist\", num_bins=30)\n</code></pre> <pre><code>{'ks_pvals': tensor([2.8365e-01, 1.3149e-04]), 'c2st_ranks': tensor([0.4950, 0.5300], dtype=torch.float64), 'c2st_dap': tensor([0.4175, 0.4750], dtype=torch.float64)}\n</code></pre> <p></p> <p>The histogram of ranks now shoots above the allowed (greyed) area for a uniform distributed around the extrema. We made the posterior samples too thin, so we received more extreme counts of ranks. The KS p-values vanish again and the <code>c2st</code> metric of the ranks is also larger than <code>0.5</code> which underlines that our rank distribution is not uniformly distributed.</p> <p>We again see, the rank distribution is capable of identifying pathologies of the estimated posterior:</p> <ul> <li>a centrally peaked rank distribution shows a systematic over-estimation of the posterior variance   (we dispersed the variance of the posterior by a factor of <code>2</code>)</li> <li>a U shaped rank distribution shows a systematic under-estimation of the posterior variance   (we dispersed the variance of the posterior by a factor of <code>.5</code>)</li> </ul> <p>Simulation-based calibration offers a direct handle on which pathology an estimated posterior examines. Outside of this tutorial, you may very well encounter situations with mixtures of effects (a shifted mean and over-estimated variance). Moreover, uncovering a malignant posterior is only the first step to fix your analysis.</p>"},{"location":"tutorials/11_diagnostics_simulation_based_calibration/#posterior-calibration-with-tarp-lemos-et-al-2023","title":"Posterior calibration with TARP (Lemos et al. 2023)","text":"<p>TARP is an alternative calibration check proposed recently in https://arxiv.org/abs/2302.03026.  It is implemented in the <code>sbi</code> package as well, following a very similar API than above.</p> <p>Given a test set \\((\\theta^*, x^*)\\) and a set of reference points \\(\\theta_r\\), TARP calculates  statistics for posterior calibration by  - drawing posterior samples \\(\\theta\\) given each \\(x_*\\) - calculating the distance \\(r\\) between \\(\\theta_*\\) and \\(\\theta_r\\) - counting for how many of the posterior samples their distance to \\(\\theta_r\\) is smaller than \\(r\\)</p> <p>See https://arxiv.org/abs/2302.03026, Figure 2, for an illustration.</p> <p>For each given coverage level \\(\\alpha\\), one can then calculate the corresponding average counts and check, whether they correspond to the given \\(\\alpha\\). </p> <p>The visualization and interpretation of TARP is therefore similar to that of SBC.</p> <pre><code>num_tarp_samples = 200  # choose a number of sbc runs, should be ~100s\n# generate ground truth parameters and corresponding simulated observations for SBC.\nthetas = prior.sample((num_tarp_samples,))\nxs = simulator(thetas)\n</code></pre> <pre><code># the tarp method returns the ECP values for a given set of alpha coverage levels.\necp, alpha = run_tarp(\n    thetas,\n    xs,\n    posterior,\n    references=None,  # will be calculated automatically.\n    num_posterior_samples=1000,\n)\n</code></pre> <pre><code># Similar to SBC, we can check then check whether the distribution of ecp is close to\n# that of alpha.\natc, ks_pval = check_tarp(ecp, alpha)\nprint(atc, \"Should be close to 0\")\nprint(ks_pval, \"Should be larger than 0.05\")\n</code></pre> <pre><code>0.757999837398529 Should be close to 0\n0.999115261755522 Should be larger than 0.05\n</code></pre> <pre><code># Or, we can perform a visual check.\nfrom sbi.analysis.plot import plot_tarp\nplot_tarp(ecp, alpha);\n</code></pre> <p></p> <p>In contrast to SBC (Talts et al.) and coverage based highest posterior density regions (Deistler et al.,), TARP provides a necessary and sufficient condition for posterior accuracy, i.e., it can also detect inaccurate posterior estimators. </p> <p>Note, however, that this property depends on the choice of reference point distribution: to obtain the full diagnostic power of TARP, one would need to sample reference points from a distribution that depends on \\(x\\). Thus, in general, we recommend using and interpreting TARP like SBC and complementing coverage checks with posterior predictive checks.</p>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/","title":"SBI with iid data and permutation-invariant embeddings","text":"<p>There are scenarios in which we observe multiple data points per experiment and we can assume that they are independent and identically distributed (iid, i.e., they are assumed to have the same underlying model parameters). For example, in decision-making experiments, the experiment is often repeated in trials with the same experimental settings and conditions. The corresponding set of trials is then assumed to be \u201ciid\u201d given a single parameter set. In such a scenario, we may want to obtain the posterior given a set of observation \\(p(\\theta | X=\\{x_i\\}_i^N)\\).</p>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/#amortization-of-neural-network-training-iid-inference-with-nle-nre","title":"Amortization of neural network training: iid-inference with NLE / NRE","text":"<p>For some SBI variants the iid assumption can be exploited: when using a likelihood-based SBI method (<code>NLE</code>, <code>NRE</code>) one can train the density or ratio estimator on single-trial data, and then perform inference with <code>MCMC</code> or variational inference (<code>VI</code>). Crucially, because the data is iid and the estimator is trained on single-trial data, one can repeat the inference with a different <code>x_o</code> (a different set of trials, or different number of trials) without having to retrain the density estimator. One can interpet this as amortization of the SBI training: we can obtain a neural likelihood, or likelihood-ratio estimate for new <code>x_o</code>s without retraining, but we still have to run <code>MCMC</code> or <code>VI</code> to do inference.</p> <p>In addition, one cannot only change the number of trials of a new <code>x_o</code>, but also the entire inference setting. For example, one can apply hierarchical inference with changing hierarchical denpendencies between the model parameters\u2013all without having to retrain the density estimator because it estimates single-trail likelihoods.</p>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/#full-amortization-iid-inference-with-npe-and-permutation-invariant-embedding-nets","title":"Full amortization: iid-inference with NPE and permutation-invariant embedding nets","text":"<p>When performing neural posterior estimation (<code>NPE</code>) we cannot exploit the iid assumption directly. Thus, the underlying neural network takes <code>x</code> as input and predicts the parameters of the density estimator. As a consequence, if <code>x</code> is a set of iid observations \\(X=\\{x_i\\}_i^N\\) then the neural network has to be invariant to permutations of this set, i.e., it has to be permutation invariant. In addition, the neural network has to be able to consume a varying number of iid datapoints in order to be amortized over the number of trials. Therefore, in order to use <code>NPE</code> for inference on iid data, we need to provide a corresponding embedding network that handles the iid-data. This will likely require some hyperparameter tuning and more training data for inference to work accurately. But once we have this, inference is fully amortized, i.e., we can get new posterior samples almost instantly without retraining and without running <code>MCMC</code> or <code>VI</code>.</p>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/#sbi-with-trial-based-data","title":"SBI with trial-based data","text":"<p>For illustration, we use a simple linear Gaussian simulator, as in previous tutorials. The simulator takes a single parameter (vector) which is the mean of a Gaussian. The simulator then adds noise with a fixed variance (set to one). We define a Gaussian prior over the mean and perform inference.</p> <p>The observed data is also sampled from a Gaussian with some fixed \u201cground-truth\u201d parameter \\(\\theta_o\\). Crucially, the observed data <code>x_o</code> can consist of multiple samples given the same ground-truth parameters and these samples are iid given \\(\\theta\\):</p> \\[ \\theta \\sim \\mathcal{N}(\\mu_0,\\; \\Sigma_0) \\\\ x | \\theta \\sim \\mathcal{N}(\\theta,\\; \\Sigma=I) \\\\ \\mathbf{x_o} = \\{x_o^i\\}_{i=1}^N \\sim  \\mathcal{N}(\\theta_o,\\; \\Sigma=I) \\] <p>For this toy problem, the ground-truth posterior is well defined, it is again a Gaussian, centered on the mean of \\(\\mathbf{x_o}\\) and with variance scaled by the number of trials \\(N\\), i.e., the more trials we observe, the more information about the underlying \\(\\theta_o\\) we have and the more concentrated the posteriors becomes.</p> <p>We will illustrate this below:</p> <pre><code>import matplotlib.pyplot as plt\nimport torch\nfrom torch import eye, zeros\nfrom torch.distributions import MultivariateNormal\n\nfrom sbi.analysis import pairplot\nfrom sbi.inference import NLE, NPE, simulate_for_sbi\nfrom sbi.simulators.linear_gaussian import (\n    linear_gaussian,\n    true_posterior_linear_gaussian_mvn_prior,\n)\nfrom sbi.utils.metrics import c2st\nfrom sbi.utils.user_input_checks import (\n    check_sbi_inputs,\n    process_prior,\n    process_simulator,\n)\n\n# Seeding\ntorch.manual_seed(1);\n</code></pre> <pre><code># Gaussian simulator\ntheta_dim = 2\nx_dim = theta_dim\n\n# likelihood_mean will be likelihood_shift+theta\nlikelihood_shift = -1.0 * zeros(x_dim)\nlikelihood_cov = 0.3 * eye(x_dim)\n\nprior_mean = zeros(theta_dim)\nprior_cov = eye(theta_dim)\nprior = MultivariateNormal(loc=prior_mean, covariance_matrix=prior_cov)\n\n# Define Gaussian simulator\nprior, num_parameters, prior_returns_numpy = process_prior(prior)\nsimulator = process_simulator(\n    lambda theta: linear_gaussian(theta, likelihood_shift, likelihood_cov),\n    prior,\n    prior_returns_numpy,\n)\ncheck_sbi_inputs(simulator, prior)\n\n\n# Use built-in function to obtain ground-truth posterior given x_o\ndef get_true_posterior_samples(x_o, num_samples=1):\n    return true_posterior_linear_gaussian_mvn_prior(\n        x_o, likelihood_shift, likelihood_cov, prior_mean, prior_cov\n    ).sample((num_samples,))\n</code></pre>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/#the-analytical-posterior-concentrates-around-true-parameters-with-increasing-number-of-iid-trials","title":"The analytical posterior concentrates around true parameters with increasing number of IID trials","text":"<pre><code>num_trials = [1, 5, 15, 20]\ntheta_o = zeros(1, theta_dim)\n\n# Generate multiple x_os with increasing number of trials.\nxos = [theta_o.repeat(nt, 1) for nt in num_trials]\n\n# Obtain analytical posterior samples for each of them.\ntrue_samples = [get_true_posterior_samples(xo, 1000) for xo in xos]\n</code></pre> <pre><code># Plot them in one pairplot as contours (obtained via KDE on the samples).\nfig, ax = pairplot(\n    true_samples,\n    points=theta_o,\n    diag=\"kde\",\n    upper=\"contour\",\n    diag_kwargs=dict(bins=100),\n    upper_kwargs=dict(levels=[0.95]),\n    fig_kwargs=dict(\n        points_colors=[\"k\"],\n        points_offdiag=dict(marker=\"*\", markersize=10),\n    ),\n)\nplt.sca(ax[1, 1])\nplt.legend(\n    [f\"{nt} trials\" if nt &gt; 1 else f\"{nt} trial\" for nt in num_trials]\n    + [r\"$\\theta_o$\"],\n    frameon=False,\n    fontsize=12,\n);\n</code></pre> <p>Indeed, with increasing number of trials the posterior density concentrates around the true underlying parameter.</p>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/#iid-inference-with-nle","title":"IID inference with NLE","text":"<p>(S)NLE and (S)NRE can perform inference given multiple IID obserations by using only single-trial training data (i.e., for training, we run the simulator only once per parameter set). Once the likelihood is learned on single trials (i.e., a neural network that predicts the likelihood of a single observation given a parameter set), one can sample the posterior for any number of trials. This works because, given a single-trial neural likelihood from (S)NLE or (S)NRE, we can calculate the joint likelihoods of all trials by multiplying them together (or adding them in log-space). The joint likelihood can then be plugged into <code>MCMC</code> or <code>VI</code>. <code>sbi</code> takes care of all of these steps, so you do not have to implement anything yourself:</p> <pre><code># Train NLE.\ninferer = NLE(prior, show_progress_bars=True, density_estimator=\"mdn\")\ntheta, x = simulate_for_sbi(simulator, prior, 10000, simulation_batch_size=1000)\ninferer.append_simulations(theta, x).train(training_batch_size=1000);\n</code></pre> <pre><code> Neural network successfully converged after 71 epochs.\n</code></pre> <pre><code># Obtain posterior samples for different number of iid xos.\nnle_samples = []\nnum_samples = 1000\n\nmcmc_parameters = dict(\n    num_chains=50,\n    thin=5,\n    warmup_steps=30,\n    init_strategy=\"proposal\",\n)\nmcmc_method = \"slice_np_vectorized\"\n\nposterior = inferer.build_posterior(\n    mcmc_method=mcmc_method,\n    mcmc_parameters=mcmc_parameters,\n)\n\n# Generate samples with MCMC given the same set of x_os as above.\nfor xo in xos:\n    nle_samples.append(posterior.sample(sample_shape=(num_samples,), x=xo))\n</code></pre> <p>Note that <code>sbi</code> warns about <code>iid-x</code> with increasing number of trial here. We ignore the warning because that\u2019s exactly what we want to do.</p> <pre><code># Plot them in one pairplot as contours (obtained via KDE on the samples).\nfig, ax = pairplot(\n    nle_samples,\n    points=theta_o,\n    diag=\"kde\",\n    upper=\"contour\",\n    diag_kwargs=dict(bins=100),\n    upper_kwargs=dict(levels=[0.95]),\n    fig_kwargs=dict(\n        points_colors=[\"k\"],\n        points_offdiag=dict(marker=\"*\", markersize=10),\n    ),\n)\nplt.sca(ax[1, 1])\nplt.legend(\n    [f\"{nt} trials\" if nt &gt; 1 else f\"{nt} trial\" for nt in num_trials]\n    + [r\"$\\theta_o$\"],\n    frameon=False,\n    fontsize=12,\n);\n</code></pre> <p></p> <p>The pairplot above already indicates that (S)NLE is well able to obtain accurate posterior samples also for increasing number of trials (note that we trained the single-round version of NLE so that we did not have to re-train it for new \\(x_o\\)).</p> <p>Quantitatively we can measure the accuracy of NLE by calculating the <code>c2st</code> score between NLE and the true posterior samples, where the best accuracy is perfect for <code>0.5</code>:</p> <pre><code>cs = [\n    c2st(s1, s2)\n    for s1, s2 in zip(true_samples, nle_samples)\n]\n\nfor _ in range(len(num_trials)):\n    print(f\"c2st score for num_trials={num_trials[_]}: {cs[_].item():.2f}\")\n</code></pre> <pre><code>c2st score for num_trials=1: 0.50\nc2st score for num_trials=5: 0.51\nc2st score for num_trials=15: 0.51\nc2st score for num_trials=20: 0.51\n</code></pre>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/#iid-inference-with-npe-using-permutation-invariant-embedding-nets","title":"IID inference with NPE using permutation-invariant embedding nets","text":"<p>For NPE we need to define an embedding net that handles the set-like structure of iid-data, i.e., that it permutation invariant and can handle different number of trials.</p> <p>We implemented several embedding net classes that allow to construct such a permutation- and number-of-trials invariant embedding net.</p> <p>To become permutation invariant, the neural net first learns embeddings for single trials and then performs a permutation invariant operation on those embeddings, e.g., by taking the sum or the mean (Chen et al. 2018, Radev et al. 2021).</p> <p>To become invariant w.r.t. the number-of-trials, we train the net with varying number of trials for each parameter setting. This means that, unlike for (S)NLE and (S)NRE, (S)NPE requires to run the simulator multiple times for individual parameter sets to generate the training data.</p> <p>In order to implement this in <code>sbi</code>, \u201cunobserved\u201d trials in the training dataset have to be masked by NaNs (and ignore the resulting SBI warning about NaNs in the training data).</p>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/#construct-training-data-set","title":"Construct training data set.","text":"<pre><code># we need to fix the maximum number of trials.\nmax_num_trials = 20\n\n# construct training data set: we want to cover the full range of possible number of\n# trials\nnum_training_samples = 1000\ntheta = prior.sample((num_training_samples,))\n\n# there are certainly smarter ways to construct the training data set, but we go with a\n# for loop here for illustration purposes.\nx = torch.ones(num_training_samples * max_num_trials, max_num_trials, x_dim) * float(\n    \"nan\"\n)\nfor i in range(num_training_samples):\n    xi = simulator(theta[i].repeat(max_num_trials, 1))\n    for j in range(max_num_trials):\n        x[i * max_num_trials + j, : j + 1, :] = xi[: j + 1, :]\n\ntheta = theta.repeat_interleave(max_num_trials, dim=0)\n</code></pre>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/#build-embedding-net","title":"Build embedding net","text":"<pre><code>from sbi.neural_nets.embedding_nets import FCEmbedding, PermutationInvariantEmbedding\nfrom sbi.neural_nets import posterior_nn\n\n# embedding\nlatent_dim = 10\nsingle_trial_net = FCEmbedding(\n    input_dim=theta_dim,\n    num_hiddens=40,\n    num_layers=2,\n    output_dim=latent_dim,\n)\nembedding_net = PermutationInvariantEmbedding(\n    single_trial_net,\n    trial_net_output_dim=latent_dim,\n    # NOTE: post-embedding is not needed really.\n    num_layers=1,\n    num_hiddens=10,\n    output_dim=10,\n)\n\n# we choose a simple MDN as the density estimator.\n# NOTE: we turn off z-scoring of the data, as we used NaNs for the missing trials.\ndensity_estimator = posterior_nn(\"mdn\", embedding_net=embedding_net, z_score_x=\"none\")\n</code></pre>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/#run-training","title":"Run training","text":"<pre><code>inference = NPE(prior, density_estimator=density_estimator)\n# NOTE: we don't exclude invalid x because we used NaNs for the missing trials.\ninference.append_simulations(\n    theta,\n    x,\n    exclude_invalid_x=False,\n).train(training_batch_size=1000)\nposterior = inference.build_posterior()\n</code></pre> <pre><code> Neural network successfully converged after 276 epochs.\n</code></pre>"},{"location":"tutorials/12_iid_data_and_permutation_invariant_embeddings/#amortized-inference","title":"Amortized inference","text":"<p>Comparing runtimes, we see that the NPE training takes a bit longer than the training on single trials for <code>NLE</code> above.</p> <p>However, we trained the density estimator such that it can handle multiple and changing number of iid trials (up to 20).</p> <p>Thus, we can obtain posterior samples for different <code>x_o</code> with just a single forward pass instead of having to run <code>MCMC</code> for each new observation.</p> <p>As you can see below, the c2st score for increasing number of observed trials remains close to the ideal <code>0.5</code>.</p> <pre><code>npe_samples = []\nfor xo in xos:\n    # we need to pad the x_os with NaNs to match the shape of the training data.\n    xoi = torch.ones(1, max_num_trials, x_dim) * float(\"nan\")\n    xoi[0, : len(xo), :] = xo\n    npe_samples.append(posterior.sample(sample_shape=(num_samples,), x=xoi))\n\ncs = [c2st(s1, s2) for s1, s2 in zip(true_samples, npe_samples)]\n\nfor _ in range(len(num_trials)):\n    print(f\"c2st score for num_trials={num_trials[_]}: {cs[_].item():.2f}\")\n</code></pre> <pre><code>c2st score for num_trials=1: 0.52\nc2st score for num_trials=5: 0.52\nc2st score for num_trials=15: 0.51\nc2st score for num_trials=20: 0.51\n</code></pre> <pre><code>num_trials = [1, 5, 15, 20]\nxos = [theta_o.repeat(nt, 1) for nt in num_trials]\n\nnpe_samples = []\nfor xo in xos:\n    # we need to pad the x_os with NaNs to match the shape of the training data.\n    xoi = torch.ones(1, max_num_trials, x_dim) * float(\"nan\")\n    xoi[0, : len(xo), :] = xo\n    npe_samples.append(posterior.sample(sample_shape=(num_samples,), x=xoi))\n\n\n# Plot them in one pairplot as contours (obtained via KDE on the samples).\nfig, ax = pairplot(\n    npe_samples,\n    points=theta_o,\n    diag=\"kde\",\n    upper=\"contour\",\n    diag_kwargs=dict(bins=100),\n    upper_kwargs=dict(levels=[0.95]),\n    fig_kwargs=dict(\n        points_colors=[\"k\"],\n        points_offdiag=dict(marker=\"*\", markersize=10\n        ),\n    )\n)\nplt.sca(ax[1, 1])\nplt.legend(\n    [f\"{nt} trials\" if nt &gt; 1 else f\"{nt} trial\" for nt in num_trials]\n    + [r\"$\\theta_o$\"],\n    frameon=False,\n    fontsize=12,\n);\n</code></pre> <p></p> <pre><code># We can easily obtain posteriors for many different x_os, instantly, because\n# NPE is fully amortized:\nnum_trials = [2, 4, 6, 8, 12, 14, 18]\nnpe_samples = []\nfor xo in xos:\n    # we need to pad the x_os with NaNs to match the shape of the training data.\n    xoi = torch.ones(1, max_num_trials, x_dim) * float(\"nan\")\n    xoi[0, : len(xo), :] = xo\n    npe_samples.append(posterior.sample(sample_shape=(num_samples,), x=xoi))\n\n\n# Plot them in one pairplot as contours (obtained via KDE on the samples).\nfig, ax = pairplot(\n    npe_samples,\n    points=theta_o,\n    diag=\"kde\",\n    upper=\"contour\",\n    diag_kwargs=dict(bins=100),\n    upper_kwargs=dict(levels=[0.95]),\n    fig_kwargs=dict(\n        points_colors=[\"k\"],\n        points_offdiag=dict(marker=\"*\", markersize=10),\n    ),\n)\nplt.sca(ax[1, 1])\nplt.legend(\n    [f\"{nt} trials\" if nt &gt; 1 else f\"{nt} trial\" for nt in num_trials]\n    + [r\"$\\theta_o$\"],\n    frameon=False,\n    fontsize=12,\n);\n</code></pre> <p></p>"},{"location":"tutorials/13_diagnostics_lc2st/","title":"Local Classifier Two-Sample Tests (\\(\\ell\\)-C2ST)","text":"<p>After a density estimator has been trained with simulated data to obtain a posterior, the estimator should be made subject to several diagnostic tests. This diagnostic should be performed before the posterior is used for inference given the actual observed data. </p> <p>Posterior Predictive Checks (see tutorial 10) provide one way to \u201ccritique\u201d a trained estimator via its predictive performance. </p> <p>Another approach is Simulation-Based Calibration (SBC, see tutorial 11). SBC evaluates whether the estimated posterior is balanced, i.e., neither over-confident nor under-confident. These checks are performed in expectation (on average) over the observation space, i.e. they are performed on a set of \\((\\theta,x)\\) pairs sampled from the joint distribution over simulator parameters \\(\\theta\\) and corresponding observations \\(x\\). As such, SBC is a global validation method that can be viewed as a necessary condition (but not sufficient) for a valid inference algorithm: If SBC checks fail, this tells you that your inference is invalid. If SBC checks pass, this is no guarantee that the posterior estimation is working.</p> <p>Local Classifier Two-Sample Tests (\\(\\ell\\)-C2ST) as developed by Linhart et al, 2023 present a new local validation method that allows to evaluate the correctness of the posterior estimator at a fixed observation, i.e. they work on a single \\((\\theta,x)\\) pair. They provide necessary and sufficient conditions for the validity of the SBI algorithm, as well as easy-to-interpret qualitative and quantitative diagnostics. </p> <p>If global checks (like SBC) fail, \\(\\ell\\)-C2ST allows to further investigate where (for which observation) and why (bias, overdispersion, etc.) the posterior estimator fails. If global validation checks pass, \\(\\ell\\)-C2ST allows to guarantee whether the inference is correct for a specific observation.</p>"},{"location":"tutorials/13_diagnostics_lc2st/#in-a-nutshell","title":"In a nutshell","text":"<p>Suppose you have an \u201camortized\u201d posterior estimator \\(q_\\phi(\\theta\\mid x)\\), meaning that we can quickly get samples for any new observation \\(x\\). The goal is to test the local consistency of our estimator at a fixed observation \\(x_\\mathrm{o}\\), i.e. whether the following null hypothesis holds about \\(q_\\phi(\\theta\\mid x)\\) and the true posterior \\(p(\\theta\\mid x)\\):</p> \\[\\mathcal{H}_0(x_\\mathrm{o}) := q_\\phi(\\theta\\mid x_\\mathrm{o}) = p(\\theta \\mid x_\\mathrm{o}), \\quad \\forall \\theta \\in \\mathbb{R}^m\\] <p>To run \\(\\ell\\)-C2ST, </p> <ol> <li>we sample new parameters from the prior of the problem at hand: \\(\\Theta_i \\sim p(\\theta)\\)</li> <li>we simulate corresponding \u201cobservations\u201d: \\(X_i = \\mathrm{Simulator}(\\Theta_i) \\sim p(x\\mid \\Theta_i)\\)</li> <li>we sample the estimated posterior at each observation: \\(Q_i \\sim q_\\phi(\\theta \\mid X_i)\\)</li> </ol> <p>This creates a calibration dataset of samples from the \u201cestimated\u201d and true joint distributions on which we train a binary classifier \\(d(\\theta, x)\\) to distinguish between the estimated joint \\(q(\\theta \\mid x)p(x)\\) (class \\(C=0\\)) and the true joint distribution \\(p(\\theta)p(x\\mid\\theta)\\) (class \\(C=1\\)):</p> \\[\\mathcal{D}_\\mathrm{cal} = \\left \\{\\underbrace{(Q_i, X_i)}_{(C=0)} \\cup \\underbrace{(\\Theta_i, X_i)}_{(C=1)} \\right \\}_{i=1}^{N_\\mathrm{cal}}\\] <p>Note: \\(D_\\mathrm{cal}\\) contains data from the joint distribution (over prior and simulator) that have to be different from the data used to train the posterior estimator. \\(N_\\mathrm{cal}\\) is typically smaller than \\(N_\\mathrm{train}\\), the number of training samples for the posterior estimator, but has to be sufficiently large to allow the convergence of the classifier. For a fixed simulation budget, a rule of thumb is to use \\(90\\%\\) for the posterior estimation and \\(10\\%\\) for the calibration.</p> <p>Once the classifier is trained, we evaluate it for a given observation \\(x^\\star\\) and multiple samples \\(Q^\\star_i \\sim q_\\phi(\\theta \\mid x^\\star)\\). This gives us a set of predicted probabilities \\(\\left\\{d(Q^\\star_i, x^\\star)\\right\\}_{i=1}^{N_\\mathrm{eval}}\\) that are then used to compute the different diagnostics. This proceedure can be repeated for several different observations, without having to retrain the classifiers, which allows to perform an efficient and thorough analysis of the failure modes of the posterior estimator.</p> <p>Note: The number of evaluation samples can be arbitrarily large (typically we use \\(N_\\mathrm{eval} = 10\\,000\\)), because we suppose our posterior estimator to be amortized. </p>"},{"location":"tutorials/13_diagnostics_lc2st/#key-ideas-behind-ell-c2st","title":"Key ideas behind \\(\\ell\\)-C2ST","text":"<p>\\(\\ell\\)-C2ST allows to evaluate the correctness your posterior estimator without requiring access to samples from the true posterior. It is built on the following two key ideas:</p> <ol> <li> <p>Train the classifier on the joint: this allows to implicitly learn the distance between the true and estimated posterior for any observation (we could call this step \u201camortized\u201d C2ST training). </p> </li> <li> <p>Local evaluation on data from one class only: we use a metric that, as opposed to the accuracy (used in C2ST) does not require samples from the true posterior, only the estimator. It consists in the Mean Squared Error (MSE) between the predicted probabilities for samples from the estimator evaluated at the given observation and one half.</p> </li> </ol> <p>Note: A predicted probability of one half corresponds to the chance level or total uncertainty of the classifier, that is unable to distinguish between the two data classes.</p> <p>The MSE metric is used as a test statistic for a hypothesis test that gives us theoretical guarantees on the correctness of the posterior estimator (at the considered observation), as well as easy-to-interpret diagnostics that allow to investigate its failure modes.</p> <p>Quick reminder on hypothesis tests. Additionaly to the observed test statistic \\(T^\\star\\), evaluating the test requires to 1. compute the test statistics \\(T_h\\) under the null hyposthesis (H0) of equal (true and estimated) distributions over multiple trials \\(h\\). 2. compute the p-value \\(p_v = \\frac{1}{H}\\sum_{h=1}^H \\mathbb{I}(T_h &gt; T^\\star)\\): \u201cHow many times is the observed test statistic \u201cbetter\u201d (i.e. below) the test statistic computed under H0?\u201d 3. choose a significance level \\(\\alpha\\) (typically \\(0.05\\)) that defines the rejection threshold and evaluate the test: - quantitatively: a p-value below this level indicates the rejection of the null hypothesis, meaning the detection of significant differences between the true and the estimated posterior.  - qualitatively: P-P plots: visually check whether the distribution of \\(T^\\star\\) falls into the \\(1-\\alpha\\) confidence region, computed by taking the corresponding quantiles of \\((T_1,\\dots, T_H)\\).</p>"},{"location":"tutorials/13_diagnostics_lc2st/#what-can-ell-c2st-diagnose","title":"What can \\(\\ell\\)-C2ST diagnose?","text":"<ul> <li> <p>Quantitatively: the MSE metric (or test statistic) gives us a distance measure between the estimated and true posterior that can be quickly evaluated for any new observation \\(x^\\star\\). Comparing it to the values of the null-distribution gives us the p-values that are used to check how significant their differences are. If the check passes (no significant differences), this tells us that we can be confident about the correctness of the estimator, but only upto to a certain confidence level (typically \\(95\\%\\)). </p> </li> <li> <p>Qualitatively: we can choose to look at the predicted probabilities used to compute the MSE metric. P-P plots allow to evaluate a general trend of over or under confidence, by comparing theire distribution to the confidence region (obtained for probabilities predicted under H0). We can go further and map these predicted probabilities to a pairplot of the samples they were evaluated on, shows us the regions of over and underconfidence of the estimator. This allows us to investigate the nature of the inconsistencies, such as positive/negative bias or under/over dispersion.</p> </li> </ul> <p>Note: High (resp. low) predicted probability indicates that the classifier is confident about the fact that the sample belongs to the estimated posterior (resp. to the true posterior). This means that the estimator associates too much (resp. not enough) mass to this sample. In other words it is \u201cover-confident\u201d (resp. \u201cunder-confident\u201d). </p> <p>To summarize \\(\\ell\\)-C2ST can:</p> <ul> <li>tell you whether your posterior estimator is valid for a given observation (with a guaranteed confidence)</li> <li>show you where (for which observation) and why (bais, overdispersion, etc.) it fails </li> </ul>"},{"location":"tutorials/13_diagnostics_lc2st/#illustration-on-a-benchmark-sbi-example","title":"Illustration on a benchmark SBI example","text":"<p>We consider the Gaussian Mixture SBI task from Lueckmann et al, 2021. It consists of inferring the common mean of a mixture of two 2D Gaussian distributions, one with much broader covariance than the other: - Prior: \\(p(\\theta) = \\mathcal{U}(-10,10)\\) - Simulator: \\(p(x|\\theta) = 0.5 \\mathcal{N}(\\theta, \\mathbf{I}_2)+ 0.5 \\mathcal{N}(\\theta, 0.1 \\times \\mathbf{I}_2)\\) - Dimensionality: \\(\\theta \\in \\mathbb{R}^2\\), \\(x \\in \\mathbb{R}^2\\)</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\n</code></pre>"},{"location":"tutorials/13_diagnostics_lc2st/#sbi-task","title":"SBI Task","text":"<pre><code>from sbi.simulators.gaussian_mixture import (\n    gaussian_mixture,\n    uniform_prior_gaussian_mixture,\n)\n\n# SBI task: prior and simualtor\ndim = 2\nprior = uniform_prior_gaussian_mixture(dim=dim)\nsimulator = gaussian_mixture\n\n# Number of samples for training, calibration and evaluation\nNUM_TRAIN = 10_000\nNUM_CAL = int(0.1 * NUM_TRAIN) # 10% of the training data\nNUM_EVAL = 10_000\n</code></pre>"},{"location":"tutorials/13_diagnostics_lc2st/#posterior-inference","title":"Posterior Inference","text":"<p>We use neural posterior estimation as our SBI-algorithm with a MAF as underlying density estimator. </p> <p>Note: Here you could use any other SBI algorithm of your own choosing (e.g. NRE, NLE, etc.). IMPORTANT: make sure it is amortized (which corresponds to sequential methods with a signle round), so sampling the posterior can be performed quickly.</p> <p>We train the estimator on a small training set (<code>small_num_train=1000</code>) over a small number of epochs (<code>max_num_epochs=10</code>), which means that it doesn\u2019t converge. Therefore the diagnostics should detect major differences between the estimated and the true posterior, i.e. the null hypothesis is rejected.</p> <p>Note: You can play with the number of training samples or epochs to see whether this influences the quality of the posterior estimator and how it is reflected in the diagnostics.</p> <pre><code>from sbi.inference import NPE\n\ntorch.manual_seed(42) # seed for reproducibility\n\n# Sample training data for the density estimator\nsmall_num_train = 1000\ntheta_train = prior.sample((NUM_TRAIN,))[:small_num_train]\nx_train = simulator(theta_train)[:small_num_train]\n\n# Train the neural posterior estimators\ntorch.manual_seed(42) # seed for reproducibility\ninference = NPE(prior, density_estimator='maf', device='cpu')\ninference = inference.append_simulations(theta=theta_train, x=x_train)\nnpe = inference.train(training_batch_size=256, max_num_epochs=10)\nposterior = inference.build_posterior()\n</code></pre> <pre><code> Training neural network. Epochs trained: 11\n</code></pre>"},{"location":"tutorials/13_diagnostics_lc2st/#evaluate-the-posterior-estimator","title":"Evaluate the posterior estimator","text":"<p>We choose to evaluate the posterior estimator at three different observations, simulated from parameters independently sampled from the prior:  \\(\\(\\theta^\\star_i \\sim p(\\theta) \\quad \\rightarrow \\quad x^\\star_i \\sim p(x\\mid \\theta_i), \\quad i=1,2,3~.\\)\\)</p> <pre><code>from sbi.simulators.gaussian_mixture import (\n    samples_true_posterior_gaussian_mixture_uniform_prior,\n)\n\n# get reference observations\ntorch.manual_seed(0) # seed for reproducibility\nthetas_star = prior.sample((3,))\nxs_star = simulator(thetas_star)\n\n# Sample from the true and estimated posterior\nref_samples_star = {}\nfor i,x in enumerate(xs_star):\n    ref_samples_star[i] = samples_true_posterior_gaussian_mixture_uniform_prior(\n        x_o=x[None,:],\n        num_samples=1000,\n    )\npost_samples_star = posterior.sample_batched((10000,), x=xs_star).permute(1,0,2)\n</code></pre>"},{"location":"tutorials/13_diagnostics_lc2st/#set-up-ell-c2st","title":"Set-up \\(\\ell\\)-C2ST","text":"<p>To setup the hypothesis test, we train the classifiers on the calibration dataset in two settings: - <code>train_under_null_hypothesis</code>: uses the permutation method to train the classifiers under the nulll hypothesis over several trials - <code>train_on_observed_data</code>: train the the classifier once on the observed data.</p> <p>For any new observation <code>x_o</code>, this allows to quickly compute (without having to retrain the classifiers) the test statistics <code>T_null</code> under the null hypothesis and <code>T_data</code> on the observed data. They will be used to compute the diagnostics (p-value or P-P plots).</p> <p>Note: we choose the default configuration with a MLP classifier (<code>classifier='mlp'</code>). You can also choose to use the default Random Forest classifier (<code>classifier='random_forest'</code>) or use your own custom <code>sklearn</code> classifier by specifying <code>clf_class</code> and <code>clf_kwargs</code> during the initialization of the <code>LC2ST</code> class. You can also use an ensemble classifier by setting <code>num_ensemble</code> &gt; 1 for more stable classifier predictions (see the <code>EnsembleClassifier</code> class in <code>sbi/diagnostics/lc2st.py</code>).</p> <pre><code>from sbi.diagnostics.lc2st import LC2ST\n\ntorch.manual_seed(42) # seed for reproducibility\n\n# sample calibration data\ntheta_cal = prior.sample((NUM_CAL,))\nx_cal = simulator(theta_cal)\npost_samples_cal = posterior.sample_batched((1,), x=x_cal)[0]\n</code></pre> <pre><code># set up the LC2ST: train the classifiers\nlc2st = LC2ST(\n    thetas=theta_cal,\n    xs=x_cal,\n    posterior_samples=post_samples_cal,\n    classifier=\"mlp\",\n    num_ensemble=1, # number of classifiers for the ensemble\n)\n_ = lc2st.train_under_null_hypothesis() # over 100 trials under (H0)\n_ = lc2st.train_on_observed_data() # on observed data\n</code></pre> <pre><code># Define significance level for diagnostics\nconf_alpha = 0.05\n</code></pre>"},{"location":"tutorials/13_diagnostics_lc2st/#quantitative-diagnostics","title":"Quantitative diagnostics","text":"<p>We here compute the test statistics and p-values for three different observations <code>x_o</code> (as mentioned above, this is done in an amortized way without having to retrain the classifiers). </p> <p>Note: The p-value associated to the test corresponds to the proportion of times the L-C2ST statistic under the null hypothesis \\(\\{T_h\\}_{h=1}^H\\) is greater than the L-C2ST statistic \\(T_\\mathrm{o}\\) at the observation <code>x_o</code>. It is computed by taking the empirical mean over statistics computed on several trials under the null hypothesis: \\(\\(\\text{p-value}(x_\\mathrm{o}) = \\frac{1}{H} \\sum_{h=1}^{H} I(T_h &lt; T_o)~.\\)\\)</p> <pre><code>fig, axes = plt.subplots(1,len(thetas_star), figsize=(12,3))\nfor i in range(len(thetas_star)):\n    probs, scores = lc2st.get_scores(\n        theta_o=post_samples_star[i],\n        x_o=xs_star[i],\n        return_probs=True,\n        trained_clfs=lc2st.trained_clfs\n    )\n    T_data = lc2st.get_statistic_on_observed_data(\n        theta_o=post_samples_star[i],\n        x_o=xs_star[i]\n    )\n    T_null = lc2st.get_statistics_under_null_hypothesis(\n        theta_o=post_samples_star[i],\n        x_o=xs_star[i]\n    )\n    p_value = lc2st.p_value(post_samples_star[i], xs_star[i])\n    reject = lc2st.reject_test(post_samples_star[i], xs_star[i], alpha=conf_alpha)\n\n    # plot 95% confidence interval\n    quantiles = np.quantile(T_null, [0, 1-conf_alpha])\n    axes[i].hist(T_null, bins=50, density=True, alpha=0.5, label=\"Null\")\n    axes[i].axvline(T_data, color=\"red\", label=\"Observed\")\n    axes[i].axvline(quantiles[0], color=\"black\", linestyle=\"--\", label=\"95% CI\")\n    axes[i].axvline(quantiles[1], color=\"black\", linestyle=\"--\")\n    axes[i].set_xlabel(\"Test statistic\")\n    axes[i].set_ylabel(\"Density\")\n    axes[i].set_xlim(-0.01,0.25)\n    axes[i].set_title(\n        f\"observation {i+1} \\n p-value = {p_value:.3f}, reject = {reject}\"\n    )\naxes[-1].legend(bbox_to_anchor=(1.1, .5), loc='center left')\nplt.show()\n</code></pre> <p></p> <p>Results: the plots show the test statistics under the null hypothesis <code>T_null</code> (in blue) defining the \\(95\\%\\) (<code>1 - conf_alpha</code>) confidence region (black dotted lines). The test statistic correponding to the observed data <code>T_data</code> (red) is outside of the confidence region, indicating the rejection of the null hypothesis and therefore a \u201cbad\u201d posterior estimator.</p>"},{"location":"tutorials/13_diagnostics_lc2st/#qualitative-diagnostics","title":"Qualitative diagnostics","text":""},{"location":"tutorials/13_diagnostics_lc2st/#p-p-plots","title":"P-P plots","text":"<p>P-P plots allow to evaluate a general trend of over- or under- confidence, by comparing the predicted probabilities of belonging to the estimated posterior (class 0). If the red curve is not fully contained in the gray confidence region, this means that the test rejects the null hypothesis and that a significant discrepancy from the true posterior is detected. Here two scenarios are possible: - over-confidence: the red curve is mostly on the right side of the gray CR (high probabilities are predominant) - under-confidence: the red curve is mostly on the left side of the gray CR (low probabilities are predominant)</p> <p>Note: The predominance of high (resp. low) probabilities indicates a classifier that is mostly confident about predicting the class corresponding to the estimated (resp. true) posterior. This in turn means that the estimator associates too much (resp. not enough) mass to the evaluation space, i.e. is overall over confident (resp. under confident).</p> <pre><code># P-P plots\nfrom sbi.analysis.plot import pp_plot_lc2st\n\nfig, axes = plt.subplots(1,len(thetas_star), figsize=(12,3))\nfor i in range(len(thetas_star)):\n    probs_data, _ = lc2st.get_scores(\n        theta_o=post_samples_star[i],\n        x_o=xs_star[i],\n        return_probs=True,\n        trained_clfs=lc2st.trained_clfs\n    )\n    probs_null, _ = lc2st.get_statistics_under_null_hypothesis(\n        theta_o=post_samples_star[i],\n        x_o=xs_star[i],\n        return_probs=True\n    )\n\n    pp_plot_lc2st(\n        probs=[probs_data],\n        probs_null=probs_null,\n        conf_alpha=conf_alpha,\n        labels=[\"Classifier probabilities \\n on observed data\"],\n        colors=[\"red\"],\n        ax=axes[i],\n    )\n    axes[i].set_title(f\"PP-plot for observation {i+1}\")\naxes[-1].legend(bbox_to_anchor=(1.1, .5), loc='center left')\nplt.show()\n</code></pre> <p></p> <p>Results: the plots below show a general trend of overconfident behavior (red curves on the right side of the black dots).</p>"},{"location":"tutorials/13_diagnostics_lc2st/#pairplot-with-heatmap-of-classifier-probabilities","title":"Pairplot with heatmap of classifier probabilities","text":"<p>We can go further and map these predicted probabilities to a pairplot of the samples they were evaluated on, which shows us the regions of over and underconfidence of the estimator. This allows us to investigate the nature of the inconsistencies, such as positive/negative bias or under/over dispersion.</p> <p>Note: High (resp. low) predicted probability indicates that the classifier is confident about the fact that the sample belongs to the estimated posterior (resp. to the true posterior). This means that the estimator associates too much (resp. not enough) mass to this sample. In other words it is \u201cover-confident\u201d (resp. \u201cunder-confident\u201d). </p> <pre><code>from sbi.analysis.plot import marginal_plot_with_probs_intensity\nfrom sbi.utils.analysis_utils import get_probs_per_marginal\n\nlabel = \"Probabilities (class 0)\"\n# label = r\"$\\hat{p}(\\Theta\\sim q_{\\phi}(\\theta \\mid x_0) \\mid x_0)$\"\n\nfig, axes = plt.subplots(len(thetas_star), 3, figsize=(9,6), constrained_layout=True)\nfor i in range(len(thetas_star)):\n    probs_data, _ = lc2st.get_scores(\n        theta_o=post_samples_star[i][:1000],\n        x_o=xs_star[i],\n        return_probs=True,\n        trained_clfs=lc2st.trained_clfs\n    )\n    dict_probs_marginals = get_probs_per_marginal(\n        probs_data[0],\n        post_samples_star[i][:1000].numpy()\n    )\n    # 2d histogram\n    marginal_plot_with_probs_intensity(\n        dict_probs_marginals['0_1'],\n        marginal_dim=2,\n        ax=axes[i][0],\n        n_bins=50,\n        label=label\n    )\n    axes[i][0].scatter(\n        ref_samples_star[i][:,0],\n        ref_samples_star[i][:,1],\n        alpha=0.2,\n        color=\"gray\",\n        label=\"True posterior\"\n    )\n\n    # marginal 1\n    marginal_plot_with_probs_intensity(\n        dict_probs_marginals['0'],\n        marginal_dim=1,\n        ax=axes[i][1],\n        n_bins=50,\n        label=label,\n    )\n    axes[i][1].hist(\n        ref_samples_star[i][:,0],\n        density=True,\n        bins=10,\n        alpha=0.5,\n        label=\"True Posterior\",\n        color=\"gray\"\n    )\n\n    # marginal 2\n    marginal_plot_with_probs_intensity(\n        dict_probs_marginals['1'],\n        marginal_dim=1,\n        ax=axes[i][2],\n        n_bins=50,\n        label=label,\n    )\n    axes[i][2].hist(\n        ref_samples_star[i][:,1],\n        density=True,\n        bins=10,\n        alpha=0.5,\n        label=\"True posterior\",\n        color=\"gray\"\n    )\n\naxes[0][1].set_title(\"marginal 1\")\naxes[0][2].set_title(\"marginal 2\")\n\nfor j in range(3):\n    axes[j][0].set_ylabel(f\"observation {j + 1}\")\naxes[0][2].legend()\nplt.show()\n</code></pre> <p></p> <p>Results: the plots below indicate over dispersion of our estimator at all three considered observations. Indeed, the 2D histograms display a small blue-green region at the center where the estimator is \u201cunderconfident\u201d, surrounded by a yellow region of \u201cequal probability\u201d, and the rest of the estimated posterior samlpes correspond to the red regions of \u201coverconfidence\u201d. </p> <p>Validation of the diagnostic tool: we verify the statement of over dispersion by plotting the true posterior samples (in grey) and are happy to see that they fall into the underconfident region of the estimator. </p>"},{"location":"tutorials/13_diagnostics_lc2st/#classifier-choice-and-calibration-data-size-how-to-ensure-meaningful-test-results","title":"Classifier choice and calibration data size: how to ensure meaningful test results","text":""},{"location":"tutorials/13_diagnostics_lc2st/#choice-of-the-classifier","title":"Choice of the classifier","text":"<p>If you are not sure about which classifier architecture is best for your data, you can do a quick check by looking at the variance of the results over different random state initializations of the classifier: For <code>i=1,2,...</code>  1. train the ith classifier: run <code>lc2st.train_on_observed_data(seed=i)</code>  2. compute the corresponding test statistic for a dataset <code>theta_o, x_o</code>: <code>T_i = lc2st.get_statistic_on_observed_data(theta_o, x_o)</code></p> <p>For different classifier architectures, you should choose the one with the smallest variance. </p>"},{"location":"tutorials/13_diagnostics_lc2st/#number-of-calibration-samples","title":"Number of calibration samples","text":"<p>A similar check can also be performed via cross-validation: set the <code>num_folds</code> parameter of your <code>LC2ST</code> object, train on observed data and call <code>lc2st.get_scores(theta_o, x_o, lc2st.trained_clfs)</code>. This outputs the test statistics obtained for each cv-fold. You should choose the smallest calibration set size that gives you a small enough variance over the test statistics. </p> <p>Note: Ideally, these checks should be performed in a separable data setting, i.e. for a dataset <code>theta_o, x_o</code> coming from a sub-optimal estimator: the classifier is supposed to be able to discriminate between the two classes; the test is supposed to be rejected; the variance is supposed to be small. In other words, we are ensuring a high statistical power (our true positive rate) of our test. If you want to be really rigurous, you should also check the type I error (or false positive rate), that should be controlled by the significance level of your test (cf. Figure 2 in [Linhart et al., 2023]).</p>"},{"location":"tutorials/13_diagnostics_lc2st/#reducing-the-variance-of-the-test-results","title":"Reducing the variance of the test results","text":"<p>To ensure more stable results, you can play with the following <code>LC2ST</code> parameters: - <code>num_ensemble</code>: number of classifiers used for ensembling. An ensemble classifier is a set of classifiers initialized with different <code>random_state</code>s and whose predicted class probalility is the mean probability over all classifiers. It reduces the variance coming from the classifier itself. - <code>num_folds</code>: number of folds used for cross-validation. It reduces the variance coming from the data.</p> <p>As these numbers increase the results become more stable (less variance) and the test becomes more disciminative (smaller confidence region). Both can be combined (i.e. you can perform cross-validation on an ensemble classifier). </p> <p>Note: Be careful, you don\u2019t want your test to be too discriminative!</p>"},{"location":"tutorials/13_diagnostics_lc2st/#the-case-of-normalizing-flows-ell-c2st-nf","title":"The case of Normalizing Flows (\\(\\ell\\)-C2ST-NF)","text":"<p>\\(\\ell\\)-C2ST can also be specialized for normalizing flows,leading to improved test performance. The idea is to train and evaluate the classifiers in the space of the base distribution of the normalizing flow, instead of the parameter space that can be highly structured.  Following Theorem 4 of [Linhart et al., 2023], the null hypothesis \\(\\mathcal{H}_0(x_\\mathrm{o}) := q_\\phi(\\theta\\mid x_\\mathrm{o}) = p(\\theta \\mid x_\\mathrm{o})\\) of local consistency holds if, and only if, the inverse flow transformation applied to the target distribution recovers the base distribution. This gives us the following new null hypothesis for posterior estimators based on normalizing flows (cf. Eq. 17 in [Linhart et al., 2023]):</p> \\[\\mathcal{H}_0(x_\\mathrm{o}) := p(T_\\phi^{-1}(\\theta ; x_\\mathrm{o}) \\mid x_\\mathrm{o}) = \\mathcal{N}(0, \\mathbf{I}_m), \\quad \\forall \\theta \\in \\mathbb{R}^m~,\\] <p>which leads to a new binary classification framework to discriminate between the joint distributions \\(\\mathcal{N}(0, \\mathbf{I}_m)p(x)\\) (class \\(C=0\\)) and \\(p(T_\\phi^{-1}(\\theta ; x_\\mathrm{o}), x_\\mathrm{o})\\) (class \\(C=1\\)).</p> <p>This results in two main advantages leading to a statistically more performant and flexible test:  - easier classification task: it is easier to discriminate samples w.r.t. a simple Gaussian than a complex (e.g. multimodal) posterior.  - an analytically known null distribution: it consists of the base distribution of the flow, which is independant of \\(x\\) and the posterior estimator. This also allows to pre-compute the null distribution and re-use it for any new posterior estimator you whish to evaluate. </p> <p>Remember that the original \\(\\ell\\)-C2ST relies on a permutation method to approximate the null distribution.</p> <p>The new method is implemented within the <code>LC2ST_NF</code> class, built on the <code>LC2ST</code> class with following major changes: - no evaluation samples <code>theta_o</code> have to be passed to the evaluation methods (e.g. <code>get_scores_on_observed_data</code>, <code>get_statistic_on_observed_data</code>, <code>p_value</code>, etc.) - the precomputed <code>trained_clfs_null</code> can be passed at initialization - no permutation method is used inside <code>train_under_null_hypothesis</code></p> <p>Note: Quick reminder on Normalizing Flows. We consider a conditional Normalizing Flow \\(q_{\\phi}(\\theta \\mid x)\\) with base distribution \\(p(z) = \\mathcal{N}(0,\\mathbf{1}_m)\\) and bijective transormation \\(T_{\\phi}(.; x)\\) defined on \\(\\mathbb{R}^2\\) and for all \\(x \\in \\mathbb{R}^2\\) for our example problem in 2D. Sampling from the normalizing flow consists of applying the forward transformation \\(T_\\phi\\): \\(\\(\\theta = T_{\\phi}(z; x) \\sim q_{\\phi}(\\theta \\mid x), \\quad z\\sim p(z)~.\\)\\) Characterization of the null hypothesis. Comparing the estimated and true posterior distributions is equivalent to comparing the base distribution to the inversely transformed prior samples:  $$ p(\\theta \\mid x) = q_{\\phi}(\\theta \\mid x) \\iff p(T_{\\phi}^{-1}(\\theta; x)\\mid x) = p(T_{\\phi}^{-1}(T_{\\phi}(z; x); x)) = p(z) = \\mathcal{N}(0,\\mathbf{1}_m)$$</p>"},{"location":"tutorials/13_diagnostics_lc2st/#set-up-ell-c2st-nf","title":"Set up \\(\\ell\\)-C2ST-NF","text":"<p>The setup of the NF version is the same as for the original \\(\\ell\\)-C2ST, but the trained classifiers can be used to compute test results and diagnostics for any new observation and new posterior estimator.</p> <pre><code>from sbi.diagnostics.lc2st import LC2ST_NF\n\nflow_inverse_transform = lambda theta, x: npe.net._transform(theta, context=x)[0]\nflow_base_dist = torch.distributions.MultivariateNormal(\n    torch.zeros(2), torch.eye(2)\n) # same as npe.net._distribution\n\nlc2st_nf = LC2ST_NF(\n    thetas=theta_cal,\n    xs=x_cal,\n    posterior_samples=post_samples_cal,\n    flow_inverse_transform=flow_inverse_transform,\n    flow_base_dist=flow_base_dist,\n    num_ensemble=1,\n)\n_ = lc2st_nf.train_under_null_hypothesis()\n_ = lc2st_nf.train_on_observed_data()\n</code></pre> <pre><code># Define significance level\nconf_alpha = 0.05\n</code></pre>"},{"location":"tutorials/13_diagnostics_lc2st/#quantitative-diagnostics_1","title":"Quantitative diagnostics","text":"<p>Same as before: we compute test statistics, confidence regions and p-values.</p> <pre><code>fig, axes = plt.subplots(1,len(thetas_star), figsize=(12,3))\nfor i in range(len(thetas_star)):\n    probs, scores = lc2st_nf.get_scores(\n        x_o=xs_star[i],\n        return_probs=True,\n        trained_clfs=lc2st_nf.trained_clfs\n    )\n    T_data = lc2st_nf.get_statistic_on_observed_data(x_o=xs_star[i])\n    T_null = lc2st_nf.get_statistics_under_null_hypothesis(x_o=xs_star[i])\n    p_value = lc2st_nf.p_value(xs_star[i])\n    reject = lc2st_nf.reject_test(xs_star[i], alpha=conf_alpha)\n\n    # plot 95% confidence interval\n    quantiles = np.quantile(T_null, [0, 1-conf_alpha])\n    axes[i].hist(T_null, bins=50, density=True, alpha=0.5, label=\"Null\")\n    axes[i].axvline(T_data, color=\"red\", label=\"Observed\")\n    axes[i].axvline(quantiles[0], color=\"black\", linestyle=\"--\", label=\"95% CI\")\n    axes[i].axvline(quantiles[1], color=\"black\", linestyle=\"--\")\n    axes[i].set_xlabel(\"Test statistic\")\n    axes[i].set_ylabel(\"Density\")\n    axes[i].set_xlim(-0.01,0.25)\n    axes[i].set_title(\n        f\"observation {i+1} \\n p-value = {p_value:.3f}, reject = {reject}\"\n    )\naxes[-1].legend(bbox_to_anchor=(1.1, .5), loc='center left')\nplt.show()\n</code></pre> <p></p> <p>Results: Again the test hypothesis is rejected for all three observations.</p>"},{"location":"tutorials/13_diagnostics_lc2st/#qualitative-diagnostics_1","title":"Qualitative diagnostics","text":""},{"location":"tutorials/13_diagnostics_lc2st/#p-p-plots_1","title":"P-P plots","text":"<p>Results: As before, the plots below show a general trend of overconfident behavior (red curves on the right side of the black dots).</p> <pre><code># P-P plots\nfrom sbi.analysis.plot import pp_plot_lc2st\n\nfig, axes = plt.subplots(1,len(thetas_star), figsize=(12,3))\nfor i in range(len(thetas_star)):\n    probs_data, _ = lc2st_nf.get_scores(\n        x_o=xs_star[i],\n        return_probs=True,\n        trained_clfs=lc2st_nf.trained_clfs\n    )\n    probs_null, _ = lc2st_nf.get_statistics_under_null_hypothesis(\n        x_o=xs_star[i],\n        return_probs=True\n    )\n\n    pp_plot_lc2st(\n        probs=[probs_data],\n        probs_null=probs_null,\n        conf_alpha=conf_alpha,\n        labels=[\"Classifier probabilities \\n on observed data\"],\n        colors=[\"red\"],\n        ax=axes[i],\n    )\n    axes[i].set_title(f\"PP-plot for observation {i+1}\")\naxes[-1].legend(bbox_to_anchor=(1.1, .5), loc='center left')\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/13_diagnostics_lc2st/#heatmap-of-classifier-probabilities","title":"Heatmap of classifier probabilities","text":"<p>For the NF case and as displayed in the plots below, we can choose to plot the heatmap of predicted classifier probabilities in the base distribution space, instead of the parameter space, which can be easier to interpret if the posterior space is highly structured.</p> <pre><code>from sbi.analysis.plot import marginal_plot_with_probs_intensity\nfrom sbi.utils.analysis_utils import get_probs_per_marginal\n\nlabel = \"Probabilities (class 0)\"\n# label = r\"$\\hat{p}(Z\\sim\\mathcal{N}(0,1)\\mid x_0)$\"\n\nfig, axes = plt.subplots(len(thetas_star), 3, figsize=(9,6), constrained_layout=True)\nfor i in range(len(thetas_star)):\n    inv_ref_samples = lc2st_nf.flow_inverse_transform(\n        ref_samples_star[i], xs_star[i]\n    ).detach()\n    probs_data, _ = lc2st_nf.get_scores(\n        x_o=xs_star[i],\n        return_probs=True,\n        trained_clfs=lc2st_nf.trained_clfs\n    )\n    marginal_probs = get_probs_per_marginal(\n        probs_data[0],\n        lc2st_nf.theta_o.numpy()\n    )\n    # 2d histogram\n    marginal_plot_with_probs_intensity(\n        marginal_probs['0_1'],\n        marginal_dim=2,\n        ax=axes[i][0],\n        n_bins=50,\n        label=label\n    )\n    axes[i][0].scatter(\n        inv_ref_samples[:,0],\n        inv_ref_samples[:,1],\n        alpha=0.2, color=\"gray\",\n        label=\"True posterior\"\n    )\n\n    # marginal 1\n    marginal_plot_with_probs_intensity(\n        marginal_probs['0'],\n        marginal_dim=1,\n        ax=axes[i][1],\n        n_bins=50,\n        label=label\n    )\n    axes[i][1].hist(\n        inv_ref_samples[:,0],\n        density=True,\n        bins=10,\n        alpha=0.5,\n        label=\"True Posterior\",\n        color=\"gray\"\n    )\n\n    # marginal 2\n    marginal_plot_with_probs_intensity(\n        marginal_probs['1'],\n        marginal_dim=1,\n        ax=axes[i][2],\n        n_bins=50,\n        label=label\n    )\n    axes[i][2].hist(\n        inv_ref_samples[:,1],\n        density=True,\n        bins=10,\n        alpha=0.5,\n        label=\"True posterior\",\n        color=\"gray\"\n    )\n\naxes[0][1].set_title(\"marginal 1\")\naxes[0][2].set_title(\"marginal 2\")\n\nfor j in range(3):\n    axes[j][0].set_ylabel(f\"observation {j + 1}\")\naxes[0][2].legend()\nplt.show()\n</code></pre> <p></p> <p>Results: Again, the plots below confirm that the true posterior samples (in grey) correspond to regions of \u201cunderconfidence\u201d (blue-green) or \u201cequal probability\u201d (yellow), indicating over dispersion of our posterior esimator.</p>"},{"location":"tutorials/14_mcmc_diagnostics_with_arviz/","title":"MCMC diagnostics with Arviz","text":"<p>This tutorial shows how to evaluate the quality of MCMC samples generated via <code>sbi</code> using the <code>arviz</code> package.</p> <p>Outline:</p> <ol> <li>Train MNLE to approximate the likelihood underlying the simulator</li> <li>Run MCMC using <code>pyro</code> MCMC samplers via <code>sbi</code> interface</li> <li>Use <code>arviz</code> to visualize the posterior, predictive distributions and MCMC diagnostics.</li> </ol> <pre><code>import arviz as az\nimport torch\nfrom pyro.distributions import InverseGamma\nfrom torch.distributions import Beta, Binomial, Gamma\n\nfrom sbi.inference import MNLE, MCMCPosterior, likelihood_estimator_based_potential\nfrom sbi.utils import MultipleIndependent\n\n# Seeding\ntorch.manual_seed(1);\n</code></pre> <pre><code># Toy simulator for mixed data\ndef mixed_simulator(theta):\n    beta, ps = theta[:, :1], theta[:, 1:]\n\n    choices = Binomial(probs=ps).sample()\n    rts = InverseGamma(concentration=2 * torch.ones_like(beta), rate=beta).sample()\n\n    return torch.cat((rts, choices), dim=1)\n\n\n# Define independent priors for each dimension.\nprior = MultipleIndependent(\n    [\n        Gamma(torch.tensor([1.0]), torch.tensor([0.5])),\n        Beta(torch.tensor([2.0]), torch.tensor([2.0])),\n    ],\n    validate_args=False,\n)\n</code></pre>"},{"location":"tutorials/14_mcmc_diagnostics_with_arviz/#train-mnle-to-approximate-the-likelihood","title":"Train MNLE to approximate the likelihood","text":"<p>For this tutorial, we will use a simple simulator with two parameters. For details see the example on the decision making model.</p> <p>Here, we pass <code>mcmc_method=\"nuts\"</code> in order to use the underlying <code>pyro</code> No-U-turn sampler, but it would work as well with other samplers (e.g. \u201cslice_np_vectorized\u201d, \u201chmc\u201d).</p> <p>Additionally, when calling <code>posterior.sample(...)</code> we pass <code>return_arviz=True</code> so that the <code>Arviz InferenceData</code> object is returned. This object gives us access to the wealth of MCMC diagnostics tool provided by <code>arviz</code>.</p> <pre><code># Generate training data and train MNLE.\nnum_simulations = 10000\ntheta = prior.sample((num_simulations,))\nx = mixed_simulator(theta)\n\ntrainer = MNLE(prior)\nlikelihood_estimator = trainer.append_simulations(theta, x).train()\n</code></pre>"},{"location":"tutorials/14_mcmc_diagnostics_with_arviz/#run-pyro-nuts-mcmc-and-obtain-arviz-inferencedata-object","title":"Run Pyro NUTS MCMC and obtain <code>arviz InferenceData</code> object","text":"<pre><code># Simulate \"observed\" data x_o\ntorch.manual_seed(42)\nnum_trials = 100\ntheta_o = prior.sample((1,))\nx_o = mixed_simulator(theta_o.repeat(num_trials, 1))\n\n# Set MCMC parameters and run Pyro NUTS.\nmcmc_parameters = dict(\n    num_chains=4,\n    thin=5,\n    warmup_steps=50,\n    init_strategy=\"proposal\",\n    method=\"nuts_pyro\",\n)\nnum_samples = 1000\n\n# get the potential function and parameter transform for constructing the posterior\npotential_fn, parameter_transform = likelihood_estimator_based_potential(\n    likelihood_estimator, prior, x_o\n)\nmnle_posterior = MCMCPosterior(\n    potential_fn, proposal=prior, theta_transform=parameter_transform, **mcmc_parameters\n)\n\nmnle_samples = mnle_posterior.sample(\n    (num_samples,), x=x_o, show_progress_bars=False\n)\n# get arviz InferenceData object from posterior\ninference_data = mnle_posterior.get_arviz_inference_data()\n</code></pre>"},{"location":"tutorials/14_mcmc_diagnostics_with_arviz/#generate-arviz-plots","title":"Generate <code>arviz</code> plots","text":"<p>The resulting <code>InferenceData</code> object can be passed to most <code>arviz</code> plotting functions, and there are plenty see here for an overview.</p> <p>To get a better understanding of the <code>InferenceData</code> object see here.</p> <p>Below and overview of common MCMC diagnostics plot, see the corresponding <code>arviz</code> documentation for interpretation of the plots.</p> <p>We will a full use-case using the SBI-MCMC-arviz workflow soon.</p> <pre><code>print(inference_data.posterior)\n</code></pre> <pre><code>&lt;xarray.Dataset&gt; Size: 50kB\nDimensions:      (chain: 4, draw: 1250, theta_dim_0: 2)\nCoordinates:\n  * chain        (chain) int64 32B 0 1 2 3\n  * draw         (draw) int64 10kB 0 1 2 3 4 5 ... 1244 1245 1246 1247 1248 1249\n  * theta_dim_0  (theta_dim_0) int64 16B 0 1\nData variables:\n    theta        (chain, draw, theta_dim_0) float32 40kB 1.908 0.7609 ... 0.9063\nAttributes:\n    created_at:     2024-08-23T15:56:16.510051+00:00\n    arviz_version:  0.19.0\n</code></pre>"},{"location":"tutorials/14_mcmc_diagnostics_with_arviz/#diagnostic-plots","title":"Diagnostic plots","text":"<pre><code>az.style.use(\"arviz-darkgrid\")\naz.plot_rank(inference_data)\n</code></pre> <pre><code>az.plot_autocorr(inference_data);\n</code></pre> <pre><code>az.plot_trace(inference_data, compact=False);\n</code></pre> <pre><code>az.plot_ess(inference_data, kind=\"evolution\");\n</code></pre>"},{"location":"tutorials/14_mcmc_diagnostics_with_arviz/#posterior-density-plots","title":"Posterior density plots","text":"<pre><code>az.plot_posterior(inference_data)\n</code></pre> <pre><code>print(\n    f\"\"\"Given the {num_trials} we observed, the posterior is centered around\n    true underlying parameters theta_o: {theta_o}\"\"\"\n)\n</code></pre> <pre><code>Given the 100 we observed, the posterior is centered around\n    true underlying parameters theta_o: tensor([[1.9622, 0.7550]])\n</code></pre> <pre><code>az.plot_pair(inference_data)\n</code></pre> <pre><code>az.plot_pair(\n    inference_data,\n    var_names=[\"theta\"],\n    kind=\"hexbin\",\n    marginals=True,\n    figsize=(10, 10),\n)\n</code></pre>"},{"location":"tutorials/15_importance_sampled_posteriors/","title":"Refining posterior estimates with importance sampling","text":""},{"location":"tutorials/15_importance_sampled_posteriors/#theory","title":"Theory","text":"<p>SBI estimates the posterior \\(p(\\theta|x) = {p(\\theta)p(x|\\theta)}/{p(x)}\\) based on samples from the prior \\(\\theta\\sim p(\\theta)\\) and the likelihood \\(x\\sim p(x|\\theta)\\). Sometimes, we can do both, sample and evaluate the prior and likelihood. In this case, we can combine the simulation-based estimate \\(q(\\theta|x)\\) with likelihood-based importance sampling, and thereby generate an asymptotically exact estimate for \\(p(\\theta|x)\\).</p>"},{"location":"tutorials/15_importance_sampled_posteriors/#importance-weights","title":"Importance weights","text":"<p>The main idea is to interpret \\(q(\\theta|x)\\) as a proposal distribution and generate proposal samples \\(\\theta_i\\sim q(\\theta|x)\\), and then augment each sample with an importance weight \\(w_i = p(\\theta_i|x) / q(\\theta_i|x)\\). The definition of the importance weights is motivated from Monte Carlo estimates for the random variable \\(f(\\theta)\\), </p> \\[  \\mathbb{E}_{\\theta\\sim p(\\theta|x)}\\left[f(\\theta)\\right]  =\\int p(\\theta|x) f(\\theta)\\,\\text{d}\\theta \\approx \\sum_{\\theta_i\\sim p(\\theta_i|x)} f(\\theta_i). \\] <p>We can rewrite this expression as </p> \\[  \\mathbb{E}_{\\theta\\sim p(\\theta|x)}\\left[f(\\theta)\\right]  =\\int p(\\theta|x) f(\\theta)\\,\\text{d}\\theta =\\int q(\\theta|x) \\frac{p(\\theta|x)}{q(\\theta|x)}f(\\theta)\\,\\text{d}\\theta \\approx \\sum_{\\theta_i\\sim q(\\theta_i|x)} \\frac{p(\\theta_i|x)}{q(\\theta_i|x)}f(\\theta_i) \\approx \\sum_{\\theta_i\\sim q(\\theta_i|x)} w_i\\cdot f(\\theta_i). \\] <p>Instead of sampling \\(\\theta_i\\sim p(\\theta_i|x)\\), we can thus sample \\(\\theta_i\\sim q(\\theta_i|x)\\) and attach a corresponding importance weight \\(w_i\\) to each sample. Intuitively, the importance weights downweight samples where \\(q(\\theta|x)\\) overestimates \\(p(\\theta|x)\\) and upweight samples where \\(p(\\theta|x)\\) underestimates \\(q(\\theta|x)\\).</p>"},{"location":"tutorials/15_importance_sampled_posteriors/#implementation","title":"Implementation","text":"<pre><code>from torch import ones, eye\nimport torch\nfrom torch.distributions import MultivariateNormal\nimport matplotlib.pyplot as plt\n\nfrom sbi.inference import NPE, ImportanceSamplingPosterior\nfrom sbi.utils import BoxUniform\nfrom sbi.inference.potentials.base_potential import BasePotential\nfrom sbi.analysis import marginal_plot\n</code></pre> <p>We first define a simulator and a prior which both have functions for sampling (as required for SBI) and log_prob evaluations (as required for importance sampling).</p> <p>Next we train an NPE model for inference.</p> <p>Now we perfrom inference with the model.</p> <pre><code># define prior and simulator\nclass Simulator:\n    def __init__(self):\n        pass\n\n    def log_likelihood(self, theta, x):\n        return MultivariateNormal(theta, eye(2)).log_prob(x)\n\n    def sample(self, theta):\n        return theta + torch.randn((theta.shape))\n\nprior = BoxUniform(-5 * ones((2,)), 5 * ones((2,)))\nsim = Simulator()\nlog_prob_fn = lambda theta, x_o: sim.log_likelihood(theta, x_o) + prior.log_prob(theta)\n\n# generate train data\n_ = torch.manual_seed(3)\ntheta = prior.sample((10,))\nx = sim.sample(theta)\n\n# train NPE model\n_ = torch.manual_seed(4)\ninference = NPE(prior=prior)\n_ = inference.append_simulations(theta, x).train()\nposterior = inference.build_posterior()\n\n# generate a synthetic observation\n_ = torch.manual_seed(2)\ntheta_gt = prior.sample((1,))\nobservation = sim.sample(theta_gt)[0]\nposterior = posterior.set_default_x(observation)\nprint(\"observations.shape\", observation.shape)\n\n# sample from posterior\ntheta_inferred = posterior.sample((10_000,))\n\n# get samples from ground-truth posterior\ngt_samples = MultivariateNormal(observation, eye(2)).sample((len(theta_inferred) * 5,))\ngt_samples = gt_samples[prior.support.check(gt_samples)][:len(theta_inferred)]\n</code></pre> <pre><code> Neural network successfully converged after 70 epochs.observations.shape torch.Size([2])\n</code></pre> <p>In this case, we know the ground truth posterior, so we can compare NPE to it:</p> <pre><code>fig, ax = marginal_plot(\n    [theta_inferred, gt_samples],\n    limits=[[-5, 5], [-5, 5]],\n    figsize=(5, 1.5),\n    diag=\"kde\",  # smooth histogram\n)\nax[1].legend([\"NPE\", \"Groud Truth\"], loc=\"upper right\", bbox_to_anchor=[2.0, 1.0, 0.0, 0.0]);\n</code></pre> <p></p> <p>While NPE is not completely off, it does not provide a perfect fit to the posterior. In cases where the likelihood is tractable, we can fix this with importance sampling.</p>"},{"location":"tutorials/15_importance_sampled_posteriors/#importance-sampling-with-the-sbi-toolbox","title":"Importance sampling with the SBI toolbox","text":"<p>With the SBI toolbox, importance sampling is a one-liner. SBI supports two methods for importance sampling: - <code>\"importance\"</code>: returns <code>n_samples</code> weighted samples (as above) corresponding to <code>n_samples * sample_efficiency</code> samples from the posterior. This results in unbiased samples, but the number of effective samples may be small when the SBI estimate is inaccurate. - <code>\"sir\"</code> (sampling-importance-resampling): performs rejection sampling on a batched basis with batch size <code>oversampling_factor</code>.  This is a guaranteed way to obtain <code>N / oversampling_factor</code> samples, but these may be biased as the weight normalization is not performed across the entire set of samples.</p> <pre><code>posterior_sir = ImportanceSamplingPosterior(\n    potential_fn=log_prob_fn,\n    proposal=posterior,\n    method=\"sir\",\n).set_default_x(observation)\n\ntheta_inferred_sir = posterior_sir.sample(\n    (1000,),\n    oversampling_factor=32,\n)\n</code></pre> <pre><code>fig, ax = marginal_plot(\n    [theta_inferred, theta_inferred_sir, gt_samples],\n    limits=[[-5, 5], [-5, 5]],\n    figsize=(5, 1.5),\n    diag=\"kde\",  # smooth histogram\n)\nax[1].legend([\"NPE\", \"NPE-IS\", \"Groud Truth\"], loc=\"upper right\", bbox_to_anchor=[2.0, 1.0, 0.0, 0.0]);\n</code></pre> <p></p> <p>Indeed, the importance-sampled posterior matches the ground truth well, despite significant deviations of the initial NPE estimate.</p> <pre><code>\n</code></pre>"},{"location":"tutorials/16_implemented_methods/","title":"API of implemented methods","text":"<p>This notebook spells out the API for all algorithms implemented in the <code>sbi</code> toolbox:</p> <ul> <li> <p>Posterior estimation (NPE)</p> </li> <li> <p>Likelihood estimation (NLE)</p> </li> <li> <p>Likelihood-ratio estimation (NRE)</p> </li> <li> <p>Utilities</p> </li> </ul>"},{"location":"tutorials/16_implemented_methods/#posterior-estimation-npe","title":"Posterior estimation (NPE)","text":"<p>Fast \u03b5-free Inference of Simulation Models with Bayesian Conditional Density Estimation by Papamakarios &amp; Murray (NeurIPS 2016) [PDF] [BibTeX]</p> <pre><code># Example setup\nimport torch\n\nfrom sbi.utils import BoxUniform\n\n# Define the prior\nnum_dims = 2\nnum_sims = 1000\nnum_rounds = 2\nprior = BoxUniform(low=torch.zeros(num_dims), high=torch.ones(num_dims))\nsimulator = lambda theta: theta + torch.randn_like(theta) * 0.1\nx_o = torch.tensor([0.5, 0.5])\n</code></pre> <pre><code>from sbi.inference import NPE_A\n\ninference = NPE_A(prior)\nproposal = prior\nfor _ in range(num_rounds):\n    theta = proposal.sample((num_sims,))\n    x = simulator(theta)\n    _ = inference.append_simulations(theta, x, proposal=proposal).train()\n    posterior = inference.build_posterior().set_default_x(x_o)\n    proposal = posterior\n</code></pre> <p>Automatic posterior transformation for likelihood-free inferenceby Greenberg, Nonnenmacher &amp; Macke (ICML 2019) [PDF]</p> <pre><code>from sbi.inference import NPE\n\ninference = NPE(prior)\nproposal = prior\nfor _ in range(num_rounds):\n    theta = proposal.sample((num_sims,))\n    x = simulator(theta)\n    _ = inference.append_simulations(theta, x, proposal=proposal).train()\n    posterior = inference.build_posterior().set_default_x(x_o)\n    proposal = posterior\n</code></pre> <p>BayesFlow: Learning complex stochastic models with invertible neural networks by Radev, S. T., Mertens, U. K., Voss, A., Ardizzone, L., &amp; K\u00f6the, U. (2020) (IEEE transactions on neural networks and learning systems 2020) Paper</p> <p>The density estimation part of BayesFlow is equivalent to single-round NPE. The additional contribution of the paper are several embedding networks for high-dimensional data including permutation invariant embeddings. Similar embeddings networks are implemented in <code>sbi</code> as well, under <code>sbi.neural_nets.embedding_nets</code>.</p> <pre><code># Posterior estimation with BayesFlow is equivalent to single-round NPE.\nfrom sbi.inference import NPE\n\ninference = NPE(prior)\ntheta = prior.sample((num_sims,))\nx = simulator(theta)\ninference.append_simulations(theta, x).train()\nposterior = inference.build_posterior()\nsamples = posterior.sample((1000,), x=x_o)\n</code></pre> <p>Truncated proposals for scalable and hassle-free simulation-based inference  by Deistler, Goncalves &amp; Macke (NeurIPS 2022) [Paper]</p> <pre><code>from sbi.inference import NPE\nfrom sbi.utils import RestrictedPrior, get_density_thresholder\n\ninference = NPE(prior)\nproposal = prior\nfor _ in range(num_rounds):\n    theta = proposal.sample((num_sims,))\n    x = simulator(theta)\n    _ = inference.append_simulations(theta, x).train(force_first_round_loss=True)\n    posterior = inference.build_posterior().set_default_x(x_o)\n\n    accept_reject_fn = get_density_thresholder(posterior, quantile=1e-4)\n    proposal = RestrictedPrior(prior, accept_reject_fn, sample_with=\"rejection\")\n</code></pre> <p>Flow Matching for Scalable Simulation-Based Inference  by Dax, Wildberger, Buchholz, Green, Macke, Sch\u00f6lkopf (NeurIPS 2023)  [Paper]</p> <pre><code>from sbi.inference import FMPE\n\ninference = FMPE(prior)\n# FMPE does support multiple rounds of inference\ntheta = prior.sample((num_sims,))\nx = simulator(theta)\ninference.append_simulations(theta, x).train()\nposterior = inference.build_posterior().set_default_x(x_o)\n</code></pre> <p>Neural posterior score estimation</p> <p>based on:  </p> <ul> <li>Compositional Score Modeling for Simulation-based Inference by Geffner, T., Papamakarios, G., &amp; Mnih, A. (ICML 2023) [Paper] </li> <li>Sequential Neural Score Estimation: Likelihood-Free Inference with Conditional Score Based Diffusion Models by Sharrock, L., Simons, J., Liu, S., &amp; Beaumont, M. (ICML 2024) [Paper] </li> </ul> <p>Note that currently only the single-round variant is implemented.</p> <pre><code>from sbi.inference import NPSE\n\ntheta = prior.sample((num_sims,))\nx = simulator(theta)\n\ninference = NPSE(prior, sde_type=\"ve\")\n_ = inference.append_simulations(theta, x).train()\nposterior = inference.build_posterior().set_default_x(x_o)\n</code></pre>"},{"location":"tutorials/16_implemented_methods/#likelihood-estimation-nle","title":"Likelihood estimation (NLE)","text":"<p>Sequential neural likelihood: Fast likelihood-free inference with autoregressive flowsby Papamakarios, Sterratt &amp; Murray (AISTATS 2019) [PDF] [BibTeX]</p> <pre><code>from sbi.inference import NLE\n\ninference = NLE(prior)\nproposal = prior\nfor _ in range(num_rounds):\n    theta = proposal.sample((num_sims,))\n    x = simulator(theta)\n    _ = inference.append_simulations(theta, x).train()\n    posterior = inference.build_posterior(mcmc_method=\"slice_np_vectorized\",\n                                          mcmc_parameters={\"num_chains\": 20,\n                                                           \"thin\": 5})\n    proposal = posterior.set_default_x(x_o)\n</code></pre> <p>Variational methods for simulation-based inference  by Gl\u00f6ckler, Deistler, Macke (ICLR 2022) [Paper]</p> <pre><code>from sbi.inference import NLE\n\ninference = NLE(prior)\nproposal = prior\nfor _ in range(num_rounds):\n    theta = proposal.sample((num_sims,))\n    x = simulator(theta)\n    _ = inference.append_simulations(theta, x).train()\n    posterior = inference.build_posterior(sample_with=\"vi\",\n                                          vi_method=\"fKL\").set_default_x(x_o)\n    proposal = posterior.train()  # Train VI posterior on given x_o.\n</code></pre> <p>Flexible and efficient simulation-based inference for models of decision-making  by Boelts, Lueckmann, Gao, Macke (Elife 2022) [Paper]</p> <pre><code>from sbi.inference import MNLE\n\ninference = MNLE(prior)\ntheta = prior.sample((num_sims,))\nx = simulator(theta)\n_ = inference.append_simulations(theta, x).train()\nposterior = inference.build_posterior().set_default_x(x_o)\n</code></pre>"},{"location":"tutorials/16_implemented_methods/#likelihood-ratio-estimation-nre","title":"Likelihood-ratio estimation (NRE)","text":"<p>Likelihood-free MCMC with Amortized Approximate Likelihood Ratiosby Hermans, Begy &amp; Louppe (ICML 2020) [PDF]</p> <pre><code>from sbi.inference import NRE_A\n\ninference = NRE_A(prior)\ntheta = prior.sample((num_sims,))\nx = simulator(theta)\n_ = inference.append_simulations(theta, x).train()\nposterior = inference.build_posterior().set_default_x(x_o)\n</code></pre> <p>On Contrastive Learning for Likelihood-free InferenceDurkan, Murray &amp; Papamakarios (ICML 2020) [PDF].</p> <pre><code>from sbi.inference import NRE\n\ninference = NRE(prior)\nproposal = prior\nfor _ in range(num_rounds):\n    theta = proposal.sample((num_sims,))\n    x = simulator(theta)\n    _ = inference.append_simulations(theta, x).train()\n    posterior = inference.build_posterior(mcmc_method=\"slice_np_vectorized\",\n                                          mcmc_parameters={\"num_chains\": 20,\n                                                           \"thin\": 5})\n    proposal = posterior.set_default_x(x_o)\n</code></pre> <p>Towards Reliable Simulation-Based Inference with Balanced Neural Ratio Estimationby Delaunoy, Hermans, Rozet, Wehenkel &amp; Louppe (NeurIPS 2022) [PDF]</p> <pre><code>from sbi.inference import BNRE\n\ninference = BNRE(prior)\ntheta = prior.sample((num_sims,))\nx = simulator(theta)\n_ = inference.append_simulations(theta, x).train(regularization_strength=100.)\nposterior = inference.build_posterior().set_default_x(x_o)\n</code></pre> <p>Contrastive Neural Ratio EstimationBenjamin Kurt Miller, Christoph Weniger, Patrick Forr\u00e9 (NeurIPS 2022) [PDF]</p> <pre><code># The main feature of NRE-C is producing an exact ratio of densities at optimum,\n# even when using multiple contrastive pairs (classes).\n\nfrom sbi.inference import NRE_C\n\ninference = NRE_C(prior)\nproposal = prior\ntheta = proposal.sample((num_sims,))\nx = simulator(theta)\n_ = inference.append_simulations(theta, x).train(\n    num_classes=5,  # sees `2 * num_classes - 1` marginally drawn contrastive pairs.\n    gamma=1.0,  # controls the weight between terms in its loss function.\n)\nposterior = inference.build_posterior().set_default_x(x_o)\n</code></pre>"},{"location":"tutorials/16_implemented_methods/#diagnostics-and-utilities","title":"Diagnostics and utilities","text":"<p>Simulation-based calibrationby Talts, Betancourt, Simpson, Vehtari, Gelman (arxiv 2018) [Paper])</p> <pre><code>from sbi.diagnostics import run_sbc\nfrom sbi.analysis import sbc_rank_plot\n\nthetas = prior.sample((1000,))\nxs = simulator(thetas)\n\n# SBC is fast for fully amortized NPE.\ninference = NPE(prior)\ntheta = prior.sample((num_sims,))\nx = simulator(theta)\ninference.append_simulations(theta, x).train()\nposterior = inference.build_posterior()\n\nranks, dap_samples = run_sbc(\n    thetas, xs, posterior, num_posterior_samples=1_000\n)\n\nfig, axes = sbc_rank_plot(\n    ranks=ranks,\n    num_posterior_samples=1000,\n    plot_type=\"hist\",\n    num_bins=20,\n)\n</code></pre> <p>Expected coverage (sample-based)as computed in Deistler, Goncalves, Macke (Neurips 2022) [Paper] and in Rozet, Louppe (2021) [Paper]</p> <pre><code>thetas = prior.sample((100,))\nxs = simulator(thetas)\n\nranks, dap_samples = run_sbc(\n    thetas,\n    xs,\n    posterior,\n    num_posterior_samples=1_000,\n    reduce_fns=posterior.log_prob  # Difference to SBC.\n)\n\n# NOTE: Here we obtain a single rank plot because ranks are calculated\n# for the entire posterior and not for each marginal like in SBC.\nfig, axes = sbc_rank_plot(\n    ranks=ranks,\n    num_posterior_samples=1000,\n    plot_type=\"hist\",\n    num_bins=20,\n)\n</code></pre> <p>TARP: Sampling-Based Accuracy Testing of Posterior Estimators for General Inference</p> <p>Lemos, Coogan, Hezaveh &amp; Perreault-Levasseur (ICML 2023)[Paper]</p> <pre><code>from sbi.diagnostics.tarp import run_tarp\nfrom sbi.analysis import plot_tarp\n\nthetas = prior.sample((1000,))\nxs = simulator(thetas)\n\nexpected_coverage, ideal_coverage = run_tarp(\n    thetas,\n    xs,\n    posterior,\n    references=None,  # optional, defaults to uniform samples across parameter space.\n    num_posterior_samples=1_000,\n)\n\nfix, axes = plot_tarp(expected_coverage, ideal_coverage)\n</code></pre> <p>Restriction estimatorby Deistler, Macke &amp; Goncalves (PNAS 2022) [Paper]</p> <pre><code>from sbi.inference import NPE\nfrom sbi.utils import RestrictionEstimator\n\nrestriction_estimator = RestrictionEstimator(prior=prior)\nproposal = prior\n\nfor _ in range(num_rounds):\n    theta = proposal.sample((num_sims,))\n    x = simulator(theta)\n    restriction_estimator.append_simulations(theta, x)\n    classifier = restriction_estimator.train()\n    proposal = restriction_estimator.restrict_prior()\n\nall_theta, all_x, _ = restriction_estimator.get_simulations()\n\ninference = NPE(prior)\ndensity_estimator = inference.append_simulations(all_theta, all_x).train()\nposterior = inference.build_posterior()\n</code></pre>"},{"location":"tutorials/17_plotting_functionality/","title":"17 plotting functionality","text":""},{"location":"tutorials/17_plotting_functionality/#plotting-functionality","title":"Plotting functionality","text":"<p>Here we will have a look at the different options for finetuning <code>pairplots</code> and <code>marginal_plots</code>.</p> <p>Lets first draw some samples from the posterior used in a previous tutorial.</p> <pre><code>import torch \nfrom sbi.analysis import pairplot\nfrom toy_posterior_for_07_cc import ExamplePosterior\n\nposterior = ExamplePosterior()\nposterior_samples = posterior.sample((100,))\n</code></pre> <p>We will start with the default plot and gradually make it prettier</p> <pre><code>_ = pairplot(\n    posterior_samples,\n)\n</code></pre> <p></p>"},{"location":"tutorials/17_plotting_functionality/#customisation","title":"Customisation","text":"<p>The pairplots are split into three regions, the diagonal (<code>diag</code>) and the upper and lower off-diagonal regions(<code>upper</code> and <code>lower</code>). We can pass separate arguments (e.g. <code>hist</code>, <code>kde</code>, <code>scatter</code>) for each region, as well as corresponding style keywords in a dictionary (by using e.g. <code>upper_kwargs</code>). For overall figure stylisation one can use <code>fig_kwargs</code>.</p> <p>To get a closer look at the potential options, have a look at the <code>_get_default_fig_kwargs</code>, <code>_get_default_diag_kwargs</code> and <code>_get_default_offdiag_kwargs</code> functions in analysis/plot.py.</p> <p>As illustrated below, we can directly use any <code>matplotlib</code> keywords (such as <code>cmap</code> for images) by passing them in the <code>mpl_kwargs</code> entry of <code>upper_kwargs</code> or <code>diag_kwargs</code>.</p> <p>Let\u2019s now make a scatter plot for the upper diagonal, a histogram for the diagonal, and pass keyword dictionaries for both.</p> <pre><code>_ = pairplot(\n    posterior_samples,\n    limits=[[-3, 3] * 3],\n    figsize=(5, 5),\n    diag=\"hist\",\n    upper=\"scatter\",\n    diag_kwargs={\n        \"mpl_kwargs\": {\n            \"bins\": 10,\n            \"color\": 'tab:blue',\n            \"edgecolor\": 'white',\n            \"linewidth\": 1,\n            \"alpha\": 0.6,\n            \"histtype\": \"bar\",\n            \"fill\": True,\n        }\n    },\n    upper_kwargs={\"mpl_kwargs\": {\"color\": 'tab:blue', \"s\": 20, \"alpha\": 0.8}},\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n)\n</code></pre> <p></p>"},{"location":"tutorials/17_plotting_functionality/#compare-two-sets-of-samples","title":"Compare two sets of samples","text":"<p>By passing a list of samples, we can plot two sets of samples on top of each other.</p> <pre><code># draw two different subsets of samples to plot\nposterior_samples1 = posterior.sample((20,))\nposterior_samples2 = posterior.sample((20,))\n\n_ = pairplot(\n    [posterior_samples1, posterior_samples2],\n    limits=[[-3, 3] * 3],\n    figsize=(5, 5),\n    diag=[\"hist\", \"hist\"],\n    upper=[\"scatter\", \"scatter\"],\n    diag_kwargs={\n        \"mpl_kwargs\": {\n            \"bins\": 10,\n            \"edgecolor\": 'white',\n            \"linewidth\": 1,\n            \"alpha\": 0.6,\n            \"histtype\": \"bar\",\n            \"fill\": True,\n        }\n    },\n    upper_kwargs={\"mpl_kwargs\": {\"s\": 50, \"alpha\": 0.8}},\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n)\n</code></pre> <p></p>"},{"location":"tutorials/17_plotting_functionality/#multi-layered-plots","title":"Multi-layered plots","text":"<p>We can use the same functionality to make a multi-layered plot using the same set of samples, e.g. a kernel-density estimate on top of a scatter plot.</p> <pre><code>_ = pairplot(\n    [posterior_samples, posterior_samples],\n    limits=[[-3, 3] * 3],\n    figsize=(5, 5),\n    diag=[\"hist\", None],\n    upper=[\"scatter\", \"contour\"],\n    diag_kwargs={\n        \"mpl_kwargs\": {\n            \"bins\": 10,\n            \"color\": 'tab:blue',\n            \"edgecolor\": 'white',\n            \"linewidth\": 1,\n            \"alpha\": 0.6,\n            \"histtype\": \"bar\",\n            \"fill\": True,\n        },\n    },\n    upper_kwargs=[\n        {\n            \"mpl_kwargs\": {\"color\": 'tab:blue', \"s\": 20, \"alpha\": 0.8},\n        },\n        {\"mpl_kwargs\": {\"cmap\": 'Blues_r', \"alpha\": 0.8, \"colors\": None}},\n    ],\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n    fig_kwargs={\"despine\": {\"offset\": 0}},\n)\n</code></pre> <p></p>"},{"location":"tutorials/17_plotting_functionality/#lower-diagonal","title":"Lower diagonal","text":"<p>We can add something in the lower off-diagonal as well.</p> <pre><code>_ = pairplot(\n    [posterior_samples, posterior_samples],\n    limits=[[-3, 3] * 3],\n    figsize=(5, 5),\n    diag=[\"hist\", None],\n    upper=[\"scatter\", \"contour\"],\n    lower=[\"kde\", None],\n    diag_kwargs={\n        \"mpl_kwargs\": {\n            \"bins\": 10,\n            \"color\": 'tab:blue',\n            \"edgecolor\": 'white',\n            \"linewidth\": 1,\n            \"alpha\": 0.6,\n            \"histtype\": \"bar\",\n            \"fill\": True,\n        }\n    },\n    upper_kwargs=[\n        {\"mpl_kwargs\": {\"color\": 'tab:blue', \"s\": 20, \"alpha\": 0.8}},\n        {\"mpl_kwargs\": {\"cmap\": 'Blues_r', \"alpha\": 0.8, \"colors\": None}},\n    ],\n    lower_kwargs={\"mpl_kwargs\": {\"cmap\": \"Blues_r\"}},\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n)\n</code></pre> <p></p>"},{"location":"tutorials/17_plotting_functionality/#adding-observed-data","title":"Adding observed data","text":"<p>We can also add points, e.g., our observed data \\(\\theta_o\\) to the plot.</p> <pre><code># fake observed data:\ntheta_o = torch.ones(1, 3)\n\n_ = pairplot(\n    [posterior_samples, posterior_samples],\n    limits=[[-3, 3] * 3],\n    figsize=(5, 5),\n    diag=[\"hist\", None],\n    upper=[\"scatter\", \"contour\"],\n    diag_kwargs={\n        \"mpl_kwargs\": {\n            \"bins\": 10,\n            \"color\": 'tab:blue',\n            \"edgecolor\": 'white',\n            \"linewidth\": 1,\n            \"alpha\": 0.6,\n            \"histtype\": \"bar\",\n            \"fill\": True,\n        }\n    },\n    upper_kwargs=[\n        {\"mpl_kwargs\": {\"color\": 'tab:blue', \"s\": 20, \"alpha\": 0.8}},\n        {\"mpl_kwargs\": {\"cmap\": 'Blues_r', \"alpha\": 0.8, \"colors\": None}},\n    ],\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n    points=theta_o,\n    fig_kwargs={\n        \"points_labels\": [r\"$\\theta_o$\"],\n        \"legend\": True,\n        \"points_colors\": [\"purple\"],\n        \"points_offdiag\": {\"marker\": \"+\", \"markersize\": 20},\n        \"despine\": {\"offset\": 0},\n    },\n)\n</code></pre> <p></p>"},{"location":"tutorials/17_plotting_functionality/#subsetting-the-plot","title":"Subsetting the plot","text":"<p>For high-dimensional posteriors, we might only want to visualise a subset of the marginals. This can be done by passing a list of entries to plot to the <code>subset</code> argument of the <code>pairplot</code> function.</p> <pre><code>_ = pairplot(\n    [posterior_samples, posterior_samples],\n    limits=[[-3, 3] * 3],\n    figsize=(5, 5),\n    subset=[0, 2],\n    diag=[\"hist\", None],\n    upper=[\"scatter\", \"contour\"],\n    diag_kwargs={\n        \"mpl_kwargs\": {\n            \"bins\": 10,\n            \"color\": 'tab:blue',\n            \"edgecolor\": 'white',\n            \"linewidth\": 1,\n            \"alpha\": 0.6,\n            \"histtype\": \"bar\",\n            \"fill\": True,\n        }\n    },\n    upper_kwargs=[\n        {\"mpl_kwargs\": {\"color\": 'tab:blue', \"s\": 20, \"alpha\": 0.8}},\n        {\"mpl_kwargs\": {\"cmap\": 'Blues_r', \"alpha\": 0.8, \"colors\": None}},\n    ],\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n    points=theta_o,\n    fig_kwargs={\n        \"points_labels\": [r\"$\\theta_o$\"],\n        \"legend\": True,\n        \"points_colors\": [\"purple\"],\n        \"points_offdiag\": {\"marker\": \"+\", \"markersize\": 20},\n        \"despine\": {\"offset\": 0},\n    },\n)\n</code></pre> <p></p>"},{"location":"tutorials/17_plotting_functionality/#plot-just-the-marginals","title":"Plot just the marginals","text":"<p>1D Marginals can also be visualised using the <code>marginal_plot</code> function</p> <pre><code>from sbi.analysis import marginal_plot\n\n# plot posterior samples\n_ = marginal_plot(\n    [posterior_samples, posterior_samples],\n    limits=[[-3, 3] * 3],\n    subset=[0, 1],\n    diag=[\"hist\", None],\n    diag_kwargs={\n        \"mpl_kwargs\": {\n            \"bins\": 10,\n            \"color\": 'tab:blue',\n            \"edgecolor\": 'white',\n            \"linewidth\": 1,\n            \"alpha\": 0.6,\n            \"histtype\": \"bar\",\n            \"fill\": True,\n        },\n    },\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n    points=[torch.ones(1, 3)],\n    figsize=(4, 2),\n    fig_kwargs={\n        \"points_labels\": [r\"$\\theta_o$\"],\n        \"legend\": True,\n        \"points_colors\": [\"purple\"],\n        \"points_offdiag\": {\"marker\": \"+\", \"markersize\": 20},\n        \"despine\": {\"offset\": 0},\n    },\n)\n</code></pre> <p></p>"},{"location":"tutorials/18_training_interface/","title":"More flexibility over the training loop and samplers","text":"<p>Note, you can find the original version of this notebook at tutorials/18_training_interface.ipynb in the <code>sbi</code> repository.</p> <p>In the previous tutorials, we showed how <code>sbi</code> can be used to train neural networks and sample from the posterior. If you are an <code>sbi</code> power-user, then you might want more control over individual stages of this process. For example, you might want to write a custom training loop or more flexibility over the samplers that are used. In this tutorial, we will explain how you can achieve this.</p> <pre><code>import torch\nfrom torch import ones, eye\nfrom torch.optim import Adam, AdamW\n\nfrom sbi.utils import BoxUniform\nfrom sbi.analysis import pairplot\nfrom typing import Callable\n</code></pre> <p>As in the previous tutorials, we first define the prior and simulator and use them to generate simulated data: </p> <pre><code>prior = BoxUniform(-3 * ones((2,)), 3 * ones((2,)))\n\ndef simulator(theta):\n    return theta + torch.randn_like(theta) * 0.1\n\nnum_simulations = 2000\ntheta = prior.sample((num_simulations,))\nx = simulator(theta)\n</code></pre> <p>Below, we will first describe how you can run <code>Neural Posterior Estimation (NPE)</code>. We will attach code snippets for <code>Neural Likelihood Estimation (NLE)</code> and <code>Neural Ratio Estimation (NRE)</code> at the end.</p>"},{"location":"tutorials/18_training_interface/#neural-posterior-estimation","title":"Neural Posterior Estimation","text":"<p>First, we have to decide on what <code>DensityEstimator</code> to use. In this tutorial, we will use a <code>Neural Spline Flow</code> (NSF) taken from the <code>nflows</code> package.</p> <pre><code>from sbi.neural_nets.net_builders import build_nsf\n\ndensity_estimator = build_nsf(theta, x)\n</code></pre> <p>Every <code>density_estimator</code> in <code>sbi</code> implements at least two methods: <code>.sample()</code> and <code>.loss()</code>. Their input and output shapes are:</p> <p><code>density_estimator.loss(input, condition)</code>: <pre><code>Args:\n    input: `(batch_dim, *event_shape_input)`\n    condition: `(batch_dim, *event_shape_condition)`\n\nReturns:\n    Loss of shape `(batch_dim,)`\n</code></pre></p> <p><code>density_estimator.sample(sample_shape, condition)</code>: <pre><code>Args:\n    sample_shape: Tuple of ints which indicates the desired number of samples.\n    condition: `(batch_dim, *event_shape_condition)`\n\nReturns:\n    Samples of shape `(sample_shape, batch_dim, *event_shape_input)`\n</code></pre></p> <p>Some <code>DensityEstimator</code>s, such as Normalizing flows, also allow to evaluate the <code>log probability</code>. In those cases, the <code>DensityEstimator</code> also has the following method:</p> <p><code>density_estimator.log_prob(input, condition)</code>: <pre><code>Args:\n    input: `(sample_dim, batch_dim, *event_shape_input)`\n    condition: `(batch_dim, *event_shape_condition)`\n\nReturns:\n    Loss of shape `(sample_dim, batch_dim,)`\n</code></pre></p>"},{"location":"tutorials/18_training_interface/#training-the-density-estimator","title":"Training the density estimator","text":"<p>We can now write our own custom training loop to train the above-generated <code>DensityEstimator</code>:</p> <pre><code>opt = Adam(list(density_estimator.parameters()), lr=5e-4)\n\nfor _ in range(200):\n    opt.zero_grad()\n    losses = density_estimator.loss(theta, condition=x)\n    loss = torch.mean(losses)\n    loss.backward()\n    opt.step()\n</code></pre> <p>Given this trained <code>density_estimator</code>, we can already generate samples from the posterior given observations (but we have to adhere to the shape specifications of the <code>DensityEstimator</code> explained above:</p> <pre><code>x_o = torch.as_tensor([[1.0, 1.0]])\nprint(f\"Shape of x_o: {x_o.shape}            # Must have a batch dimension\")\n\nsamples = density_estimator.sample((1000,), condition=x_o).detach()\nprint(f\"Shape of samples: {samples.shape}  # Samples are returned with a batch dimension.\")\n\nsamples = samples.squeeze(dim=1)\nprint(f\"Shape of samples: {samples.shape}     # Removed batch dimension.\")\n</code></pre> <pre><code>Shape of x_o: torch.Size([1, 2])            # Must have a batch dimension\nShape of samples: torch.Size([1000, 1, 2])  # Samples are returned with a batch dimension.\nShape of samples: torch.Size([1000, 2])     # Removed batch dimension.\n</code></pre> <pre><code>pairplot(samples, limits=[[-3, 3], [-3, 3]], figsize=(3, 3));\n</code></pre> <p></p>"},{"location":"tutorials/18_training_interface/#wrapping-as-a-directposterior","title":"Wrapping as a <code>DirectPosterior</code>","text":"<p>You can also wrap the <code>DensityEstimator</code> as a <code>DirectPosterior</code>. The <code>DirectPosterior</code> is also returned by  <code>inference.build_posterior</code> and you have already learned how to use it in the introduction tutorial and the amortization tutotrial. It adds the following functionality over the raw <code>DensityEstimator</code>:</p> <ul> <li>automatically reject samples outside of the prior bounds  </li> <li>compute the Maximum-a-posteriori (MAP) estimate</li> </ul> <pre><code>from sbi.inference.posteriors import DirectPosterior\n\nposterior = DirectPosterior(density_estimator, prior)\n</code></pre> <pre><code>print(f\"Shape of x_o: {x_o.shape}\")\nsamples = posterior.sample((1000,), x=x_o)\nprint(f\"Shape of samples: {samples.shape}\")\n</code></pre> <pre><code>Shape of x_o: torch.Size([1, 2])\n\n\nShape of samples: torch.Size([1000, 2])\n</code></pre> <p>Note: For the <code>DirectPosterior</code>, the batch dimension is optional, i.e., it is possible to sample for multiple observations simultaneously. Use <code>.sample_batch</code> in that case.</p> <pre><code>_ = pairplot(samples, limits=[[-3, 3], [-3, 3]], figsize=(3, 3), upper=\"contour\")\n</code></pre> <p></p>"},{"location":"tutorials/18_training_interface/#custom-data-loaders","title":"Custom Data Loaders","text":"<p>One helpful advantage of having access to the training loop is that you can now use your own DataLoaders during training of the density estimator. In this fashion, larger datasets can be used as input to <code>sbi</code> where <code>x</code> is potentially an image or something else. While this will require embedding the input data, a more fine grained control over loading the data is possible and allows to manage the memory requirement during training.</p> <p>First, we build a Dataset that complies with the <code>torch.util.data.Dataset</code> API. Note, the class below is meant for illustration purposes. In practice, this class can also read the data from disk etc.</p> <pre><code>class NPEData(torch.utils.data.Dataset):\n\n    def __init__(self,\n                 num_samples: int,\n                 prior: torch.distributions.Distribution,\n                 simulator: Callable,\n                 seed: int = 44):\n        super().__init__()\n\n        torch.random.manual_seed(seed) #will set the seed device wide\n        self.prior = prior\n        self.simulator = simulator\n\n        self.theta = prior.sample((num_samples,))\n        self.x = simulator(self.theta)\n\n    def __len__(self):\n        return self.theta.shape[0]\n\n    def __getitem__(self, index:int):\n        return self.theta[index,...], self.x[index,...]\n</code></pre> <p>We can now proceed to create a DataLoader and conduct our training loop as illustrated above.</p> <pre><code>train_data = NPEData(num_samples=2048, prior=prior, simulator=simulator)\ntrain_loader = torch.utils.data.DataLoader(train_data, batch_size=128)\n</code></pre> <p>For sake of demonstration, let\u2019s create another estimator using a masked autoregressive flow (maf). For this, we create a second dataset and use only parts of the data to construct the maf estimator.</p> <pre><code>from sbi.neural_nets.net_builders import build_maf\n\ndummy_data = NPEData(64, prior, simulator, seed=43)\ndummy_loader = torch.utils.data.DataLoader(dummy_data, batch_size=4)\ndummy_theta, dummy_x = next(iter(dummy_loader))\nmaf_estimator = build_maf(dummy_theta, dummy_x)\n</code></pre> <pre><code>optw = AdamW(list(maf_estimator.parameters()), lr=5e-4)\nnum_epochs = 100\n\nfor ep in range(num_epochs):\n    for idx, (theta_batch, x_batch) in enumerate(train_loader):\n        optw.zero_grad()\n        losses = maf_estimator.loss(theta_batch, condition=x_batch)\n        loss = torch.mean(losses)\n        loss.backward()\n        optw.step()\n    if ep % 10 == 0:\n        print(\"last loss\", loss.item())\n</code></pre> <pre><code>last loss 4.49238920211792\nlast loss -1.2831010818481445\nlast loss -1.5764970779418945\nlast loss -1.6195335388183594\nlast loss -1.6439297199249268\nlast loss -1.6492975950241089\nlast loss -1.6488871574401855\nlast loss -1.6473512649536133\nlast loss -1.6515816450119019\nlast loss -1.6809775829315186\n</code></pre> <pre><code># let's compare the trained estimator to the NSF from above\nsamples = maf_estimator.sample((1000,), condition=x_o).detach()\nprint(f\"Shape of samples: {samples.shape}  # Samples are returned with a batch dimension.\")\n\nsamples = samples.squeeze(dim=1)\nprint(f\"Shape of samples: {samples.shape}     # Removed batch dimension.\")\n</code></pre> <pre><code>Shape of samples: torch.Size([1000, 1, 2])  # Samples are returned with a batch dimension.\nShape of samples: torch.Size([1000, 2])     # Removed batch dimension.\n</code></pre> <pre><code>_ = pairplot(samples, limits=[[-3, 3], [-3, 3]], figsize=(3, 3))\n</code></pre> <p></p>"},{"location":"tutorials/18_training_interface/#neural-likelihood-estimation","title":"Neural Likelihood Estimation","text":"<p>The workflow for Neural Likelihood Estimation is very similar. Unlike for NPE, we have to sample with MCMC (or variational inference) though, so we will build an <code>MCMCPosterior</code> after training:</p> <pre><code>from sbi.inference.posteriors import MCMCPosterior\nfrom sbi.inference.potentials import likelihood_estimator_based_potential\n</code></pre> <pre><code># Note that the order of x and theta are reversed in comparison to NPE.\ndensity_estimator = build_nsf(x, theta)\n\n# Training loop.\nopt = Adam(list(density_estimator.parameters()), lr=5e-4)\nfor _ in range(200):\n    opt.zero_grad()\n    losses = density_estimator.loss(x, condition=theta)\n    loss = torch.mean(losses)\n    loss.backward()\n    opt.step()\n\n# Build the posterior.\npotential, tf = likelihood_estimator_based_potential(density_estimator, prior, x_o)\nposterior = MCMCPosterior(\n    potential,\n    proposal=prior,\n    theta_transform=tf,\n    num_chains=50,\n    thin=1,\n    method=\"slice_np_vectorized\"\n)\n</code></pre> <pre><code>samples = posterior.sample((1000,), x=x_o)\npairplot(samples, limits=[[-3, 3], [-3, 3]], figsize=(3, 3), upper=\"contour\");\n</code></pre> <p></p>"},{"location":"tutorials/18_training_interface/#neural-ratio-estimation","title":"Neural Ratio Estimation","text":"<p>Finally, for NRE, at this point, you have to implement the loss function yourself:</p> <pre><code>from sbi.neural_nets.net_builders import build_resnet_classifier\nfrom sbi.inference.potentials import ratio_estimator_based_potential\nfrom sbi import utils as utils\n</code></pre> <pre><code>net = build_resnet_classifier(x, theta)\n</code></pre> <pre><code>opt = Adam(list(net.parameters()), lr=5e-4)\n\n\ndef classifier_logits(net, theta, x, num_atoms):\n    batch_size = theta.shape[0]\n    repeated_x = utils.repeat_rows(x, num_atoms)\n    probs = ones(batch_size, batch_size) * (1 - eye(batch_size)) / (batch_size - 1)\n    choices = torch.multinomial(probs, num_samples=num_atoms - 1, replacement=False)\n    contrasting_theta = theta[choices]\n    atomic_theta = torch.cat((theta[:, None, :], contrasting_theta), dim=1).reshape(\n        batch_size * num_atoms, -1\n    )\n    return net(atomic_theta, repeated_x)\n\n\nnum_atoms = 10\nfor _ in range(300):\n    opt.zero_grad()\n    batch_size = theta.shape[0]\n    logits = classifier_logits(net, theta, x, num_atoms=num_atoms)\n    logits = logits.reshape(batch_size, num_atoms)\n    log_probs = logits[:, 0] - torch.logsumexp(logits, dim=-1)\n    loss = -torch.mean(log_probs)\n    loss.backward()\n    opt.step()\n</code></pre> <pre><code>potential, tf = ratio_estimator_based_potential(net, prior, x_o)\nposterior = MCMCPosterior(\n    potential,\n    proposal=prior,\n    theta_transform=tf,\n    num_chains=100,\n    method=\"slice_np_vectorized\"\n)\n</code></pre> <pre><code>samples = posterior.sample((1000,), x=x_o)\npairplot(samples, limits=[[-3, 3], [-3, 3]], figsize=(3, 3));\n</code></pre> <p></p>"},{"location":"tutorials/19_flowmatching_and_scorematching/","title":"Flow-Matching Posterior Estimation (FMPE) and Neural Posterior Score Estimation (NPSE)","text":"<p><code>sbi</code> also incorporates recent algorithms based on Flow Matching and Score Matching generative models, which are also referred to as Continuous Normalizing Flows (CNF) and Denoising Diffusion Probabilistic Models (DDPM), respectively.</p> <p>At the highest level, you can conceptualize FMPE and NPSE as tackling the exact same problem as NPE, i.e., estimating the posterior from simulations, but replacing Normalizing Flows with different conditional density estimators. </p> <p>Flow Matching and Score Matching, as generative models, are also quite similar to Normalizing Flows, where a deep neural network parameterizes the transformation from a base distribution (e.g., Gaussian) to a more complex one that approximates the target density, but they differ in what this transformation looks like (more on that below). </p> <p>Beyond that, Flow Matching and Score Matching offer different benefits and drawbacks compared to Normalizing Flows, which make them better (or worse) choices for some problems. For examples, Score Matching (Diffusion Models) are known to be very flexible and can model high-dimensional distributions, but are comparatively slow during sampling.</p> <p>In this tutorial, we take a brief look at the API for <code>FMPE</code> and <code>NPSE</code>, their pros and cons, as well as highlight some notable options.</p> <p>For more information, see:</p> <p>Score Matching: - Hyv\u00e4rinen, A. \u201cEstimation of Non-Normalized Statistical Models by Score Matching.\u201d JMLR 2005. - Song, Y., et al. \u201cScore-Based Generative Modeling through Stochastic Differential Equations.\u201d ICLR 2021. - Geffner, T., Papamakarios, G., and Mnih, A. \u201cScore modeling for simulation-based inference.\u201d NeurIPS 2022 Workshop on Score-Based Methods. 2022. - Sharrock, L., Simons, J., et al. \u201cSequential neural score estimation: Likelihood-free inference with conditional score based diffusion models.\u201d ICML 2024.</p> <p>Flow Matching: - Lipman, Y., et al. \u201cFlow Matching for Generative Modeling.\u201d ICLR 2023 - Wildberger, J.B.,  Buchholz, S., et al. \u201cFlow Matching for Scalable Simulation-Based Inference.\u201d NeurIPS 2023.</p> <pre><code>import torch\n\nfrom sbi.inference import NPSE\nfrom sbi.utils import BoxUniform\nfrom sbi.analysis import pairplot\n</code></pre> <pre><code># Example toy simulator\n# Define the prior\nnum_dims = 3\nnum_sims = 5000\nprior = BoxUniform(low=-torch.ones(num_dims), high=torch.ones(num_dims))\n\ndef simulator(theta):\n    \"\"\"Linear gaussian simulator.\"\"\"\n    return theta + 1.0 + torch.randn_like(theta) * 0.1\n\n# Produce simulations\ntheta = prior.sample((num_sims,))\nx = simulator(theta)\n\ntheta_o = torch.zeros(num_dims)\nx_o = simulator(theta_o)\n</code></pre>"},{"location":"tutorials/19_flowmatching_and_scorematching/#fmpe","title":"FMPE","text":"<p>Flow-Matching Posterior Estimation (FMPE) is an approach to Simulation-Based Inference (SBI) that leverages Flow Matching, a generative modeling technique where the transformation from a simple base distribution (like a Gaussian) to the target distribution is learned through matching the flow of probability densities.</p>"},{"location":"tutorials/19_flowmatching_and_scorematching/#key-concept","title":"Key Concept:","text":"<ul> <li>Flow Matching: The core idea is to model the probability flow between the base   distribution and the target distribution by minimizing a discrepancy between their   \u201cflows\u201d or \u201cdynamics\u201d in the latent space. This is typically done by training a neural   network to parameterize a vector field that defines how samples should be moved or   transformed in order to follow the target distribution.</li> </ul>"},{"location":"tutorials/19_flowmatching_and_scorematching/#step-by-step-process","title":"Step-by-Step Process:","text":"<ol> <li>Base Distribution: Start with a simple base distribution (e.g., Gaussian).</li> <li>Neural Network Parameterization: Use a neural network to learn a vector field    that describes the flow from the base distribution to the target distribution.</li> <li>Flow Matching Objective: Optimize the neural network to minimize a loss function    that captures the difference between the flow of the base distribution and the target    distribution.</li> <li>Sampling: Once trained, draw samples from the base distribution and apply the    learned flow transformation to obtain samples from the approximate posterior    distribution.</li> </ol> <p>FMPE can be more efficient than traditional normalizing flows in some settings, especially when the target distribution has complex structures or when high-dimensional data is involved (see Dax et al., 2023, https://arxiv.org/abs/2305.17161 for an example). However, compared to (discrete time) normalizing flows, flow matching is usually slower at inference time because sampling and evaluation of the target distribution requires solving the underlying ODE (compared to just doing a NN forward pass for normalizing flows). </p> <p>In the next cell, we\u2019ll show how to use FMPE using the <code>sbi</code> package.</p> <pre><code>from sbi.inference import FMPE\nfrom sbi.neural_nets import flowmatching_nn\n\n# the quick way\ntrainer = FMPE(prior)\ntrainer.append_simulations(theta, x).train()\nposterior = trainer.build_posterior()\n</code></pre> <pre><code> Neural network successfully converged after 61 epochs.\n</code></pre> <pre><code># Set up a custom vector field neural network\nnet_builder = flowmatching_nn(\n    model=\"resnet\",\n    num_blocks=3,\n    hidden_features=24,\n    # embedding_net=CNNEmbedding  # e.g., for image data.\n)\ntrainer = FMPE(prior, density_estimator=net_builder)\ntrainer.append_simulations(theta, x).train(training_batch_size=200, learning_rate=5e-4)\nposterior = trainer.build_posterior()\nposterior_samples = posterior.sample((10000,), x_o)\n</code></pre> <pre><code> Neural network successfully converged after 125 epochs.\n</code></pre> <pre><code># plot posterior samples\nfig, ax = pairplot(\n    posterior_samples, limits=[[-2, 2], [-2, 2], [-2, 2]], figsize=(5, 5),\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n    points=theta_o # add ground truth thetas\n)\n</code></pre> <p></p>"},{"location":"tutorials/19_flowmatching_and_scorematching/#npse","title":"NPSE","text":"<p>NPSE approximates the posterior distribution by learning its score function, i.e., gradient of the log-density, using the denoising score matching loss. The class of generative models is referred to as score-based generative models, with close links to diffusion models.</p> <ul> <li>Score-based generative models have been shown to scale well to very high dimensions (e.g., high-resolutions images), which is particularly useful when the parameter space (and hence, the target posterior) is high-dimensional.</li> <li>On the other hand, sampling can be slower as it involves solving many steps of the stochastic differential equation for reversing the diffusion process.</li> </ul> <p>Note that only the single-round version of NPSE is implemented currently.</p> <p>For more details on score-based generative models, see Song et al., 2020 (in particular, Figure 1 and 2).</p> <pre><code># Instantiate NPSE and append simulations\ninference = NPSE(prior=prior, sde_type=\"ve\")\ninference.append_simulations(theta, x)\n</code></pre> <p>Note the argument <code>sde_type</code>, which defines whether the forward diffusion process has a noising schedule that is Variance Exploding (<code>ve</code>, i.e., SMLD), Variance Preserving (<code>vp</code>, i.e., DDPM), or sub-Variance Preserving (<code>subvp</code>) in the limit.</p> <pre><code># Train the score estimator\nscore_estimator = inference.train()\n</code></pre> <pre><code> Neural network successfully converged after 365 epochs.\n</code></pre> <pre><code># Build the posterior using the trained score estimator, and sample\nposterior = inference.build_posterior(score_estimator)\nposterior_samples = posterior.sample((10000,), x=x_o)\n</code></pre> <pre><code># plot posterior samples\nfig, ax = pairplot(\n    posterior_samples, limits=[[-2, 2], [-2, 2], [-2, 2]], figsize=(5, 5),\n    labels=[r\"$\\theta_1$\", r\"$\\theta_2$\", r\"$\\theta_3$\"],\n    points=theta_o # add ground truth thetas\n)\n</code></pre> <p></p>"},{"location":"tutorials/Example_00_HodgkinHuxleyModel/","title":"Inference on Hodgkin-Huxley model: tutorial","text":"<p>In this tutorial, we use <code>sbi</code> to do inference on a Hodgkin-Huxley model from neuroscience (Hodgkin and Huxley, 1952). </p> <p>We want to infer the posterior distribution of two parameters (\\(\\bar g_{Na}\\),\\(\\bar g_K\\)) based on a current-clamp recording, that we generate synthetically (in practice, this would be an experimental observation).</p> <p>Note, you find the original version of this notebook in the <code>sbi</code> repository under tutorials/Example_00_HodgkinHuxleyModel.ipynb.</p> <p>First we are going to import basic packages.</p> <pre><code># visualization\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\n\nfrom sbi import analysis as analysis\n\n# sbi\nfrom sbi import utils as utils\nfrom sbi.inference import NPE, simulate_for_sbi\nfrom sbi.utils.user_input_checks import (\n    check_sbi_inputs,\n    process_prior,\n    process_simulator,\n)\n</code></pre> <pre><code># remove top and right axis from plots\nmpl.rcParams[\"axes.spines.right\"] = False\nmpl.rcParams[\"axes.spines.top\"] = False\n</code></pre>"},{"location":"tutorials/Example_00_HodgkinHuxleyModel/#different-required-components","title":"Different required components","text":"<p>Before running inference, let us define the different required components: 1. observational data  - the observations in this case a simulated volatge trace (or summary statistics thereof)  1. a candidate (mechanistic) model - the simulator in this case the Hodgkin-Huxley model 1. the - prior over the model parameters in this case over (\\(\\bar g_{Na}\\),\\(\\bar g_K\\))</p> <p>Note: that you do not need to fully understand the details of the HH-model and model specific jargon to get an intuition for how SBI works in this scientific use case. </p>"},{"location":"tutorials/Example_00_HodgkinHuxleyModel/#1-observed-data","title":"1. Observed data","text":"<p>Let us assume we current-clamped a neuron and recorded the following voltage trace:</p> <p> </p> <p>In fact, this voltage trace was not measured experimentally but synthetically generated by simulating a Hodgkin-Huxley model with particular parameters (\\(\\bar g_{Na}\\),\\(\\bar g_K\\)). We will come back to this point later in the tutorial.</p>"},{"location":"tutorials/Example_00_HodgkinHuxleyModel/#2-simulator","title":"2. Simulator","text":"<p>We would like to infer the posterior over the two parameters (\\(\\color{orange}{\\bar g_{Na}}\\),\\(\\color{orange}{\\bar g_K}\\)) of a Hodgkin-Huxley model, given the observed electrophysiological recording above. The model has channel kinetics as in Pospischil et al. 2008, and is defined by the following set of differential equations (parameters of interest highlighted in orange):</p> \\[ \\scriptsize \\begin{align} \\color{black}{C_m\\frac{dV}{dt}}&amp; \\color{black}{=g_1\\left(E_1-V\\right)}+                     \\color{orange}{\\bar{g}_{Na}} \\color{black}{m^3h\\left(E_{Na}-V\\right)+}                     \\color{orange}{\\bar{g}_{K}} \\color{black}{n^4\\left(E_K-V\\right)+\\bar{g}_Mp\\left(E_K-V\\right)+I_{inj}+\\sigma\\eta\\left(t\\right)}\\\\                     \\color{black}{\\frac{dq}{dt}}&amp;\\color{black}{=\\frac{q_\\infty\\left(V\\right)-q}{\\tau_q\\left(V\\right)},\\;q\\in\\{m,h,n,p\\}} \\end{align} \\] <p>Above, \\(V\\) represents the membrane potential, \\(C_m\\) is the membrane capacitance, \\(g_{\\text{l}}\\) is the leak conductance, \\(E_{\\text{l}}\\) is the membrane reversal potential, \\(\\bar{g}_c\\) is the density of channels of type \\(c\\) (\\(\\text{Na}^+\\), \\(\\text{K}^+\\), M), \\(E_c\\) is the reversal potential of \\(c\\), (\\(m\\), \\(h\\), \\(n\\), \\(p\\)) are the respective channel gating kinetic variables, and \\(\\sigma \\eta(t)\\) is the intrinsic neural noise. The right hand side of the voltage dynamics is composed of a leak current, a voltage-dependent \\(\\text{Na}^+\\) current, a delayed-rectifier \\(\\text{K}^+\\) current, a slow voltage-dependent \\(\\text{K}^+\\) current responsible for spike-frequency adaptation, and an injected current \\(I_{\\text{inj}}\\). Channel gating variables \\(q\\) have dynamics fully characterized by the neuron membrane potential \\(V\\), given the respective steady-state \\(q_{\\infty}(V)\\) and time constant \\(\\tau_{q}(V)\\) (details in Pospischil et al. 2008).</p> <p>The input current \\(I_{\\text{inj}}\\) is defined as</p> <pre><code>from HH_helper_functions import syn_current\n\n# current, onset time of stimulation, offset time of stimulation, time step, time, area of some\nI_inj, t_on, t_off, dt, t, A_soma = syn_current()\n</code></pre> <p>The Hodgkin-Huxley simulator takes the parameters as input together with other arguments such as the initial voltage state, the integration timestep, time and injected current:</p> <pre><code>from HH_helper_functions import HHsimulator\n</code></pre> <p>Putting the input current and the simulator together:</p> <pre><code>def run_HH_model(params):\n\n    params = np.asarray(params)\n\n    # input current, time step\n    I_inj, t_on, t_off, dt, t, A_soma = syn_current()\n\n    t = np.arange(0, len(I_inj), 1) * dt\n\n    # initial voltage V0\n    initial_voltage = -70\n\n    voltage_trace = HHsimulator(initial_voltage, params.reshape(1, -1), dt, t, I_inj)\n\n    return dict(data=voltage_trace.reshape(-1), time=t, dt=dt, I_inj=I_inj.reshape(-1))\n</code></pre> <p>To get an idea of the output of the Hodgkin-Huxley model, let us generate some voltage traces for different parameters (\\(\\bar g_{Na}\\),\\(\\bar g_K\\)), given the input current \\(I_{\\text{inj}}\\):</p> <pre><code># three sets of (g_Na, g_K)\nparams = np.array([[50.0, 1.0], [4.0, 1.5], [20.0, 15.0]])\n\nnum_samples = len(params[:, 0])\nsim_samples = np.zeros((num_samples, len(I_inj)))\nfor i in range(num_samples):\n    sim_samples[i, :] = run_HH_model(params=params[i, :])[\"data\"]\n</code></pre> <pre><code># colors for traces\ncol_min = 2\nnum_colors = num_samples + col_min\ncm1 = mpl.cm.Blues\ncol1 = [cm1(1.0 * i / num_colors) for i in range(col_min, num_colors)]\n\nfig = plt.figure(figsize=(7, 5))\ngs = mpl.gridspec.GridSpec(2, 1, height_ratios=[4, 1])\nax = plt.subplot(gs[0])\n# plot the three voltage traces for different parameter sets\nfor i in range(num_samples):\n    plt.plot(t, sim_samples[i, :], color=col1[i], lw=2)\nplt.ylabel(\"voltage (mV)\")\nax.set_xticks([])\nax.set_yticks([-80, -20, 40])\n\n# plot the injected current\nax = plt.subplot(gs[1])\nplt.plot(t, I_inj * A_soma * 1e3, \"k\", lw=2)\nplt.xlabel(\"time (ms)\")\nplt.ylabel(\"input (nA)\")\n\nax.set_xticks([0, max(t) / 2, max(t)])\nax.set_yticks([0, 1.1 * np.max(I_inj * A_soma * 1e3)])\nax.yaxis.set_major_formatter(mpl.ticker.FormatStrFormatter(\"%.2f\"))\nplt.show()\n</code></pre> <p></p> <p>As can be seen, the voltage traces can be quite diverse for different parameter values.</p> <p>Often, we are not interested in matching the exact trace, but only in matching certain features thereof. In this example of the Hodgkin-Huxley model, the summary features are the number of spikes, the mean resting potential, the standard deviation of the resting potential, and the first four voltage moments: mean, standard deviation, skewness and kurtosis. Using the function <code>calculate_summary_statistics()</code> imported below, we obtain these statistics from the output of the Hodgkin Huxley simulator.</p> <pre><code>from HH_helper_functions import calculate_summary_statistics\n</code></pre> <p>Note: the summary features depend on the simulator and observations under investigation. Check out our tutorials on crafting summary statistics. </p> <p>Lastly, we define a function that performs all of the above steps at once, to have one object we pass to the inference method as our simulator. The function <code>simulation_wrapper</code> takes in the parameters, runs the Hodgkin Huxley model and then returns the summary statistics.</p> <pre><code>def simulation_wrapper(params):\n    \"\"\"\n    Returns summary statistics from conductance values in `params`.\n\n    Summarizes the output of the HH simulator and converts it to `torch.Tensor`.\n    \"\"\"\n    obs = run_HH_model(params)\n    summstats = torch.as_tensor(calculate_summary_statistics(obs))\n    return summstats\n</code></pre> <p>Note: <code>sbi</code> takes any function as simulator. Thus, <code>sbi</code> also has the flexibility to use simulators that utilize external packages, e.g., Brian (http://briansimulator.org/), nest (https://www.nest-simulator.org/), or NEURON (https://neuron.yale.edu/neuron/). External simulators do not even need to be Python-based as long as they store simulation outputs in a format that can be read from Python. All that is necessary is to wrap your external simulator of choice into a Python callable that takes a parameter set and outputs a set of summary statistics we want to fit the parameters to.</p>"},{"location":"tutorials/Example_00_HodgkinHuxleyModel/#3-prior-over-model-parameters","title":"3. Prior over model parameters","text":"<p>Now that we have the simulator, we need to define a function with the prior over the model parameters (\\(\\bar g_{Na}\\),\\(\\bar g_K\\)), which in this case is chosen to be a Uniform distribution:</p> <p>Note: This is where you would incorporate prior knowlegde about the parameters you want to infer, e.g., ranges known from literature. </p> <pre><code>prior_min = [0.5, 1e-4]\nprior_max = [80.0, 15.0]\nprior = utils.torchutils.BoxUniform(\n    low=torch.as_tensor(prior_min), high=torch.as_tensor(prior_max)\n)\n\n# Check prior, simulator, consistency\nprior, num_parameters, prior_returns_numpy = process_prior(prior)\nsimulation_wrapper = process_simulator(simulation_wrapper, prior, prior_returns_numpy)\ncheck_sbi_inputs(simulation_wrapper, prior)\n</code></pre>"},{"location":"tutorials/Example_00_HodgkinHuxleyModel/#running-inference","title":"Running inference","text":"<p>Now that we have all the required components, we can run inference with <code>NPE</code> to identify parameters whose activity matches this trace.</p> <p>Note that this might take a few minutes.</p> <pre><code># Create inference object. Here, NPE is used.\ninference = NPE(prior=prior)\n\n# generate simulations and pass to the inference object\ntheta, x = simulate_for_sbi(simulation_wrapper, proposal=prior,\n                             num_simulations=300, num_workers=4)\ninference = inference.append_simulations(theta, x)\n\n# train the density estimator and build the posterior\ndensity_estimator = inference.train()\nposterior = inference.build_posterior(density_estimator)\n</code></pre> <pre><code> Neural network successfully converged after 296 epochs.\n</code></pre> <p>Note: <code>sbi</code> can parallelize your simulator. If you experience problems with parallelization, try setting <code>num_workers=1</code> and please give us an error report as a GitHub issue.</p>"},{"location":"tutorials/Example_00_HodgkinHuxleyModel/#coming-back-to-the-observed-data","title":"Coming back to the observed data","text":"<p>As mentioned at the beginning of the tutorial, the observed data are generated by the Hodgkin-Huxley model with a set of known parameters (\\(\\bar g_{Na}\\),\\(\\bar g_K\\)). To illustrate how to compute the summary statistics of the observed data, let us regenerate the observed data:</p> <pre><code># true parameters and respective labels\ntrue_params = np.array([50.0, 5.0])\nlabels_params = [r\"$g_{Na}$\", r\"$g_{K}$\"]\n</code></pre> <pre><code>observation_trace = run_HH_model(true_params)\nobservation_summary_statistics = calculate_summary_statistics(observation_trace)\n</code></pre> <p>As we have already shown above, the observed voltage traces look as follows:</p> <pre><code>fig = plt.figure(figsize=(7, 5))\ngs = mpl.gridspec.GridSpec(2, 1, height_ratios=[4, 1])\nax = plt.subplot(gs[0])\nplt.plot(observation_trace[\"time\"], observation_trace[\"data\"])\nplt.ylabel(\"voltage (mV)\")\nplt.title(\"observed data\")\nplt.setp(ax, xticks=[], yticks=[-80, -20, 40])\n\nax = plt.subplot(gs[1])\nplt.plot(observation_trace[\"time\"], I_inj * A_soma * 1e3, \"k\", lw=2)\nplt.xlabel(\"time (ms)\")\nplt.ylabel(\"input (nA)\")\n\nax.set_xticks([0, max(observation_trace[\"time\"]) / 2, max(observation_trace[\"time\"])])\nax.set_yticks([0, 1.1 * np.max(I_inj * A_soma * 1e3)])\nax.yaxis.set_major_formatter(mpl.ticker.FormatStrFormatter(\"%.2f\"))\n</code></pre> <p></p>"},{"location":"tutorials/Example_00_HodgkinHuxleyModel/#analysis-of-the-posterior-given-the-observed-data","title":"Analysis of the posterior given the observed data","text":"<p>After running the inference algorithm, let us inspect the inferred posterior distribution over the parameters (\\(\\bar g_{Na}\\),\\(\\bar g_K\\)), given the observed trace. To do so, we first draw samples (i.e. consistent parameter sets \\(\\bar g_{Na}^{samples}\\),\\(\\bar g_K^{samples}\\)) from the posterior:</p> <pre><code>samples = posterior.sample((10000,), x=observation_summary_statistics)\n</code></pre> <pre><code>fig, axes = analysis.pairplot(\n    samples,\n    limits=[[0.5, 80], [1e-4, 15.0]],\n    ticks=[[0.5, 80], [1e-4, 15.0]],\n    figsize=(5, 5),\n    points=true_params,\n    points_offdiag={\"markersize\": 6},\n    points_colors=\"r\",\n    labels=labels_params,\n);\n</code></pre> <p></p> <p>As can be seen, the inferred posterior contains the ground-truth parameters (red) in a high-probability region. Now, let us sample parameters from the posterior distribution, simulate the Hodgkin-Huxley model for this parameter set and compare the simulations with the observed data:</p> <pre><code># Draw a sample from the posterior and convert to numpy for plotting.\nposterior_sample = posterior.sample((1,), x=observation_summary_statistics).numpy()\n</code></pre> <pre><code>fig = plt.figure(figsize=(7, 5))\n\n# plot observation\nt = observation_trace[\"time\"]\ny_obs = observation_trace[\"data\"]\nplt.plot(t, y_obs, lw=2, label=\"observation\")\n\n# simulate and plot samples\nx = run_HH_model(posterior_sample)\nplt.plot(t, x[\"data\"], \"--\", lw=2, label=\"posterior sample\")\n\nplt.xlabel(\"time (ms)\")\nplt.ylabel(\"voltage (mV)\")\n\nax = plt.gca()\nhandles, labels = ax.get_legend_handles_labels()\nax.legend(handles[::-1], labels[::-1], bbox_to_anchor=(1.3, 1), loc=\"upper right\")\n\nax.set_xticks([0, 60, 120])\nax.set_yticks([-80, -20, 40]);\n</code></pre> <p></p> <p>As can be seen, the sample from the inferred posterior leads to simulations that closely resemble the observed data, confirming that <code>NPE</code> did a good job at capturing the observed data in this simple case.</p>"},{"location":"tutorials/Example_00_HodgkinHuxleyModel/#references","title":"References","text":"<p>A. L. Hodgkin and A. F. Huxley. A quantitative description of membrane current and its application to conduction and excitation in nerve. The Journal of Physiology, 117(4):500\u2013544, 1952.</p> <p>M. Pospischil, M. Toledo-Rodriguez, C. Monier, Z. Piwkowska, T. Bal, Y. Fr\u00e9gnac, H. Markram, and A. Destexhe. Minimal Hodgkin-Huxley type models for different classes of cortical and thalamic neurons. Biological Cybernetics, 99(4-5), 2008.</p>"},{"location":"tutorials/Example_01_DecisionMakingModel/","title":"SBI for decision-making models","text":"<p>In a previous tutorial, we showed how to use SBI with trial-based iid data. Such scenarios can arise, for example, in models of perceptual decision making. In addition to trial-based iid data points, these models often come with mixed data types and varying experimental conditions. Here, we show how <code>sbi</code> can be used to perform inference in such models with the <code>MNLE</code> method.</p> <p>Note, you find the original version of this notebook in the <code>sbi</code> repository under tutorials/Example_01_DecisionMakingModel.ipynb.</p>"},{"location":"tutorials/Example_01_DecisionMakingModel/#trial-based-sbi-with-mixed-data-types","title":"Trial-based SBI with mixed data types","text":"<p>In some cases, models with trial-based data additionally return data with mixed data types, e.g., continous and discrete data. For example, most computational models of decision-making have continuous reaction times and discrete choices as output.</p> <p>This can induce a problem when performing trial-based SBI that relies on learning a neural likelihood: It is challenging for most density estimators to handle both, continuous and discrete data at the same time. However, there is a recent SBI method for solving this problem, it\u2019s called Mixed Neural Likelihood Estimation (MNLE). It works just like NLE, but with mixed data types. The trick is that it learns two separate density estimators, one for the discrete part of the data, and one for the continuous part, and combines the two to obtain the final neural likelihood. Crucially, the continuous density estimator is trained conditioned on the output of the discrete one, such that statistical dependencies between the discrete and continuous data (e.g., between choices and reaction times) are modeled as well. The interested reader is referred to the original paper available here.</p> <p>MNLE was recently added to <code>sbi</code> (see this PR and also issue) and follows the same API as <code>SNLE</code>.</p> <p>In this tutorial we will show how to apply <code>MNLE</code> to mixed data, and how to deal with varying experimental conditions.</p>"},{"location":"tutorials/Example_01_DecisionMakingModel/#toy-problem-for-mnle","title":"Toy problem for <code>MNLE</code>","text":"<p>To illustrate <code>MNLE</code> we set up a toy simulator that outputs mixed data and for which we know the likelihood such we can obtain reference posterior samples via MCMC.</p> <p>Simulator: To simulate mixed data we do the following</p> <ul> <li>Sample reaction time from <code>inverse Gamma</code></li> <li>Sample choices from <code>Binomial</code></li> <li>Return reaction time \\(rt \\in (0, \\infty)\\) and choice index \\(c \\in \\{0, 1\\}\\)</li> </ul> \\[ c \\sim \\text{Binomial}(\\rho) \\\\ rt \\sim \\text{InverseGamma}(\\alpha=2, \\beta) \\\\ \\] <p>Prior: The priors of the two parameters \\(\\rho\\) and \\(\\beta\\) are independent. We define a <code>Beta</code> prior over the probabilty parameter of the <code>Binomial</code> used in the simulator and a <code>Gamma</code> prior over the shape-parameter of the <code>inverse Gamma</code> used in the simulator:</p> \\[ p(\\beta, \\rho) = p(\\beta) \\; p(\\rho) ; \\\\ p(\\beta) = \\text{Gamma}(1, 0.5) \\\\ p(\\text{probs}) = \\text{Beta}(2, 2) \\] <p>Because the <code>InverseGamma</code> and the <code>Binomial</code> likelihoods are well-defined we can perform MCMC on this problem and obtain reference-posterior samples.</p> <pre><code>import matplotlib.pyplot as plt\nimport torch\nfrom pyro.distributions import InverseGamma\nfrom torch import Tensor\nfrom torch.distributions import Beta, Binomial, Categorical, Gamma\n\nfrom sbi.analysis import pairplot\nfrom sbi.inference import MNLE, MCMCPosterior\nfrom sbi.inference.potentials.base_potential import BasePotential\nfrom sbi.inference.potentials.likelihood_based_potential import (\n    MixedLikelihoodBasedPotential,\n)\nfrom sbi.utils import MultipleIndependent, mcmc_transform\nfrom sbi.utils.conditional_density_utils import ConditionedPotential\nfrom sbi.utils.metrics import c2st\nfrom sbi.utils.torchutils import atleast_2d\n</code></pre> <pre><code># Toy simulator for mixed data\ndef mixed_simulator(theta: Tensor, concentration_scaling: float = 1.0):\n    \"\"\"Returns a sample from a mixed distribution given parameters theta.\n\n    Args:\n        theta: batch of parameters, shape (batch_size, 2) concentration_scaling:\n        scaling factor for the concentration parameter of the InverseGamma\n        distribution, mimics an experimental condition.\n\n    \"\"\"\n    beta, rho = theta[:, :1], theta[:, 1:]\n\n    choices = Binomial(probs=rho).sample()\n    rts = InverseGamma(\n        concentration=concentration_scaling * torch.ones_like(beta), rate=beta\n    ).sample()\n\n    return torch.cat((rts, choices), dim=1)\n\n\n# The potential function defines the ground truth likelihood and allows us to\n# obtain reference posterior samples via MCMC.\nclass BinomialGammaPotential(BasePotential):\n\n    def __init__(self, prior, x_o, concentration_scaling=1.0, device=\"cpu\"):\n        super().__init__(prior, x_o, device)\n        self.concentration_scaling = concentration_scaling\n\n    def __call__(self, theta, track_gradients: bool = True):\n        theta = atleast_2d(theta)\n\n        with torch.set_grad_enabled(track_gradients):\n            iid_ll = self.iid_likelihood(theta)\n\n        return iid_ll + self.prior.log_prob(theta)\n\n    def iid_likelihood(self, theta):\n        batch_size = theta.shape[0]\n        num_trials = self.x_o.shape[0]\n        theta = theta.reshape(batch_size, 1, -1)\n        beta, rho = theta[:, :, :1], theta[:, :, 1:]\n        # vectorized\n        logprob_choices = Binomial(probs=rho).log_prob(\n            self.x_o[:, 1:].reshape(1, num_trials, -1)\n        )\n\n        logprob_rts = InverseGamma(\n            concentration=self.concentration_scaling * torch.ones_like(beta),\n            rate=beta,\n        ).log_prob(self.x_o[:, :1].reshape(1, num_trials, -1))\n\n        joint_likelihood = (logprob_choices + logprob_rts).squeeze()\n\n        assert joint_likelihood.shape == torch.Size([theta.shape[0], self.x_o.shape[0]])\n        return joint_likelihood.sum(1)\n</code></pre> <pre><code># Define independent prior.\nprior = MultipleIndependent(\n    [\n        Gamma(torch.tensor([1.0]), torch.tensor([0.5])),\n        Beta(torch.tensor([2.0]), torch.tensor([2.0])),\n    ],\n    validate_args=False,\n)\n</code></pre>"},{"location":"tutorials/Example_01_DecisionMakingModel/#obtain-reference-posterior-samples-via-analytical-likelihood-and-mcmc","title":"Obtain reference-posterior samples via analytical likelihood and MCMC","text":"<pre><code>torch.manual_seed(42)\nnum_trials = 10\nnum_samples = 1000\ntheta_o = prior.sample((1,))\nx_o = mixed_simulator(theta_o.repeat(num_trials, 1))\n</code></pre> <pre><code>mcmc_kwargs = dict(\n    num_chains=20,\n    warmup_steps=50,\n    method=\"slice_np_vectorized\",\n    init_strategy=\"proposal\",\n)\n\ntrue_posterior = MCMCPosterior(\n    potential_fn=BinomialGammaPotential(prior, x_o),\n    proposal=prior,\n    theta_transform=mcmc_transform(prior, enable_transform=True),\n    **mcmc_kwargs,\n)\ntrue_samples = true_posterior.sample((num_samples,))\n</code></pre>"},{"location":"tutorials/Example_01_DecisionMakingModel/#train-mnle-and-generate-samples-via-mcmc","title":"Train MNLE and generate samples via MCMC","text":"<pre><code># Training data\nnum_simulations = 20000\n# For training the MNLE emulator we need to define a proposal distribution, the prior is\n# a good choice.\nproposal = prior\ntheta = proposal.sample((num_simulations,))\nx = mixed_simulator(theta)\n\n# Train MNLE and obtain MCMC-based posterior.\ntrainer = MNLE()\nestimator = trainer.append_simulations(theta, x).train(training_batch_size=1000)\n</code></pre> <pre><code> Neural network successfully converged after 65 epochs.\n</code></pre> <pre><code># Build posterior from the trained estimator and prior.\nmnle_posterior = trainer.build_posterior(prior=prior)\n\nmnle_samples = mnle_posterior.sample((num_samples,), x=x_o, **mcmc_kwargs)\n</code></pre>"},{"location":"tutorials/Example_01_DecisionMakingModel/#compare-mnle-and-reference-posterior","title":"Compare MNLE and reference posterior","text":"<pre><code># Plot them in one pairplot as contours (obtained via KDE on the samples).\nfig, ax = pairplot(\n    [\n        prior.sample((1000,)),\n        true_samples,\n        mnle_samples,\n    ],\n    points=theta_o,\n    diag=\"kde\",\n    upper=\"contour\",\n    upper_kwargs=dict(levels=[0.95]),\n    diag_kwargs=dict(bins=100),\n    fig_kwargs=dict(\n        points_offdiag=dict(marker=\"*\", markersize=10),\n        points_colors=[\"k\"],\n    ),\n    labels=[r\"$\\beta$\", r\"$\\rho$\"],\n    figsize=(6, 6),\n)\n\nplt.sca(ax[1, 1])\nplt.legend(\n    [\"Prior\", \"Reference\", \"MNLE\", r\"$\\theta_o$\"],\n    frameon=False,\n    fontsize=12,\n);\n</code></pre> <p>We see that the inferred <code>MNLE</code> posterior nicely matches the reference posterior, and how both inferred a posterior that is quite different from the prior.</p> <p>Because MNLE training is amortized we can obtain another posterior given a different observation with potentially a different number of trials, just by running MCMC again (without re-training <code>MNLE</code>):</p>"},{"location":"tutorials/Example_01_DecisionMakingModel/#repeat-inference-with-different-x_o-that-contains-more-trials","title":"Repeat inference with different <code>x_o</code> that contains more trials","text":"<pre><code>num_trials = 50\nx_o = mixed_simulator(theta_o.repeat(num_trials, 1))\ntrue_samples = true_posterior.sample((num_samples,), x=x_o, **mcmc_kwargs)\nmnle_samples = mnle_posterior.sample((num_samples,), x=x_o, **mcmc_kwargs)\n</code></pre> <pre><code># Plot them in one pairplot as contours (obtained via KDE on the samples).\nfig, ax = pairplot(\n    [\n        prior.sample((1000,)),\n        true_samples,\n        mnle_samples,\n    ],\n    points=theta_o,\n    diag=\"kde\",\n    upper=\"contour\",\n    diag_kwargs=dict(bins=100),\n    upper_kwargs=dict(levels=[0.95]),\n    fig_kwargs=dict(\n        points_offdiag=dict(marker=\"*\", markersize=10),\n        points_colors=[\"k\"],\n    ),\n    labels=[r\"$\\beta$\", r\"$\\rho$\"],\n    figsize=(6, 6),\n)\n\nplt.sca(ax[1, 1])\nplt.legend(\n    [\"Prior\", \"Reference\", \"MNLE\", r\"$\\theta_o$\"],\n    frameon=False,\n    fontsize=12,\n);\n</code></pre> <pre><code>print(\"c2st between true and MNLE posterior:\", c2st(true_samples, mnle_samples).item())\n</code></pre> <pre><code>c2st between true and MNLE posterior: 0.593\n</code></pre> <p>Again we can see that the posteriors match nicely. In addition, we observe that the posterior\u2019s (epistemic) uncertainty reduces as we increase the number of trials.</p> <p>Note: <code>MNLE</code> is trained on single-trial data. Theoretically, density estimation is perfectly accurate only in the limit of infinite training data. Thus, training with a finite amount of training data naturally induces a small bias in the density estimator. As we observed above, this bias is so small that we don\u2019t really notice it, e.g., the <code>c2st</code> scores were close to 0.5. However, when we increase the number of trials in <code>x_o</code> dramatically (on the order of 1000s) the small bias can accumulate over the trials and inference with <code>MNLE</code> can become less accurate.</p>"},{"location":"tutorials/Example_01_DecisionMakingModel/#mnle-with-experimental-conditions","title":"MNLE with experimental conditions","text":"<p>In the perceptual decision-making research, it is common to design experiments with varying experimental decisions, e.g., to vary the difficulty of the task. During parameter inference, it can be beneficial to incorporate the experimental conditions.</p> <p>In MNLE, we are learning an emulator that should be able to generate synthetic experimental data including reaction times and choices given different experimental conditions. Thus, to make MNLE work with experimental conditions, we need to include them in the training process, i.e., treat them like auxiliary parameters of the simulator:</p> <pre><code># define a simulator wrapper in which the experimental condition are contained\n# in theta and passed to the simulator.\ndef sim_wrapper(theta):\n    # simulate with experiment conditions\n    return mixed_simulator(\n        # we assume the first two parameters are beta and rho\n        theta=theta[:, :2],\n        # we treat the third concentration parameter as an experimental condition\n        # add 1 to deal with 0 values from Categorical distribution\n        concentration_scaling=theta[:, 2:] + 1,\n    )\n</code></pre> <pre><code># Define a proposal that contains both, priors for the parameters and a discrte\n# prior over experimental conditions.\nproposal = MultipleIndependent(\n    [\n        Gamma(torch.tensor([1.0]), torch.tensor([0.5])),\n        Beta(torch.tensor([2.0]), torch.tensor([2.0])),\n        Categorical(probs=torch.ones(1, 3)),  # 3 discrete conditions\n    ],\n    validate_args=False,\n)\n\n# Simulated data\nnum_simulations = 10000\nnum_samples = 1000\ntheta = proposal.sample((num_simulations,))\nx = sim_wrapper(theta)\nassert x.shape == (num_simulations, 2)\n\n# simulate observed data and define ground truth parameters\nnum_trials = 10\ntheta_o = proposal.sample((1,))\ntheta_o[0, 2] = 2.0  # set condition to 2 as in original simulator.\n# NOTE: we use the same experimental condition for all trials.\nx_o = sim_wrapper(theta_o.repeat(num_trials, 1))\n</code></pre>"},{"location":"tutorials/Example_01_DecisionMakingModel/#obtain-ground-truth-posterior-via-mcmc","title":"Obtain ground truth posterior via MCMC","text":"<p>We obtain a ground-truth posterior via MCMC by using the PotentialFunctionProvider.</p> <p>For that, we first the define the actual prior, i.e., the distribution over the parameter we want to infer (not the proposal).</p> <p>Thus, we leave out the discrete prior over experimental conditions.</p> <pre><code>prior = MultipleIndependent(\n    [\n        Gamma(torch.tensor([1.0]), torch.tensor([0.5])),\n        Beta(torch.tensor([2.0]), torch.tensor([2.0])),\n    ],\n    validate_args=False,\n)\nprior_transform = mcmc_transform(prior)\n\n# We can now use the PotentialFunctionProvider to obtain a ground-truth\n# posterior via MCMC.\ntrue_posterior_samples = MCMCPosterior(\n    BinomialGammaPotential(\n        prior,\n        x_o,\n        concentration_scaling=float(theta_o[0, 2])\n        + 1.0,  # add one because the sim_wrapper adds one (see above)\n    ),\n    theta_transform=prior_transform,\n    proposal=prior,\n    **mcmc_kwargs,\n).sample((num_samples,), show_progress_bars=True)\n</code></pre>"},{"location":"tutorials/Example_01_DecisionMakingModel/#train-mnle-including-experimental-conditions","title":"Train MNLE including experimental conditions","text":"<pre><code>trainer = MNLE(proposal)\nestimator = trainer.append_simulations(theta, x).train()\n</code></pre> <pre><code> Neural network successfully converged after 60 epochs.\n</code></pre>"},{"location":"tutorials/Example_01_DecisionMakingModel/#construct-conditional-potential-function","title":"Construct conditional potential function","text":"<p>We have now an emulator for the extended simulator, i.e., the one that has both the model parameters and the experimental condition as parameters. </p> <p>To obtain posterior samples conditioned on a particular experimental condition (and on x_o), we need to construct a corresponding potential function that can return the log likelihood of the model parameters, but conditioned on the experimental condition.</p> <pre><code>theta_o.shape\n</code></pre> <pre><code># We define the potential function for the complete, unconditional MNLE-likelihood\npotential_fn = MixedLikelihoodBasedPotential(estimator, proposal, x_o)\n\n# Then we use the potential to construct the conditional potential function.\n# Here, we tell the constructor to condition on the last dimension (index 2) by\n# passing dims_to_sample=[0, 1].\nconditioned_potential_fn = ConditionedPotential(\n    potential_fn,\n    condition=theta_o,\n    dims_to_sample=[0, 1],\n)\n\n# Using this potential function, we can now obtain conditional samples.\nmnle_posterior = MCMCPosterior(\n    potential_fn=conditioned_potential_fn,\n    theta_transform=prior_transform,\n    proposal=prior,\n    **mcmc_kwargs\n)\nconditional_samples = mnle_posterior.sample((num_samples,), x=x_o)\n</code></pre> <pre><code># Finally, we can compare the ground truth conditional posterior with the\n# MNLE-conditional posterior.\nfig, ax = pairplot(\n    [\n        prior.sample((1000,)),\n        true_posterior_samples,\n        conditional_samples,\n    ],\n    points=theta_o,\n    diag=\"kde\",\n    upper=\"contour\",\n    diag_kwargs=dict(bins=100),\n    upper_kwargs=dict(levels=[0.95]),\n    fig_kwargs=dict(\n        points_offdiag=dict(marker=\"*\", markersize=10),\n        points_colors=[\"k\"],\n    ),\n    labels=[r\"$\\beta$\", r\"$\\rho$\"],\n)\n\nplt.sca(ax[1, 1])\nplt.legend(\n    [\"Prior\", \"Reference\", \"MNLE\", r\"$\\theta_o$\"],\n    frameon=False,\n    fontsize=12,\n);\n</code></pre> <p></p> <p>They match accurately, showing that we can indeed post-hoc condition the trained MNLE likelihood on different experimental conditions.</p>"}]}